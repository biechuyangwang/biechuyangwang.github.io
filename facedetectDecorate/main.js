/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, { enumerable: true, get: getter });
            /******/
        }
        /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __webpack_require__.r = function(exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
            /******/
        }
        /******/
        Object.defineProperty(exports, '__esModule', { value: true });
        /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __webpack_require__.t = function(value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/
        if (mode & 8) return value;
        /******/
        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
        /******/
        var ns = Object.create(null);
        /******/
        __webpack_require__.r(ns);
        /******/
        Object.defineProperty(ns, 'default', { enumerable: true, value: value });
        /******/
        if (mode & 2 && typeof value != 'string')
            for (var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
        /******/
        return ns;
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() { return module['default']; } :
            /******/
            function getModuleExports() { return module; };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = "./index.ts");
    /******/
})
/************************************************************************/
/******/
({

    /***/
    "./index.ts":
    /*!******************!*\
      !*** ./index.ts ***!
      \******************/
    /*! no exports provided */
    /***/
        (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */
        var _paddlejs_models_facedetect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @paddlejs-models/facedetect */ "./node_modules/@paddlejs-models/facedetect/lib/index.js");
        /* harmony import */
        var _paddlejs_models_facedetect__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(_paddlejs_models_facedetect__WEBPACK_IMPORTED_MODULE_0__);
        var __awaiter = (undefined && undefined.__awaiter) || function(thisArg, _arguments, P, generator) {
            function adopt(value) { return value instanceof P ? value : new P(function(resolve) { resolve(value); }); }
            return new(P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }

                function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }

                function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        var __generator = (undefined && undefined.__generator) || function(thisArg, body) {
            var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] },
                f, y, t, g;
            return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;

            function verb(n) { return function(v) { return step([n, v]); }; }

            function step(op) {
                if (f) throw new TypeError("Generator is already executing.");
                while (_) try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                    if (y = 0, t) op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                            if (op[0] === 6 && _.label < t[1]) { _.label = t[1];
                                t = op; break; }
                            if (t && _.label < t[2]) { _.label = t[2];
                                _.ops.push(op); break; }
                            if (t[2]) _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                } catch (e) { op = [6, e];
                    y = 0; } finally { f = t = 0; }
                if (op[0] & 5) throw op[1];
                return { value: op[0] ? op[1] : void 0, done: true };
            }
        };

        var resCanvas = document.getElementById('resCanvas');
        var resCtx = resCanvas.getContext('2d');
        var defaultImgPath = './img/multi_small_face.jpeg';
        var fileReader = new FileReader();
        var loading = document.getElementById('loading');
        var faceDetector = new _paddlejs_models_facedetect__WEBPACK_IMPORTED_MODULE_0__["FaceDetector"]();
        var faceDecoration = null;
        load();
        document.getElementById('uploadImg').onchange = function() {
            loadFile(this);
        };

        function load() {
            return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            return [4, faceDetector.init()];
                        case 1:
                            _a.sent();
                            return [4, Object(_paddlejs_models_facedetect__WEBPACK_IMPORTED_MODULE_0__["createImage"])('./img/facedecoration.png')];
                        case 2:
                            faceDecoration = _a.sent();
                            run(defaultImgPath);
                            return [2];
                    }
                });
            });
        }

        function run(imgPath) {
            return __awaiter(this, void 0, void 0, function() {
                var imgEle, res;
                return __generator(this, function(_a) {
                    switch (_a.label) {
                        case 0:
                            loading.style.display = 'block';
                            return [4, Object(_paddlejs_models_facedetect__WEBPACK_IMPORTED_MODULE_0__["createImage"])(imgPath)];
                        case 1:
                            imgEle = _a.sent();
                            drawImage(imgEle);
                            return [4, faceDetector.detect(imgEle, { shrink: 0.4 })];
                        case 2:
                            res = _a.sent();
                            drawDecoration(res);
                            loading.style.display = 'none';
                            return [2];
                    }
                });
            });
        }

        function drawImage(img) {
            var naturalWidth = img.naturalWidth,
                naturalHeight = img.naturalHeight;
            resCanvas.width = naturalWidth;
            resCanvas.height = naturalHeight;
            resCtx.drawImage(img, 0, 0, naturalWidth, naturalHeight);
        }

        function drawDecoration(data) {
            data.sort(function(item1, item2) {
                return item1.width * item1.height - item2.width * item2.height;
            });
            data.forEach(function(item) {
                resCtx.lineWidth = 4;
                var x = item.left * resCanvas.width;
                var y = item.top * resCanvas.height;
                var w = item.width * resCanvas.width;
                var h = item.height * resCanvas.height;
                var ratio = 1.7;
                var decW = ratio * w;
                var decH = ratio * h;
                var decY = y - (decH - h) / 2;
                var decX = x - (decW - w) / 2;
                resCtx.drawImage(faceDecoration, decX, decY, decW, decH);
            });
        }

        function loadFile(ipt) {
            if (!ipt.files || !ipt.files[0]) {
                return;
            }
            fileReader.onload = function(evt) {
                if (evt.target && typeof evt.target.result === 'string') {
                    run(evt.target.result);
                }
            };
            fileReader.readAsDataURL(ipt.files[0]);
        }


        /***/
    }),

    /***/
    "./node_modules/@paddlejs-models/facedetect/lib/index.js":
    /*!***************************************************************!*\
      !*** ./node_modules/@paddlejs-models/facedetect/lib/index.js ***!
      \***************************************************************/
    /*! no static exports found */
    /***/
        (function(module, exports, __webpack_require__) {

        ! function(n, e) { true ? module.exports = e() : undefined }(this, (function() { return function(n) { var e = {};

                function t(o) { if (e[o]) return e[o].exports; var r = e[o] = { i: o, l: !1, exports: {} }; return n[o].call(r.exports, r, r.exports, t), r.l = !0, r.exports } return t.m = n, t.c = e, t.d = function(n, e, o) { t.o(n, e) || Object.defineProperty(n, e, { enumerable: !0, get: o }) }, t.r = function(n) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n, "__esModule", { value: !0 }) }, t.t = function(n, e) { if (1 & e && (n = t(n)), 8 & e) return n; if (4 & e && "object" == typeof n && n && n.__esModule) return n; var o = Object.create(null); if (t.r(o), Object.defineProperty(o, "default", { enumerable: !0, value: n }), 2 & e && "string" != typeof n)
                        for (var r in n) t.d(o, r, function(e) { return n[e] }.bind(null, r)); return o }, t.n = function(n) { var e = n && n.__esModule ? function() { return n.default } : function() { return n }; return t.d(e, "a", e), e }, t.o = function(n, e) { return Object.prototype.hasOwnProperty.call(n, e) }, t.p = "/", t(t.s = 1) }([function(n, e, t) { n.exports = (() => { var n = { 911: (n, e) => { "use strict"; var t = function() { if ("undefined" != typeof self) return self; if ("undefined" != typeof window) return window; if (void 0 !== t) return t; throw new Error("unable to locate global object") }();
                                n.exports = e = t.fetch, t.fetch && (e.default = t.fetch.bind(t)), e.Headers = t.Headers, e.Request = t.Request, e.Response = t.Response }, 994: (n, e, t) => { "use strict";
                                t.r(e), t.d(e, { PaddlejsBackend: () => Pn, Runner: () => vn, Transformer: () => F, coreUtils: () => o, env: () => f, interfaces: () => r, registerBackend: () => b, registerOp: () => x }); var o = {};
                                t.r(o), t.d(o, { AddItemToVars: () => u, delUselessData: () => c, findVarByKey: () => a, getGlobalInterface: () => i, getOrMakeGlobalProperty: () => s, traverseVars: () => l }); var r = {};

                                function i() { var n; if ("undefined" != typeof window) n = window;
                                    else if (void 0 !== t.g) n = t.g;
                                    else { if ("undefined" == typeof self) throw new Error("Could not find a global object");
                                        n = self } return n }

                                function s(n, e) { var t = i(); return t[n] || (t[n] = e), t[n] }

                                function a(n, e) { return Array.isArray(n) ? n.find((function(n) { return n.name === e })) : n[e] }

                                function u(n, e) { var t = Array.isArray(n),
                                        o = Array.isArray(e) ? e : [e];
                                    t ? o.forEach((function(e) { for (var t = null, o = 0; o < n.length; o++)
                                            if (n[o].name === e.name) { t = o; break }
                                        null !== t ? n[t] = e : n.push(e) })) : o.forEach((function(e) { n[e.name] = e })) }

                                function l(n, e) { Array.isArray(n) ? n.forEach((function(n) { e(n) })) : Object.keys(n).forEach((function(t) { e(n[t]) })) }

                                function c(n) { if (n.ops = null, n.vars instanceof Array)
                                        for (var e = 0; e < n.vars.length; e++) n.vars[e].data && delete n.vars[e].data;
                                    else
                                        for (var t in n.vars) n.vars[t].data && delete n.vars[t].data }
                                t.r(r), t.d(r, { BufferType: () => g, GraphType: () => v, UniformType: () => m, WasmMemoryType: () => _ }); const f = s("env", new(function() {
                                    function n() { this.ENV = {} } return n.prototype.set = function(n, e) { this.ENV[n] = e }, n.prototype.get = function(n) { return this.ENV[n] }, n }())); var h = function(n, e, t, o) { return new(t || (t = Promise))((function(r, i) {
                                            function s(n) { try { u(o.next(n)) } catch (n) { i(n) } }

                                            function a(n) { try { u(o.throw(n)) } catch (n) { i(n) } }

                                            function u(n) { var e;
                                                n.done ? r(n.value) : (e = n.value, e instanceof t ? e : new t((function(n) { n(e) }))).then(s, a) }
                                            u((o = o.apply(n, e || [])).next()) })) },
                                    p = function(n, e) { var t, o, r, i, s = { label: 0, sent: function() { if (1 & r[0]) throw r[1]; return r[1] }, trys: [], ops: [] }; return i = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (i[Symbol.iterator] = function() { return this }), i;

                                        function a(i) { return function(a) { return function(i) { if (t) throw new TypeError("Generator is already executing."); for (; s;) try { if (t = 1, o && (r = 2 & i[0] ? o.return : i[0] ? o.throw || ((r = o.return) && r.call(o), 0) : o.next) && !(r = r.call(o, i[1])).done) return r; switch (o = 0, r && (i = [2 & i[0], r.value]), i[0]) {
                                                            case 0:
                                                            case 1:
                                                                r = i; break;
                                                            case 4:
                                                                return s.label++, { value: i[1], done: !1 };
                                                            case 5:
                                                                s.label++, o = i[1], i = [0]; continue;
                                                            case 7:
                                                                i = s.ops.pop(), s.trys.pop(); continue;
                                                            default:
                                                                if (!((r = (r = s.trys).length > 0 && r[r.length - 1]) || 6 !== i[0] && 2 !== i[0])) { s = 0; continue } if (3 === i[0] && (!r || i[1] > r[0] && i[1] < r[3])) { s.label = i[1]; break } if (6 === i[0] && s.label < r[1]) { s.label = r[1], r = i; break } if (r && s.label < r[2]) { s.label = r[2], s.ops.push(i); break }
                                                                r[2] && s.ops.pop(), s.trys.pop(); continue }
                                                        i = e.call(n, s) } catch (n) { i = [6, n], o = 0 } finally { t = r = 0 }
                                                    if (5 & i[0]) throw i[1]; return { value: i[0] ? i[1] : void 0, done: !0 } }([i, a]) } } }; const d = function() {
                                    function n(n) { this.urlConf = { dir: "", main: "" }, this.separateChunk = !0, this.chunkNum = 1, this.dataType = "binary", this.params = { type: "fetch" }, this.inNode = !1, this.isLocalFile = !1, this.realFetch = function() { throw new Error("ERROR: empty fetch funciton") }; var e = n,
                                            t = "model.json"; if (n.endsWith(".json")) { var o = n.lastIndexOf("/") + 1;
                                            e = n.substr(0, o), t = n.substr(o) } else "/" !== n.charAt(n.length - 1) && (e = n + "/");
                                        this.isLocalFile = 0 !== e.indexOf("http"), this.urlConf = { dir: this.isLocalFile ? "/" === e.charAt(0) ? "" + e : "/" + e : e, main: t }, this.inNode = "node" === f.get("platform") } return n.prototype.load = function() { return h(this, void 0, void 0, (function() { var e; return p(this, (function(t) { switch (t.label) {
                                                    case 0:
                                                        return [4, this.fetchModel()];
                                                    case 1:
                                                        return e = t.sent(), this.separateChunk = !!e.chunkNum && e.chunkNum > 0, this.chunkNum = this.separateChunk ? e.chunkNum : 0, this.separateChunk ? "binary" !== this.dataType ? [3, 3] : [4, this.fetchChunks().then((function(t) { return n.allocateParamsVar(e.vars, t) }))] : [3, 3];
                                                    case 2:
                                                        t.sent(), t.label = 3;
                                                    case 3:
                                                        return [2, e] } })) })) }, n.prototype.fetchOneChunk = function(n) { return h(this, void 0, void 0, (function() { return p(this, (function(e) { switch (e.label) {
                                                    case 0:
                                                        return f.get("fetch") ? [4, f.get("fetch")(n, { type: "arrayBuffer" })] : [3, 2];
                                                    case 1:
                                                        return [2, e.sent()];
                                                    case 2:
                                                        return [2, this.fetch(n).then((function(n) { return n.arrayBuffer() }))] } })) })) }, n.prototype.fetchJson = function(n) { return this.fetch(n).then((function(n) { return n.json() })) }, n.prototype.getFileName = function(n) { return "chunk_" + n + ".dat" }, n.prototype.fetchChunks = function() { return h(this, void 0, void 0, (function() { var n, e, t; return p(this, (function(o) { for (n = this.chunkNum, e = [], t = 1; t <= n; t++) e.push(this.fetchOneChunk(this.urlConf.dir + this.getFileName(t))); return [2, Promise.all(e).then((function(n) { var e, t = 0,
                                                        o = [];
                                                    n.forEach((function(n) { e = new Float32Array(n), o.push(e), t += e.length })); var r = new Float32Array(t),
                                                        i = 0; return o.forEach((function(n) { n.forEach((function(n) { r[i] = n, i += 1 })) })), r }))] })) })) }, n.allocateParamsVar = function(n, e) { var t, o = 0;
                                        l(n, (function(n) { t = n.shape.reduce((function(n, e) { return n * e })), n.persistable && (n.data = e.slice(o, o + t), o += t) })) }, n.prototype.fetch = function(n, e) { if (f.get("fetch")) return f.get("fetch")(n, e || {}); var o = (e || this.params).method || "get",
                                            r = new(this.inNode ? t(911).Headers : Headers); return this.realFetch = this.inNode ? this.isLocalFile ? this.fetchLocalFile : t(911) : window.fetch.bind(window), this.realFetch(n, { method: o, headers: r }) }, n.prototype.fetchLocalFile = function(n) { var e = t(993); return new Promise((function(t, o) { try { t(e.readFileSync(n, "utf8")) } catch (n) { o(n) } })) }, n.prototype.fetchModel = function() { var n = this,
                                            e = this.params,
                                            t = this.urlConf.dir + this.urlConf.main,
                                            o = null; return "fetch" === e.type && (o = new Promise((function(o, r) { n.fetch(t, e).then((function(e) { return f.get("fetch") ? e : n.isLocalFile && n.inNode ? JSON.parse(e) : e.json() })).then((function(n) { return o(n) })).then((function(n) { return r(n) })) }))), o }, n }(); var g, _, m, v;! function(n) { n.FrameBuffer = "frameBuffer", n.ColorBuffer = "colorBuffer" }(g || (g = {})),
                                function(n) { n.memory100 = "100", n.memory200 = "200", n.memory300 = "300", n.memory400 = "400", n.memory500 = "500", n.memory600 = "600", n.memory700 = "700", n.memory800 = "800", n.memory900 = "900" }(_ || (_ = {})),
                                function(n) { n.uniform1f = "1f", n.uniform1fv = "1fv", n.uniform1i = "1i", n.uniform1iv = "1iv", n.uniform2f = "2f", n.uniform2fv = "2fv", n.uniform2i = "2i", n.uniform2iv = "2iv", n.uniform3f = "3f", n.uniform3fv = "3fv", n.uniform3i = "3i", n.uniform3iv = "3iv", n.uniform4f = "4f", n.uniform4fv = "4fv", n.uniform4i = "4i", n.uniform4iv = "4iv" }(m || (m = {})),
                                function(n) { n.SingleOutput = "single", n.MultipleOutput = "multiple", n.MultipleInput = "multipleInput" }(v || (v = {})); var P = { opRegistry: { ops: {} }, backend: "", backendInstance: null };

                                function x(n, e) { var t = n.conf,
                                        o = n.params,
                                        r = n.main,
                                        i = n.mainFunc,
                                        s = n.textureFuncConf,
                                        a = n.commonFuncConf,
                                        u = n.behaviors,
                                        l = void 0 === u ? [] : u,
                                        c = P.backend + "_" + e;
                                    P.opRegistry.ops[c] || (P.opRegistry.ops[c] = { name: e, conf: t, params: o, main: r, mainFunc: i, textureFuncConf: s, commonFuncConf: a, behaviors: l }) }

                                function b(n, e, t) { n && (P.backend = n), e && (P.backendInstance = e), t && Object.keys(t).forEach((function(n) { x(t[n], n) })) }
                                P = s("GLOBALS", P); var T = i();
                                T.ImageBitmap || (T.ImageBitmap = function() {}); const y = function() {
                                        function n(n, e) { this.id = "", this.type = "", this.inputs = {}, this.outputs = {}, this.attrs = {}, this.subAttrs = [], this.next = "", this.opData = null, this.isPacked = !1, this.bufferType = g.FrameBuffer, this.uniform = null; var t = n.inputs,
                                                o = n.outputs,
                                                r = n.attrs,
                                                i = void 0 === r ? {} : r,
                                                s = n.type,
                                                a = n.isPacked,
                                                u = void 0 !== a && a,
                                                l = n.bufferType,
                                                c = void 0 === l ? g.FrameBuffer : l,
                                                f = n.uniform,
                                                h = void 0 === f ? null : f;
                                            this.id = s + "_" + +new Date + "_" + e, this.inputs = t, this.outputs = o, this.attrs = i, this.subAttrs = n["sub-attrs"] || [], this.uniform = h, this.type = s, this.isPacked = u, this.bufferType = c, this.next = "", this.opData = null } return Object.defineProperty(n.prototype, "inputsName", { get: function() { var n = this,
                                                    e = []; return Object.keys(this.inputs).forEach((function(t) { e.push(n.inputs[t][0]) })), e }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "outputsName", { get: function() { return this.outputs.Output || this.outputs.Out || this.outputs.Y }, enumerable: !1, configurable: !0 }), n.prototype.execute = function(n) { P.backendInstance.runProgram(this.opData, n) }, n }(),
                                    F = function(n) { this.name = n }; var w, E = (w = function(n, e) { return (w = Object.setPrototypeOf || { __proto__: [] }
                                            instanceof Array && function(n, e) { n.__proto__ = e } || function(n, e) { for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (n[t] = e[t]) })(n, e) }, function(n, e) {
                                        function t() { this.constructor = n }
                                        w(n, e), n.prototype = null === e ? Object.create(e) : (t.prototype = e.prototype, new t) }),
                                    A = { conv2d: function(n, e) { var t = n.attrs.strides,
                                                o = n.inputs.Input[0],
                                                r = n.inputs.Filter[0]; if ("image" === o) return !1; var i = a(e, o).shape,
                                                s = a(e, r).shape; return !t.find((function(n) { return n > 1 })) && i[i.length - 1 - 2] % 4 == 0 && 4 === s.length && s[0] % 4 == 0 && s[1] % 4 == 0 } };

                                function O(n) { return { type: "packed_2_unpacked", attrs: {}, inputs: { Input: [n.inputName] }, outputs: { Output: [n.outputName] } } }

                                function V(n) { return { type: "unpacked_2_packed", attrs: {}, inputs: { Input: [n.inputName] }, outputs: { Output: [n.outputName] } } }

                                function C(n, e) { Object.keys(n.inputs).forEach((function(e) { n.inputs[e] = [n.inputs[e] + "_packed"] })), Object.keys(n.outputs).forEach((function(e) { n.outputs[e] = [n.outputs[e] + "_packed"] })), n.type = n.type + "_packing", n.id = n.type + "_" + +new Date + "_" + e.length, n.isPacked = !0 } const S = function(n) {
                                    function e() { return n.call(this, "TexturePacking") || this } return E(e, n), e.prototype.transform = function() { for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e]; if ("webgl" === P.backend && f.get("webgl_pack_channel")) { var t = n[0],
                                                o = n[1],
                                                r = n[2],
                                                i = "depthwise_conv2d" === t.type ? "conv2d" : t.type,
                                                s = A[i]; if (s && s(t, o)) { var a = t.inputs,
                                                    u = t.outputs,
                                                    l = a.Input[0],
                                                    c = u.Output ? u.Output[0] : u.Out[0],
                                                    h = V({ inputName: l, outputName: l + "_packed" }),
                                                    p = r.length;
                                                r.push(new y(h, p)), C(t, r); var d = O({ inputName: c + "_packed", outputName: c }),
                                                    g = r.length + 1;
                                                r.push(new y(d, g)) } } }, e }(F); var k = function() { var n = function(e, t) { return (n = Object.setPrototypeOf || { __proto__: [] }
                                            instanceof Array && function(n, e) { n.__proto__ = e } || function(n, e) { for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (n[t] = e[t]) })(e, t) }; return function(e, t) {
                                        function o() { this.constructor = e }
                                        n(e, t), e.prototype = null === t ? Object.create(t) : (o.prototype = t.prototype, new o) } }(); const R = function(n) {
                                    function e() { return n.call(this, "FormatInputsX") || this } return k(e, n), e.prototype.transform = function() { for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e]; var t = n[0],
                                            o = ["concat", "connect", "fc", "rnn_origin", "rnn_matmul"]; if (o.includes(t.type)) { var r = t.inputs; if (("rnn_origin" === t.type || "rnn_matmul" === t.type) && r.WeightList.length > 0) r.WeightList.forEach((function(n, e) { r["weightlist_" + e] = [n] }));
                                            else { var i = r.X || r.Input;
                                                i.length > 1 && (i.forEach((function(n, e) { r["origin" + (e > 0 ? "_" + e : "")] = [n] })), delete r.X, delete r.Input) } } }, e }(F); var I = function() { var n = function(e, t) { return (n = Object.setPrototypeOf || { __proto__: [] }
                                                instanceof Array && function(n, e) { n.__proto__ = e } || function(n, e) { for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (n[t] = e[t]) })(e, t) }; return function(e, t) {
                                            function o() { this.constructor = e }
                                            n(e, t), e.prototype = null === t ? Object.create(t) : (o.prototype = t.prototype, new o) } }(),
                                    M = function() { for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length; var o = Array(n),
                                            r = 0; for (e = 0; e < t; e++)
                                            for (var i = arguments[e], s = 0, a = i.length; s < a; s++, r++) o[r] = i[s]; return o };

                                function L(n, e) { var t = a(e, n); return t ? t.shape : [] }

                                function j(n, e, t, o) { for (var r = M(e), i = 0, s = 0, a = n; s < a.length; s++) i += L(a[s], o)[t]; return r[t] = i, { name: n[n.length - 1] + "_out", shape: r } } const D = function(n) {
                                    function e() { return n.call(this, "splitOp") || this } return I(e, n), e.prototype.transform = function() { for (var n, e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]; for (var o = e[0], r = e[1], i = 0, s = o.length; i < s; i++) { var a = o[i]; if ("concat" === a.type && (null === (n = a.inputs) || void 0 === n ? void 0 : n.X) && !(a.inputs.X.length <= 4)) { var l = a.attrs,
                                                    c = a.inputs,
                                                    f = a.outputs,
                                                    h = c.X,
                                                    p = h.length,
                                                    d = Math.ceil((p - 4) / 3) + 1,
                                                    g = f.Out[0],
                                                    _ = L(g, r),
                                                    m = l.axis || 0;
                                                m = m > -1 ? m : _.length + m; for (var v = [], P = [], x = h.slice(0, 4), b = void 0, T = 0; T < d; T++) { var y = 0 === T ? x : h.slice(3 * T + 1, 3 * (T + 1) + 1),
                                                        F = j(y, _, m, r);
                                                    0 !== T && y.splice(0, 0, b.name), F.shape[m] += b ? b.shape[m] : 0; var w = { Out: [F.name] };
                                                    P.push({ attrs: l, inputs: { X: y }, outputs: w, type: "concat" }), v.push(F), b = F }
                                                P[d - 1].outputs.Out = [g], o.splice.apply(o, M([i, 1], P)), u(r, v) } } }, e }(F); var N = function() { for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length; var o = Array(n),
                                        r = 0; for (e = 0; e < t; e++)
                                        for (var i = arguments[e], s = 0, a = i.length; s < a; s++, r++) o[r] = i[s]; return o };

                                function B(n) { if (n.length < 4) { for (var e = [], t = 0; t < 4 - n.length; t++) e.push(1); return e.concat(n) } return N(n) }

                                function U(n) { return n.reduce((function(n, e) { return n + e })) }

                                function G(n, e) { var t = n.length; return 4 - t + (e > -1 ? e : t + e) }

                                function W(n, e) { for (var t = e[0], o = e[1], r = e[2], i = e[3], s = r * i, a = o * r * i, u = [], l = 0; l < t; l++)
                                        for (var c = 0; c < i; c++)
                                            for (var f = 0; f < o; f++)
                                                for (var h = 0; h < r; h++) u.push(n[l * a + f * s + h * i + c]); return new Float32Array(u) }

                                function H(n) { for (var e, t = n.data, o = n.shape, r = N(o).reverse(), i = 0, s = r.length - 1; i < s; i++) e = X(e || t, r[i]); return e }

                                function X(n, e) { for (var t = [], o = 0, r = n.length; o < r; o += e) t.push(n.slice(o, o + e)); return t } var z = function() { var n = function(e, t) { return (n = Object.setPrototypeOf || { __proto__: [] }
                                                instanceof Array && function(n, e) { n.__proto__ = e } || function(n, e) { for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (n[t] = e[t]) })(e, t) }; return function(e, t) {
                                            function o() { this.constructor = e }
                                            n(e, t), e.prototype = null === t ? Object.create(t) : (o.prototype = t.prototype, new o) } }(),
                                    q = "fetch_pack"; const Y = function(n) {
                                    function e() { return n.call(this, "PackOut") || this } return z(e, n), e.prototype.transform = function() { for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e]; if (f.get("webgl_pack_output")) { var t = n[0],
                                                o = n[1],
                                                r = t.find((function(n) { return "fetch" === n.type })),
                                                i = r.inputs.X[0],
                                                s = a(o, i),
                                                l = B(s.shape),
                                                c = l[0],
                                                h = l[1],
                                                p = l[2],
                                                d = l[3],
                                                g = { attrs: {}, inputs: { X: [i] }, outputs: { Y: [q] }, type: "pack_out" },
                                                _ = h * d,
                                                m = Math.ceil(c * p / 4),
                                                v = { name: q, shape: [1, 1, m, _], persistable: !1 };
                                            r.inputs.X = [q], r.attrs.origin_shape = [c, h, p, d], t.push(g), u(o, [v]) } }, e }(F); var K = function() { var n = function(e, t) { return (n = Object.setPrototypeOf || { __proto__: [] }
                                                instanceof Array && function(n, e) { n.__proto__ = e } || function(n, e) { for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (n[t] = e[t]) })(e, t) }; return function(e, t) {
                                            function o() { this.constructor = e }
                                            n(e, t), e.prototype = null === t ? Object.create(t) : (o.prototype = t.prototype, new o) } }(),
                                    Z = "img_pre_processed",
                                    J = "img_origin"; const Q = function(n) {
                                        function e() { return n.call(this, "FeedProcess") || this } return K(e, n), e.prototype.transform = function() { for (var n = [], e = 0; e < arguments.length; e++) n[e] = arguments[e]; var t = n[0],
                                                o = n[1],
                                                r = n[2]; if (r.webglFeedProcess || f.get("webgl_gpu_pipeline")) { var i = r.mean,
                                                    s = void 0 === i ? [0, 0, 0] : i,
                                                    l = r.std,
                                                    c = void 0 === l ? [1, 1, 1] : l,
                                                    h = r.scale,
                                                    p = void 0 === h ? [1, 1] : h,
                                                    d = r.pos,
                                                    g = void 0 === d ? [0, 0] : d,
                                                    _ = r.feedShape,
                                                    v = a(o, "image"),
                                                    P = v.shape,
                                                    x = P[2],
                                                    b = P[3];
                                                v.shape = [1, 1, x, b]; var T = Object.assign({}, v);
                                                T.name = Z, T.shape = [1, 3, _.fh, _.fw], T.persistable = !1, delete T.data; var y = Object.assign({}, v);
                                                y.name = J, y.shape = [1, 1, _.fh, _.fw], y.persistable = !1, delete y.data, u(o, [y, T]); var F = t.find((function(n) { var e = n.inputs; return Object.keys(e).find((function(n) { return "image" === e[n][0] })) })),
                                                    w = F.inputs;
                                                Object.keys(w).forEach((function(n) { "image" === w[n][0] && (w[n][0] = Z) })); var E = { attrs: { mean: s, std: c }, inputs: { X: [J] }, outputs: { Y: [Z] }, type: "feedPost" },
                                                    A = { attrs: { mean: s, std: c, scale: p, pos: g }, inputs: { X: ["image"] }, outputs: { Y: [J] }, type: "imgFeed", uniform: { u_scale: { type: m.uniform2fv, value: [1, 1] }, u_pos: { type: m.uniform2fv, value: [0, 0] } }, isPacked: !0 };
                                                t.splice(1, 0, E), t.splice(1, 0, A) } }, e }(F),
                                    $ = { preTransforms: [new D, new Y, new Q], transforms: [new R, new S], postTransforms: [] }; var nn, en = function() { for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length; var o = Array(n),
                                        r = 0; for (e = 0; e < t; e++)
                                        for (var i = arguments[e], s = 0, a = i.length; s < a; s++, r++) o[r] = i[s]; return o };

                                function tn(n, e) { return n && n[e] || [] }! function(n) { n.PreTransforms = "preTransforms", n.Transforms = "transforms", n.PostTransforms = "postTransforms" }(nn || (nn = {})); const on = function() {
                                        function n(n, e) { this.weightMap = [], this.ops = [], this.vars = [], this.config = {}, this.type = v.SingleOutput, this.plugins = null, this.ops = n.ops, this.vars = n.vars, this.type = e.type || this.type, this.plugins = e.plugins, this.config = e, n.feedShape && (this.config.feedShape = n.feedShape) } return n.prototype.createGraph = function() { return this.preTransforms(), this.createOpsMap(), this.arrangeMap(), this.postTransforms(), this.weightMap }, n.prototype.preTransforms = function() { var n = this;
                                            en($.preTransforms, tn(this.plugins, nn.PreTransforms)).forEach((function(e) { e.transform(n.ops, n.vars, n.config) })) }, n.prototype.transforms = function(n, e) { var t = this;
                                            en($.transforms, tn(this.plugins, nn.Transforms)).forEach((function(o) { o.transform(n, t.vars, e) })) }, n.prototype.postTransforms = function() { var n = this;
                                            en($.postTransforms, tn(this.plugins, nn.PostTransforms)).forEach((function(e) { e.transform(n.weightMap, n.vars, n.type) })) }, n.prototype.createOpsMap = function() { for (var n = [], e = 0; e < this.ops.length; e++) { var t = n.length,
                                                    o = this.ops[e],
                                                    r = new y(o, t);
                                                this.transforms(r, n), n.push(r) }
                                            this.weightMap = n }, n.prototype.arrangeMap = function() { for (var n = {}, e = [], t = {}, o = function(o) { for (var i = r.weightMap[o], s = 0; s < i.outputsName.length; s++) { var a = i.outputsName[s];
                                                        n[a] = !0 }
                                                    e[o] = 0, t[i.id] = o, i.inputsName.length > 1 ? i.inputsName.forEach((function(t) {!0 === n[t] && e[o]++ })) : e[o] = i.inputsName.length }, r = this, i = 0; i < this.weightMap.length; i++) o(i);
                                            this.topoSort(this.weightMap, e, t) }, n.prototype.topoSort = function(n, e, t) { var o = [];
                                            o.push(n[0]); for (var r = n.slice(0), i = null, s = n[0]; o.length > 0;) { null != i && (n[t[i.id]].next = s.id), i = s, s = o.pop() || {}; for (var a = 0; a < s.outputsName.length; a++)
                                                    for (var u = 0; u < r.length; u++)
                                                        for (var l = 0; l < r[u].inputsName.length; l++)
                                                            if (r[u].inputsName[l] === s.outputsName[a] && (e[t[r[u].id]]--, 0 === e[t[r[u].id]])) { o.push(n[t[r[u].id]]), r.splice(u, 1), u--; break } } }, n.prototype.getFeedExecutor = function() { return this.weightMap.find((function(n) { return "feed" === n.type })) }, n.prototype.getFetchExecutor = function() { return this.weightMap.find((function(n) { return "fetch" === n.type })) }, n.prototype.getExecutorById = function(n) { return this.weightMap.find((function(e) { return e.id === n })) }, n }(),
                                    rn = function() {
                                        function n(n) { this.opts = {}, this.isPacked = !1, this.name = "", this.tensorId = "", this.total = 1, this.shape = [], this.unformattedShapeLength = 0, this.shape_texture = [], this.exceedMax = !1, this.data = null, this.persistable = !1, this.interpType = "NEAREST", this.dataLayout = "", this.runtime = 0, this.binding = 0; var e = n.isPacked,
                                                t = void 0 !== e && e,
                                                o = n.name,
                                                r = n.runtime,
                                                i = void 0 === r ? 0 : r,
                                                s = n.persistable,
                                                a = void 0 !== s && s,
                                                u = n.type,
                                                l = n.dataLayout,
                                                c = n.interpType,
                                                f = void 0 === c ? "NEAREST" : c,
                                                h = n.shape,
                                                p = n.data,
                                                d = n.binding,
                                                g = void 0 === d ? 0 : d;
                                            this.opts = n, this.isPacked = t, this.name = o, this.runtime = i, this.binding = g, this.persistable = a, this.interpType = f, this.tensorId = u, this.dataLayout = l, this.unformattedShapeLength = h.length, this.shape = B(h), this.total = this.shape.reduce((function(n, e) { return n * e })), n.noLayout || p && p.length && (this.data = function(n, e, t, o) { if ("nhwc" === e) { var r = t[0],
                                                        i = t[1],
                                                        s = W(n, [r, t[2], t[3], i * (o ? 4 : 1)]); return new Float32Array(s) } return new Float32Array(n) }(p, this.dataLayout, this.shape, this.isPacked), n.data = null) } return Object.defineProperty(n.prototype, "width_texture", { get: function() { var n = this.shape_texture.length; return this.shape_texture[n - 1] || 1 }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "height_texture", { get: function() { var n = this.shape_texture.length; return this.shape_texture[n - 2] || 1 }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "width_shape", { get: function() { var n = this.shape.length; return this.shape[n - 1] }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "height_shape", { get: function() { var n = this.shape.length; return this.shape[n - 2] }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "channel", { get: function() { var n = this.shape.length; return this.shape[n - 3] }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "length_shape", { get: function() { return this.shape.length || 0 }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "length_unformatted_shape", { get: function() { return this.unformattedShapeLength || 0 }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "total_shape", { get: function() { return this.total }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "numbers_shape", { get: function() { for (var n = [], e = this.shape.length, t = 0; t < e - 1; t++) { var o = this.shape.slice(t + 1).reduce((function(n, e) { return n * e }));
                                                    n.push(o) } return n.push(1), n }, enumerable: !1, configurable: !0 }), n }(),
                                    sn = { adaptPaddings: function() { for (var n in this.processedAttrs)
                                                if (Object.prototype.hasOwnProperty.call(this.processedAttrs, n) && "paddings" === n) { var e = this.processedAttrs[n],
                                                        t = e[0],
                                                        o = e[1]; return void(0 === t && 1 === o && (this.processedAttrs[n][1] = 0)) } }, setAdaptive: function() { this.processedAttrs.adaptive && 2 === this.processedAttrs.ksize.length && 1 === this.processedAttrs.ksize[0] && 1 === this.processedAttrs.ksize[1] && (this.processedAttrs.adaptive = !1, this.processedAttrs.global_pooling = !0) }, isGlobalPooling: function() { var n, e = this.tensorDataMap.origin,
                                                t = (null === (n = null == e ? void 0 : e.shape) || void 0 === n ? void 0 : n.length) || 0;
                                            t > 2 && this.processedAttrs.global_pooling && (this.processedAttrs.ksize = [e.shape[t - 2], e.shape[t - 1]]) }, setPacked: function() { var n = this.processedAttrs.ispacked;
                                            this.tensorDataMap.origin && n && this.name.indexOf("pool") > -1 && (this.name += "_winograd") }, mergeAttrs: function() { this.processedAttrs = this.subAttrs.reduce((function(n, e) { return Object.assign(n, e) }), {}) }, isApplySeparableConv: function() { if (!this.isPackedOp) { var n = this.processedAttrs.groups,
                                                    e = this.tensorDataMap.filter; if ("depthwise_conv2d" === this.name && (this.name = "conv2d"), e) { var t = e.shape,
                                                        o = t[0],
                                                        r = t[1];
                                                    o === n && 1 === r && (this.name += "_depthwise") } } }, batchComputeConv2d: function() { var n = this.tensorDataMap.filter.shape[1];
                                            this.processedAttrs.filter_nearest_vec4 = 4 * Math.floor(n / 4), this.processedAttrs.filter_remainder_vec4 = n % 4 }, processBias: function() { var n = this.tensorDataMap.bias; if (n && this.isPackedOp) { n.packed = !0; var e = n.shape,
                                                    t = [e[e.length - 1] / 4, 1, 1];
                                                n.shape = t } }, isMax: function() { var n = "max" === this.processedAttrs.pooling_type ? 1 : 0;
                                            this.processedAttrs.pooling_type = n, 1 === n && (this.name += "_max") }, transToPrelu: function() { this.processedAttrs.multi_value = "0.0", this.processedAttrs.active_function = "prelu" }, transToRelu6: function() { this.processedAttrs.multi_value = this.processedAttrs.threshold, this.processedAttrs.active_function = "relu6" }, transToHardSigmoid: function() { this.processedAttrs.multi_value = this.processedAttrs.slope || .2, this.processedAttrs.bias_value = this.processedAttrs.offset || .5, this.processedAttrs.active_function = "hardSigmoid" }, transToLeakyrelu: function() { this.processedAttrs.multi_value = this.processedAttrs.alpha, this.processedAttrs.active_function = "leakyRelu", this.name = "relu" }, transToPow: function() { this.processedAttrs.multi_value = this.processedAttrs.factor || 2, this.processedAttrs.active_function = "pow_func", this.name = "pow" }, transToSigmoid: function() { this.processedAttrs.active_function = "sigmoid" }, transToSqrt: function() { this.processedAttrs.active_function = "sqrt" }, transToTanh: function() { this.processedAttrs.active_function = "tanh_func" }, transToScale: function() { var n = this.processedAttrs.scale;
                                            this.processedAttrs.multi_value = void 0 !== n ? n : 1, this.processedAttrs.bias_value = this.processedAttrs.bias || 0; var e = this.processedAttrs.bias_after_scale;
                                            this.processedAttrs.active_function = e || void 0 === e ? "scale" : "scaleWidthBias" }, setActiveFunc: function() { var n = this.name.replace("conv2d-elementwise_add-", "");
                                            this.processedAttrs = Object.assign({ active_function: "scale", multi_value: "1.0", bias_value: "0.0", fuse_relu: !1 }, this.processedAttrs), "leaky_relu" === n && (this.processedAttrs.multi_value = this.processedAttrs.alpha, this.processedAttrs.active_function = "leakyRelu") }, normalizePerm: function() { var n = this.tensorDataMap.origin.shape.length,
                                                e = this.processedAttrs.axis,
                                                t = e.length; if (t - n > 0 && (t = (e = e.map((function(n) { return n - 1 })).filter((function(n) { return n >= 0 }))).length), t > 4) throw Error("op transpoes2 axis length exceeds maximum length 4, get " + t); for (var o = new Array(t).fill(0), r = 0; r < t; r++) o[e[r]] = r; var i = []; for (r = 0; r < 4; r++) i[r] = o[r] || 0;
                                            this.processedAttrs.perm_arr = i, this.processedAttrs.perm_size = t }, normalizeDim: function() { for (var n = this.tensorDataMap.origin.shape, e = B(n), t = G(n, this.processedAttrs.axis), o = [], r = 0; r < e[t]; r++) o[r] = r;
                                            this.processedAttrs.target_length = o.length, this.processedAttrs.target_value = o, this.processedAttrs.inputs_dim = e[t], this.processedAttrs.dim = t, 0 === this.processedAttrs.num && (this.processedAttrs.num = Object.values(this.tensorDataMap).filter((function(n) { return "out" === n.tensorName })).length || 1) }, processElementwiseAxis: function() { var n = this.tensorDataMap.origin.shape,
                                                e = this.tensorDataMap.counter.shape,
                                                t = this.processedAttrs.axis || -1;
                                            this.processedAttrs.counterLen = e.length, U(n) === U(e) ? (this.processedAttrs.axis = 0, this.processedAttrs.counterLen = 4) : (-1 === t && (t = n.length - e.length), this.processedAttrs.axis = G(n, t)) }, genElementwiseCounterPos: function() { for (var n = this.processedAttrs, e = n.counterLen, t = ["0", "0", "0", "0"], o = n.axis, r = 4 - e; r < 4; r++) t[r] = "oPos[" + o++ + "]";
                                            this.processedAttrs.counterPos = t.join(",") }, flattenShape: function() { var n = Object.values(this.tensorDataMap).find((function(n) { return n.shape.length > 2 })); if (n) { var e = B(n.shape);
                                                n.shape = [e[0] * e[2], e[1] * e[3]] } }, reshape: function() { var n = this.tensorDataMap.origin,
                                                e = this.tensorDataMap.counter,
                                                t = this.tensorDataMap.out; if (e.shape.length > n.shape.length) { var o = e;
                                                e = n, n = o } if (n.shape.length > 2 && 2 === e.shape.length) { var r = function(n, e) { void 0 === n && (n = []), void 0 === e && (e = []); var t = n.reduce((function(n, e) { return n * e })); return 1 === e.length ? [1, t] : [e[0], t / e[0]] }(n.shape, t.shape);
                                                n.shape = r } }, checkIsMerge: function() { var n = this.name.replace("conv2d-elementwise_add-", "");
                                            this.name = "conv2d_elementwise_add", "leaky_relu" === n && (this.processedAttrs.alpha && (this.processedAttrs.multi_value = this.processedAttrs.alpha), this.processedAttrs.active_function = "leakyRelu") } }; var an = function() { return (an = Object.assign || function(n) { for (var e, t = 1, o = arguments.length; t < o; t++)
                                            for (var r in e = arguments[t]) Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n }).apply(this, arguments) }; const un = function() {
                                    function n(n, e, t, o, r) { this.name = "", this.isPackedOp = !1, this.processedAttrs = {}, this.subAttrs = [], this.uniform = null, this.inputTensors = [], this.outputTensors = [], this.dataLayout = "", this.iLayer = 0, this.program = [], this.isFinalOp = !1, this.bufferType = g.FrameBuffer, this.tensorDataMap = {}, this.tensorData = []; var i = n.type,
                                            s = n.inputs,
                                            a = n.outputs,
                                            u = n.attrs,
                                            l = n.isPacked,
                                            c = n.bufferType,
                                            f = void 0 === c ? g.FrameBuffer : c,
                                            h = n.uniform,
                                            p = void 0 === h ? null : h;
                                        this.modelName = r, this.subAttrs = n.subAttrs, this.name = i, this.isPackedOp = l, this.bufferType = f, this.dataLayout = t.dataLayout || "", this.iLayer = e, this.isFinalOp = o, this.uniform = p, this.initExtendedAttrs(u), this.constructTensorData(s, a, t.vars), this.buildTensor(); var d = this.buildShaderParams();
                                        this.buildProgram(d) } return n.prototype.initExtendedAttrs = function(n) { for (var e in n)
                                            if (Object.prototype.hasOwnProperty.call(n, e)) { var t = n[e];
                                                this.processedAttrs[e] = t } }, n.prototype.constructTensorData = function(n, e, t) { var o = this;
                                        Object.keys(e).forEach((function(n) { e[n].forEach((function(r, i) { e[n][i] = o.getTensorVar(r, t) })) })), Object.keys(n).forEach((function(e) { n[e] = [o.getTensorVar(n[e][0], t)] })); var r = function(n) { if (Object.prototype.hasOwnProperty.call(e, n)) try { var t = e[n] || [{}],
                                                        r = i.getExactTensorName(n, "output");
                                                    r && t.forEach((function(n, e) { n.tensorName = r, o.tensorDataMap[r + "_" + e] = an(an({}, n), { tensorName: r, runtime: e }) })) } catch (n) { console.error(n) } },
                                            i = this; for (var s in e) r(s); for (var s in n)
                                            if (Object.prototype.hasOwnProperty.call(n, s)) { var a = n[s].length > 0 ? n[s] : [{}],
                                                    u = this.getExactTensorName(s, "input"); if (u) { var l = a[0];
                                                    l.tensorName = u, this.tensorDataMap[u] = an(an({}, l), { tensorName: u }) } } }, n.prototype.getExactTensorName = function(n, e) { return "input" === e ? { input: "origin", x: "origin", y: "counter", w: "weight" }[n.toLowerCase()] || n.toLowerCase() : { output: "out", y: "out", out: "out", scale: "scale", bias: "bias", mean: "mean", variance: "variance", mask: "out", boxes: "out", variances: "out" }[n.toLowerCase()] }, n.prototype.getTensorVar = function(n, e) { var t = a(e, n.replace(/_packed$/, "")); return t && n.endsWith("_packed") ? function(n, e) { var t = 3 === n.shape.length ? N([1], n.shape) : n.shape,
                                                o = t[0],
                                                r = t[1],
                                                i = t[2],
                                                s = t[3],
                                                a = Object.assign({}, n); if (a.name = e, a.packed = !1, r % 4 == 0) { var u = r / 4;
                                                a.packed = !0, a.shape = [o, u, i, s] } return a }(t, n) : t }, n.prototype.buildProgram = function(n) { var e = this,
                                            t = this.name,
                                            o = P.backend + "_" + t,
                                            r = P.opRegistry.ops[o]; try { if (!r && "wasm" !== f.get("backend")) throw new Error("[unregistered op] " + t); var i = this.inputTensors;
                                            this.program = this.outputTensors.map((function(t, o) { return P.backendInstance.createProgram({ op: r, outTensor: t, inputTensors: i, shaderParams: n[o], runtime: o, isFinalOp: e.isFinalOp }) })) } catch (n) { console.error(n) } }, n.prototype.processTensorDataAndAttrs = function() { var n = this; try { this.name.indexOf("conv2d-elementwise_add") > -1 ? this.name = "conv2d_elementwise_add" : this.name.indexOf("max_pool2d_with_index") > -1 && (this.name = "pool2d_max"); var e = P.backend + "_" + this.name;
                                            (P.opRegistry.ops[e] && P.opRegistry.ops[e].behaviors || []).forEach((function(e) { try { sn[e].call(n) } catch (n) { console.error(n) } })) } catch (n) { console.error(n) } }, n.prototype.buildTensor = function() { var n = this;
                                        this.processTensorDataAndAttrs(); var e = Object.values(this.tensorDataMap);
                                        e.forEach((function(e, t) { var o, r = e.tensorName,
                                                i = new rn({ type: n.modelName + "_" + e.name, name: r, shape: e.shape, data: e.data || null, persistable: e.persistable || !1, interpType: e.interpType || "NEAREST", isPacked: n.isPackedOp || e.packed || !1, binding: t, noLayout: null === (o = P.backendInstance) || void 0 === o ? void 0 : o.noLayout, dataLayout: n.dataLayout, runtime: e.runtime || 0 }); "out" === r ? n.outputTensors.push(i) : n.inputTensors.push(i), e.shape = i.shape, e.total = i.total })), this.tensorDataMap = null, this.tensorData = e }, n.prototype.buildShaderParams = function() { var n = this,
                                            e = []; return this.outputTensors.forEach((function() { var t = JSON.parse(JSON.stringify(n.processedAttrs));
                                            e.push(t) })), e }, n }(); var ln = function() { return (ln = Object.assign || function(n) { for (var e, t = 1, o = arguments.length; t < o; t++)
                                            for (var r in e = arguments[t]) Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n }).apply(this, arguments) }; const cn = function() {
                                    function n() { this.targetContext = {}, this.gapFillWith = "#fff", this.mean = [0, 0, 0], this.std = [1, 1, 1], this.bgr = !1, this.pixelWidth = 1, this.pixelHeight = 1, this.inputFeed = [], this.targetCanvas = f.get("canvas2d") || document.createElement("canvas"), this.targetContext = this.targetCanvas.getContext("2d") } return n.prototype.process = function(n, e, t) { var o = e.fill,
                                            r = e.mean,
                                            i = e.std,
                                            s = e.bgr,
                                            a = e.keepRatio,
                                            u = void 0 === a || a,
                                            l = e.scale,
                                            c = void 0 === l ? 0 : l,
                                            f = t.fc,
                                            h = void 0 === f ? 3 : f,
                                            p = t.fh,
                                            d = t.fw,
                                            g = n,
                                            _ = { gapFillWith: o || this.gapFillWith, mean: r || this.mean, std: i || this.std, bgr: s || this.bgr, keepRatio: u, scale: c, targetSize: { width: d, height: p }, targetShape: [1, h, p, d] }; return this.fromPixels(g, _) || [] }, n.prototype.fromPixels = function(n, e) { var t = [],
                                            o = { gapFillWith: e.gapFillWith, dx: 0, dy: 0, dWidth: e.targetSize.width, dHeight: e.targetSize.height },
                                            r = n,
                                            i = n.path && n.width && n.height; if (!i && !(n instanceof ImageBitmap || n instanceof HTMLVideoElement || n instanceof HTMLImageElement || n instanceof HTMLCanvasElement)) return [{ data: t, shape: e.shape || e.targetShape, name: "image", persistable: !0 }];
                                        this.pixelWidth = n.naturalWidth || n.width, this.pixelHeight = n.naturalHeight || n.height; var s = f.get("webgl_gpu_pipeline") || e.webglFeedProcess; return this.fitToTargetSize(i ? r.path : r, o, ln(ln({}, e), { inGPU: s })), t = this.getImageData(o), s ? [{ data: t = Float32Array.from(t.data), shape: [1, 1, o.dHeight, o.dWidth], name: "image", persistable: !0 }] : [{ data: t = this.allReshapeToRGB(t, e), shape: e.targetShape || e.shape, name: "image", persistable: !0 }] }, n.prototype.allReshapeToRGB = function(n, e) { for (var t = e.mean, o = e.std, r = e.targetShape, i = e.bgr, s = e.normalizeType, a = void 0 === s ? 0 : s, u = r[1], l = r[2], c = r[3], f = n.data || n, h = new Float32Array(l * c * u), p = 0, d = 0; d < l; ++d)
                                            for (var g = d * c, _ = 0; _ < c; ++_)
                                                for (var m = g + _, v = 0; v < u; ++v) { var P = i ? 4 * m + (2 - v) : 4 * m + v;
                                                    h[p] = 0 === a ? f[P] / 255 : (f[P] - 128) / 128, h[p] -= t[v], h[p] /= o[v], p++ }
                                        return W(h, [1, l, c, u]) }, n.prototype.fitToTargetSize = function(n, e, t) { var o = t || {},
                                            r = o.keepRatio,
                                            i = void 0 === r || r,
                                            s = o.inGPU,
                                            a = void 0 !== s && s,
                                            u = o.scale,
                                            l = void 0 === u ? 0 : u,
                                            c = e.dWidth,
                                            f = e.dHeight,
                                            h = a ? this.pixelWidth : c,
                                            p = a ? this.pixelHeight : f,
                                            d = a ? this.pixelWidth : c,
                                            g = a ? this.pixelHeight : f,
                                            _ = 0,
                                            m = 0; if (l) { if (d - c < 0 || g - f < 0) throw new Error("scale size smaller than target size");
                                            this.pixelWidth > this.pixelHeight ? (g = l, d = Math.round(g * this.pixelWidth / this.pixelHeight)) : (d = l, g = Math.round(d * this.pixelHeight / this.pixelWidth)), this.targetCanvas.width = h = d, this.targetCanvas.height = p = g, e.dx = (d - c) / 2, e.dy = (g - f) / 2 } else i && (c / f * this.pixelHeight / this.pixelWidth >= 1 ? a ? (h = Math.round(g * c / f), _ = Math.floor((h - d) / 2)) : (d = Math.round(g * this.pixelWidth / this.pixelHeight), _ = Math.floor((c - d) / 2)) : a ? (p = Math.round(d * f / c), m = Math.floor((p - g) / 2)) : (g = Math.round(d * this.pixelHeight / this.pixelWidth), m = Math.floor((f - g) / 2))), this.targetCanvas.width = e.dWidth = h, this.targetCanvas.height = e.dHeight = p;
                                        this.targetContext.fillStyle = e.gapFillWith, this.targetContext.fillRect(0, 0, this.targetCanvas.width, this.targetCanvas.height), this.targetContext.drawImage(n, _, m, d, g) }, n.prototype.getImageData = function(n) { var e = n.dx,
                                            t = n.dy,
                                            o = n.dWidth,
                                            r = n.dHeight; return this.targetContext.getImageData(e, t, o, r) }, n.prototype.cover = function(n, e, t, o) { var r = t,
                                            i = o; return t / o * e / n >= 1 ? r = Math.round(i * n / e) : i = Math.round(r * e / n), [r / t, i / o] }, n }(); var fn = function() { return (fn = Object.assign || function(n) { for (var e, t = 1, o = arguments.length; t < o; t++)
                                            for (var r in e = arguments[t]) Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]); return n }).apply(this, arguments) };

                                function hn(n, e, t) { for (var o = [], r = 0, i = n.length; r < i; r++) { var s = n[r];
                                        s > e && o.push({ score: s, i: r }) } return o.sort((function(n, e) { return e.score - n.score })).slice(0, t) }

                                function pn(n) { var e = n[0],
                                        t = n[1],
                                        o = n[2],
                                        r = n[3]; return o < e || r < t ? 0 : (o - e) * (r - t) }

                                function dn(n, e) { if (e[0] > n[2] || e[2] < n[0] || e[1] > n[3] || e[3] < n[1]) return 0; var t = pn(n),
                                        o = pn(e),
                                        r = function(n, e) { var t = n[0],
                                                o = n[1],
                                                r = n[2],
                                                i = n[3],
                                                s = e[0],
                                                a = e[1],
                                                u = e[2],
                                                l = e[3],
                                                c = Math.max(t, s),
                                                f = Math.max(o, a); return (Math.min(r, u) - c) * (Math.min(i, l) - f) }(n, e); return r / (t + o - r) } const gn = { multiclass_nms: function(n, e) { var t = n[0],
                                            o = void 0 === t ? [] : t,
                                            r = n[1],
                                            i = void 0 === r ? [] : r,
                                            s = H(o),
                                            a = H(i); if (!s || !a) return []; if (s = s[0], a = a[0], !(s && s.length && a && a.length)) return []; for (var u = e.nms_top_k, l = void 0 === u ? 100 : u, c = e.nms_eta, f = void 0 === c ? 1 : c, h = e.keep_top_k, p = void 0 === h ? 100 : h, d = e.background_label, g = void 0 === d ? 0 : d, _ = e.nms_threshold, m = void 0 === _ ? .3 : _, v = e.score_threshold, P = void 0 === v ? 0 : v, x = [], b = 0, T = a.length; b < T; b++) { var y = []; if (b !== g) { var F = hn(a[b], P, l); if (!F || !F.length) return []; var w = F.shift(),
                                                    E = s[w.i]; for (y.push(fn(fn({}, w), { box: E, label: b })); F.length;) { var A = F.shift();
                                                    E = s[A.i]; for (var O = !0, V = 0, C = y; V < C.length; V++)
                                                        if (dn(E, C[V].box) > m) { O = !1; break }
                                                    O && y.push(fn(fn({}, A), { box: E, label: b })), O && f < 1 && m > .5 && (m *= f) }
                                                x = x.concat(y) } } var S = x.sort((function(n, e) { return e.score - n.score })).slice(0, p).sort((function(n, e) { return n.label - e.label })).map((function(n) { return function() { for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length; var o = Array(n),
                                                    r = 0; for (e = 0; e < t; e++)
                                                    for (var i = arguments[e], s = 0, a = i.length; s < a; s++, r++) o[r] = i[s]; return o }([n.label, n.score], n.box) })); return S && S.length ? S : [] } }; var _n = function(n, e, t, o) { return new(t || (t = Promise))((function(r, i) {
                                            function s(n) { try { u(o.next(n)) } catch (n) { i(n) } }

                                            function a(n) { try { u(o.throw(n)) } catch (n) { i(n) } }

                                            function u(n) { var e;
                                                n.done ? r(n.value) : (e = n.value, e instanceof t ? e : new t((function(n) { n(e) }))).then(s, a) }
                                            u((o = o.apply(n, e || [])).next()) })) },
                                    mn = function(n, e) { var t, o, r, i, s = { label: 0, sent: function() { if (1 & r[0]) throw r[1]; return r[1] }, trys: [], ops: [] }; return i = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (i[Symbol.iterator] = function() { return this }), i;

                                        function a(i) { return function(a) { return function(i) { if (t) throw new TypeError("Generator is already executing."); for (; s;) try { if (t = 1, o && (r = 2 & i[0] ? o.return : i[0] ? o.throw || ((r = o.return) && r.call(o), 0) : o.next) && !(r = r.call(o, i[1])).done) return r; switch (o = 0, r && (i = [2 & i[0], r.value]), i[0]) {
                                                            case 0:
                                                            case 1:
                                                                r = i; break;
                                                            case 4:
                                                                return s.label++, { value: i[1], done: !1 };
                                                            case 5:
                                                                s.label++, o = i[1], i = [0]; continue;
                                                            case 7:
                                                                i = s.ops.pop(), s.trys.pop(); continue;
                                                            default:
                                                                if (!((r = (r = s.trys).length > 0 && r[r.length - 1]) || 6 !== i[0] && 2 !== i[0])) { s = 0; continue } if (3 === i[0] && (!r || i[1] > r[0] && i[1] < r[3])) { s.label = i[1]; break } if (6 === i[0] && s.label < r[1]) { s.label = r[1], r = i; break } if (r && s.label < r[2]) { s.label = r[2], s.ops.push(i); break }
                                                                r[2] && s.ops.pop(), s.trys.pop(); continue }
                                                        i = e.call(n, s) } catch (n) { i = [6, n], o = 0 } finally { t = r = 0 }
                                                    if (5 & i[0]) throw i[1]; return { value: i[0] ? i[1] : void 0, done: !0 } }([i, a]) } } }; const vn = function() {
                                        function n(n) { this.runnerConfig = {}, this.isPaused = !1, this.model = {}, this.weightMap = [], this.isExecuted = !1, this.test = !1, this.graphGenerator = {}, this.mediaProcessor = null, this.needPreheat = !0, this.feedShape = {}, this.runnerConfig = Object.assign({}, n), this.needPreheat = void 0 === n.needPreheat || n.needPreheat, this.modelName = n.modelName || Date.now().toString(), this.weightMap = [], f.set("ns", i()), "node" !== f.get("platform") && (this.mediaProcessor = new cn) } return n.prototype.init = function() { return _n(this, void 0, void 0, (function() { var n; return mn(this, (function(e) { switch (e.label) {
                                                        case 0:
                                                            return P.backendInstance ? (this.isExecuted = !1, "wasm" !== f.get("backend") ? [3, 2] : [4, Promise.all([this.load(), P.backendInstance.init()])]) : (console.error("ERROR: Haven't register backend"), [2]);
                                                        case 1:
                                                            return e.sent(), [3, 4];
                                                        case 2:
                                                            return P.backendInstance.init(), this.isExecuted = !1, [4, this.load()];
                                                        case 3:
                                                            e.sent(), e.label = 4;
                                                        case 4:
                                                            return this.genFeedData(), this.genGraph(), this.genOpData(), "wasm" !== f.get("backend") ? [3, 6] : (this.model = Object.assign(this.model, this.runnerConfig), n = this.model, [4, P.backendInstance.initWasm(this.model, this.weightMap)]);
                                                        case 5:
                                                            return n.index = e.sent(), [2, []];
                                                        case 6:
                                                            return this.needPreheat ? [4, this.preheat()] : [3, 8];
                                                        case 7:
                                                            return [2, e.sent()];
                                                        case 8:
                                                            return [2] } })) })) }, n.prototype.load = function() { return _n(this, void 0, void 0, (function() { var n, e, t, o, r, i, s, a; return mn(this, (function(u) { switch (u.label) {
                                                        case 0:
                                                            return n = this.runnerConfig, e = n.modelPath, t = n.modelObj, o = void 0 === t ? null : t, e ? (r = new d(e), i = this, [4, r.load()]) : [3, 2];
                                                        case 1:
                                                            return i.model = u.sent(), [3, 3];
                                                        case 2:
                                                            (null == o ? void 0 : o.model) && (null == o ? void 0 : o.params) && (s = o.model, a = o.params, d.allocateParamsVar(s.vars, a), this.model = s), u.label = 3;
                                                        case 3:
                                                            return [2] } })) })) }, n.prototype.genGraph = function() { this.graphGenerator = new on(this.model, this.runnerConfig), this.weightMap = this.graphGenerator.createGraph() }, n.prototype.genOpData = function() { var n = this,
                                                e = 0;
                                            this.weightMap.forEach((function(t, o) { var r = t.type; if ("feed" !== r && "fetch" !== r) { e++; var i = o === n.weightMap.length - 2,
                                                        s = new un(t, e, n.model, i, n.modelName);
                                                    t.opData = s } })), c(this.model) }, n.prototype.preheat = function() { return _n(this, void 0, void 0, (function() { var n; return mn(this, (function(e) { switch (e.label) {
                                                        case 0:
                                                            return [4, this.checkModelLoaded()];
                                                        case 1:
                                                            return e.sent(), [4, this.execute()];
                                                        case 2:
                                                            return n = e.sent(), this.isExecuted = !0, [2, n] } })) })) }, n.prototype.checkModelLoaded = function() { return _n(this, void 0, void 0, (function() { return mn(this, (function(n) { switch (n.label) {
                                                        case 0:
                                                            return 0 !== this.weightMap.length ? [3, 2] : (console.info("It's better to preheat the model before running."), [4, this.load()]);
                                                        case 1:
                                                            n.sent(), this.genFeedData(), this.genGraph(), this.genOpData(), this.isExecuted = !1, n.label = 2;
                                                        case 2:
                                                            return [2] } })) })) }, n.prototype.predict = function(n, e) { return _n(this, void 0, void 0, (function() { var t, o, r; return mn(this, (function(i) { switch (i.label) {
                                                        case 0:
                                                            return this.isPaused || !this.mediaProcessor ? [2] : (t = [], t = this.runnerConfig.webglFeedProcess ? [n] : this.mediaProcessor.process(n, this.runnerConfig, this.feedShape), o = [], "wasm" !== f.get("backend") ? [3, 3] : [4, P.backendInstance.predict(t[0].data, this.model.index)]);
                                                        case 1:
                                                            return i.sent(), [4, this.read()];
                                                        case 2:
                                                            return r = i.sent(), o = this.postProcess(r), [3, 5];
                                                        case 3:
                                                            return this.updateFeedData(t), [4, this.execute()];
                                                        case 4:
                                                            o = i.sent(), i.label = 5;
                                                        case 5:
                                                            return this.isExecuted = !0, [2, e ? e(o) : o] } })) })) }, n.prototype.predictWithFeed = function(n, e, t) { var o; return _n(this, void 0, void 0, (function() { var r, i, s, a, u, l, c, h, p, d, g, _; return mn(this, (function(m) { switch (m.label) {
                                                        case 0:
                                                            return r = this.feedShape, i = r.fc, s = void 0 === i ? 3 : i, a = r.fw, u = r.fh, Array.isArray(n) ? (null === (o = n[0]) || void 0 === o ? void 0 : o.data) ? ((d = n[0].data) instanceof Float32Array || (n[0].data = new Float32Array(d)), l = n) : l = [{ data: new Float32Array(n), shape: t || [1, s, u, a], name: "image", persistable: !0 }] : (h = (c = n).width, p = c.height, d = c.data, l = [{ data: new Float32Array(d), shape: t || [1, s, p || u, h || a], name: "image", persistable: !0 }]), g = [], "wasm" !== f.get("backend") ? [3, 3] : [4, P.backendInstance.predict(l[0].data, this.model.index)];
                                                        case 1:
                                                            return m.sent(), [4, this.read()];
                                                        case 2:
                                                            return _ = m.sent(), g = this.postProcess(_), [3, 5];
                                                        case 3:
                                                            return this.updateFeedData(l), [4, this.execute()];
                                                        case 4:
                                                            g = m.sent(), m.label = 5;
                                                        case 5:
                                                            return this.isExecuted = !0, [2, e ? e(g) : g] } })) })) }, n.prototype.genFeedData = function() { var n, e = this.runnerConfig,
                                                t = e.type,
                                                o = e.feedShape,
                                                r = e.webglFeedProcess;
                                            this.feedShape = this.model.feedShape || o; var i, s = this.feedShape,
                                                l = s.fc,
                                                c = void 0 === l ? 3 : l,
                                                h = s.fh,
                                                p = s.fw,
                                                d = this.model.vars; if (t === v.MultipleInput) { var g = this.model.ops && this.model.ops[0] && (null === (n = this.model.ops[0].inputs) || void 0 === n ? void 0 : n.X);
                                                g.length > 1 && (i = g.map((function(n) { var e = a(d, n),
                                                        t = e.shape.reverse(),
                                                        o = t[0],
                                                        r = t[1],
                                                        i = t[2],
                                                        s = t[3],
                                                        u = void 0 === s ? 1 : s; return e.data = new Float32Array(u * i * r * o), e }))) } else { var _ = "wasm" !== f.get("backend") && r ? 4 : c;
                                                i = a(d, "image"); var m = { name: "image", shape: [1, _, h, p] };
                                                i = Object.assign(m, i, { data: new Float32Array(_ * h * p).fill(1), persistable: !0 }) }
                                            u(d, i) }, n.prototype.updateFeedData = function(n) { var e = n[0],
                                                t = this.weightMap.find((function(n) { return n.opData ? n.opData.inputTensors.find((function(n) { return n.tensorId.endsWith("_image") })) : null })),
                                                o = t.opData.inputTensors.find((function(n) { return n.tensorId.endsWith("_image") })); if (o.data = e.data, this.runnerConfig.webglFeedProcess || f.get("webgl_gpu_pipeline")) { var r = e.shape || [1, 1, e.height, e.width],
                                                    i = new Uint8Array(e.data || []); if (e.width && e.height && !e.data) { var s = e.naturalWidth || e.width;
                                                    r = [1, 1, e.naturalHeight || e.height, s], i = e } var a = o.opts;
                                                a.shape = r; var u = t.opData,
                                                    l = new rn(a);
                                                l.data = i, u.inputTensors = [l]; var c = r.slice(-2),
                                                    h = c[0],
                                                    p = c[1],
                                                    d = u.outputTensors[0].shape.slice(-2),
                                                    g = d[0],
                                                    _ = d[1],
                                                    m = this.mediaProcessor.cover(p, h, _, g);
                                                t.uniform.u_scale.value = m } }, n.prototype.execute = function() { return _n(this, void 0, void 0, (function() { var n, e; return mn(this, (function(t) { switch (t.label) {
                                                        case 0:
                                                            return n = this.graphGenerator.getFeedExecutor(), this.executeOp(n), [4, this.read()];
                                                        case 1:
                                                            return e = t.sent(), [2, this.postProcess(e)] } })) })) }, n.prototype.postProcess = function(n) { var e = "wasm" === f.get("backend"); if (f.get("debug")) return n; var t = n,
                                                o = this.model,
                                                r = o.multiOutputs,
                                                i = o.postOps; if (r)
                                                if (e) t = r.map((function(e, t) { var o; return (o = {})[e.name] = n[t], o }));
                                                else { var s = 0;
                                                    t = r.map((function(e) { var t, o = e.shape.reduce((function(n, e) { return n * e })),
                                                            r = n.slice(s, o + s); return s += o, (t = {})[e.name] = r, t })) }
                                            if (r && i && i.length)
                                                for (var a = function(n, e) { var o = i[n],
                                                            r = o.type,
                                                            s = o.attrs,
                                                            a = o.inputs,
                                                            u = gn[r]; if (!u) return { value: void 0 }; var l = function() { for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length; var o = Array(n),
                                                                    r = 0; for (e = 0; e < t; e++)
                                                                    for (var i = arguments[e], s = 0, a = i.length; s < a; s++, r++) o[r] = i[s]; return o }(t),
                                                            c = Object.keys(a).map((function(n) { var e = a[n],
                                                                    t = e.name,
                                                                    o = e.shape,
                                                                    r = l.filter((function(n) { return n[t] })); return r && r[0] && r[0][t] ? { name: n, tensorId: t, data: r[0][t], shape: o } : (console.error("未获取到" + t + "的数据"), null) }));
                                                        t = u(c, s) }, u = 0, l = i.length; u < l; u++) { var c = a(u); if ("object" == typeof c) return c.value }
                                            return t }, n.prototype.executeOp = function(n) { var e; if ("fetch" !== n.type)
                                                if ("feed" !== n.type && n.execute(this.isExecuted), f.get("debug") && (null === (e = n.opData) || void 0 === e ? void 0 : e.outputTensors) && n.opData.outputTensors[n.opData.outputTensors.length - 1] && n.opData.outputTensors[n.opData.outputTensors.length - 1].tensorId === this.modelName + "_" + (f.get("ns").layerName || f.get("layerName"))) console.info(n.opData.name + "_" + n.opData.iLayer, "runner op");
                                                else if (n.next) { var t = n.next,
                                                    o = this.graphGenerator.getExecutorById(t);
                                                this.executeOp(o) } }, n.prototype.read = function() { return _n(this, void 0, void 0, (function() { var n, e, t; return mn(this, (function(o) { switch (o.label) {
                                                        case 0:
                                                            return n = this.graphGenerator.getFetchExecutor(), e = a(this.model.vars, n.inputs.X[0]), t = { name: e.name, shape: n.attrs.origin_shape || e.shape, index: this.model.index }, [4, P.backendInstance.read(t)];
                                                        case 1:
                                                            return [2, o.sent()] } })) })) }, n.prototype.stopPredict = function() { this.isPaused = !0 }, n }(),
                                    Pn = function() {} }, 993: () => {} },
                        e = {};

                    function t(o) { if (e[o]) return e[o].exports; var r = e[o] = { exports: {} }; return n[o](r, r.exports, t), r.exports } return t.d = (n, e) => { for (var o in e) t.o(e, o) && !t.o(n, o) && Object.defineProperty(n, o, { enumerable: !0, get: e[o] }) }, t.g = function() { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (n) { if ("object" == typeof window) return window } }(), t.o = (n, e) => Object.prototype.hasOwnProperty.call(n, e), t.r = n => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n, "__esModule", { value: !0 }) }, t(994) })() }, function(n, e, t) { n.exports = t(2) }, function(n, e, t) { "use strict";
                t.r(e), t.d(e, "FaceDetector", (function() { return u })), t.d(e, "createImage", (function() { return l })); var o = t(0),
                    r = (t(3), function(n, e, t, o) { return new(t || (t = Promise))((function(r, i) {
                            function s(n) { try { u(o.next(n)) } catch (n) { i(n) } }

                            function a(n) { try { u(o.throw(n)) } catch (n) { i(n) } }

                            function u(n) { var e;
                                n.done ? r(n.value) : (e = n.value, e instanceof t ? e : new t((function(n) { n(e) }))).then(s, a) }
                            u((o = o.apply(n, e || [])).next()) })) }),
                    i = function(n, e) { var t, o, r, i, s = { label: 0, sent: function() { if (1 & r[0]) throw r[1]; return r[1] }, trys: [], ops: [] }; return i = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (i[Symbol.iterator] = function() { return this }), i;

                        function a(i) { return function(a) { return function(i) { if (t) throw new TypeError("Generator is already executing."); for (; s;) try { if (t = 1, o && (r = 2 & i[0] ? o.return : i[0] ? o.throw || ((r = o.return) && r.call(o), 0) : o.next) && !(r = r.call(o, i[1])).done) return r; switch (o = 0, r && (i = [2 & i[0], r.value]), i[0]) {
                                            case 0:
                                            case 1:
                                                r = i; break;
                                            case 4:
                                                return s.label++, { value: i[1], done: !1 };
                                            case 5:
                                                s.label++, o = i[1], i = [0]; continue;
                                            case 7:
                                                i = s.ops.pop(), s.trys.pop(); continue;
                                            default:
                                                if (!(r = s.trys, (r = r.length > 0 && r[r.length - 1]) || 6 !== i[0] && 2 !== i[0])) { s = 0; continue } if (3 === i[0] && (!r || i[1] > r[0] && i[1] < r[3])) { s.label = i[1]; break } if (6 === i[0] && s.label < r[1]) { s.label = r[1], r = i; break } if (r && s.label < r[2]) { s.label = r[2], s.ops.push(i); break }
                                                r[2] && s.ops.pop(), s.trys.pop(); continue }
                                        i = e.call(n, s) } catch (n) { i = [6, n], o = 0 } finally { t = r = 0 }
                                    if (5 & i[0]) throw i[1]; return { value: i[0] ? i[1] : void 0, done: !0 } }([i, a]) } } },
                    s = { fw: 1024, fh: 1024 },
                    a = { modelPath: "https://paddlejs.cdn.bcebos.com/models/fuse/facedetect_opt/model.json", mean: [.407843137, .458823529, .482352941], std: [.5, .5, .5] },
                    u = function() {
                        function n(n) { this.modelConfig = a, this.feedShape = s, this.runner = null, this.inputSize = {}, this.modelConfig = Object.assign(this.modelConfig, n), this.feedShape = Object.assign(this.feedShape, null == n ? void 0 : n.feedShape) } return n.prototype.init = function() { return r(this, void 0, void 0, (function() { return i(this, (function(n) { switch (n.label) {
                                        case 0:
                                            return this.runner = new o.Runner(this.modelConfig), [4, this.runner.init()];
                                        case 1:
                                            return n.sent(), [2] } })) })) }, n.prototype.detect = function(n, e) { return r(this, void 0, void 0, (function() { var t, o, r, s, a, u, l; return i(this, (function(i) { switch (i.label) {
                                        case 0:
                                            return this.inputSize.naturalWidth = n.naturalWidth, this.inputSize.naturalHeight = n.naturalHeight, t = Object.assign({}, e), o = t.shrink, r = void 0 === o ? .4 : o, s = t.threshold, a = void 0 === s ? .6 : s, u = this.preprocess(n, r), [4, this.runner.predictWithFeed(u)];
                                        case 1:
                                            return l = i.sent(), [2, this.postprocessor(l, a)] } })) })) }, n.prototype.preprocess = function(n, e) { var t = this.scale = Math.min(this.inputSize.naturalWidth, this.inputSize.naturalHeight) * e; return this.runner.mediaProcessor.process(n, Object.assign({}, this.modelConfig, { scale: t }), this.feedShape) }, n.prototype.postprocessor = function(n, e) { var t = this; return n.filter((function(n) { return n[1] && n[1] > e })).map((function(n) { return t.transformData(n) })) }, n.prototype.transformData = function(n) { var e, t, o = {},
                                r = this.feedShape,
                                i = r.fw,
                                s = r.fh,
                                a = this.inputSize,
                                u = a.naturalWidth,
                                l = a.naturalHeight;
                            u > l ? e = (t = this.scale) * u / l : t = (e = this.scale) * l / u; var c = (i - e) / 2,
                                f = (s - t) / 2; return o.confidence = n[1], o.left = (n[2] * i - c) / e, o.width = (n[4] - n[2]) * i / e, o.top = (n[3] * s - f) / t, o.height = (n[5] - n[3]) * s / t, o }, n }();

                function l(n) { return new Promise((function(e) { var t = new Image;
                        t.crossOrigin = "anonymous", t.onload = function() { e(t) }, t.src = n })) } }, function(n, e, t) { n.exports = (() => { "use strict"; var n = { 646: (n, e, t) => { t.r(e), t.d(e, { GLHelper: () => b, glInstance: () => bn, ops: () => xn, webgl_types: () => o }); var o = {};
                                t.r(o), t.d(o, { UniformType: () => f }); var r = {};
                                t.r(r), t.d(r, { hardSigmoid: () => M, leakyRelu: () => S, pow_func: () => j, prelu: () => V, relu6: () => C, scale: () => k, scaleWidthBias: () => R, sigmoid: () => I, sqrt: () => L, tanh_func: () => D, transferFromNHWCtoNCHW: () => O }); var i = {};

                                function s() { var n; if ("undefined" != typeof window) n = window;
                                    else if (void 0 !== t.g) n = t.g;
                                    else { if ("undefined" == typeof self) throw new Error("Could not find a global object");
                                        n = self } return n }

                                function a(n, e) { var t = s(); return t[n] || (t[n] = e), t[n] }
                                t.r(i), t.d(i, { getPixelsFromTexturePos: () => G, getSamplerCode: () => H, getTensorPosFromArrayIndex: () => U, getValueFromTensorPos: () => N, getValueFromTensorPosPacking: () => B, moveTexture2PosToReal: () => W }); var u = { opRegistry: { ops: {} }, backend: "", backendInstance: null };
                                u = a("GLOBALS", u); var l = s();
                                l.ImageBitmap || (l.ImageBitmap = function() {}); const c = a("env", new(function() {
                                    function n() { this.ENV = {} } return n.prototype.set = function(n, e) { this.ENV[n] = e }, n.prototype.get = function(n) { return this.ENV[n] }, n }())); var f, h, p;

                                function d(n) { for (var e = n.length, t = function() { for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length; var o = Array(n),
                                                r = 0; for (e = 0; e < t; e++)
                                                for (var i = arguments[e], s = 0, a = i.length; s < a; s++, r++) o[r] = i[s]; return o }(n), o = []; e > 1;) t.splice(0, 1), o.push(t.reduce((function(n, e) { return n * e }))), e--; return o }

                                function g(n) { return n.reduce((function(n, e) { return n * e }), 1) }

                                function _(n, e) { return 0 === n.length ? "" : n.reduce((function(e, t, o) { return e + "float(" + t + ")" + (o === n.length - 1 ? ");" : ",") }), "float " + e + "[" + n.length + "] = float[](") }

                                function m(n, e) { if (1 === n.length) return "float " + e + " = float(" + n[0] + ");"; for (var t = n.length, o = "\n        vec" + t + " " + e + " = vec" + t + "(\n    ", r = 0; r < t; r++) o += "float(" + n[r] + "),"; return o.slice(0, -1) + ");" }! function(n) { n.uniform1f = "1f", n.uniform1fv = "1fv", n.uniform1i = "1i", n.uniform1iv = "1iv", n.uniform2f = "2f", n.uniform2fv = "2fv", n.uniform2i = "2i", n.uniform2iv = "2iv", n.uniform3f = "3f", n.uniform3fv = "3fv", n.uniform3i = "3i", n.uniform3iv = "3iv", n.uniform4f = "4f", n.uniform4fv = "4fv", n.uniform4i = "4i", n.uniform4iv = "4iv" }(f || (f = {})),
                                function(n) { n[n.VS_SHADER = 0] = "VS_SHADER", n[n.FS_SHADER = 1] = "FS_SHADER" }(h || (h = {})),
                                function(n) { n[n.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", n[n.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", n[n.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", n[n.INT_VEC2 = 35667] = "INT_VEC2", n[n.INT_VEC3 = 35668] = "INT_VEC3", n[n.INT_VEC4 = 35669] = "INT_VEC4", n[n.BOOL = 35670] = "BOOL", n[n.BOOL_VEC2 = 35671] = "BOOL_VEC2", n[n.BOOL_VEC3 = 35672] = "BOOL_VEC3", n[n.BOOL_VEC4 = 35673] = "BOOL_VEC4", n[n.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", n[n.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", n[n.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", n[n.SAMPLER_2D = 35677] = "SAMPLER_2D", n[n.SAMPLER_CUBE = 35678] = "SAMPLER_CUBE", n[n.FLOAT = 5126] = "FLOAT", n[n.INT = 5124] = "INT" }(p || (p = {})); var v, P = function(n, e, t) { this.size = n, this.type = e, this.location = t },
                                    x = function(n, e, t) { this.size = n, this.type = e, this.location = t },
                                    b = function() {
                                        function n() {} return n.getWebglVersion = function() { return c.get("webglVersion") }, n.createCanvas = function() { return c.get("canvas") || document && document.createElement("canvas") }, n.setWebglVersion = function(n) { c.set("webglVersion", n) }, n.setWebGLRenderingContext = function(n) { return this.gl = n, n }, n.getWebGLRenderingContext = function() { return this.gl ? this.gl : this.createWebGLRenderingContext() }, n.createWebGLRenderingContext = function() { if (this.gl) return this.gl; var n = this.createCanvas(); if (!n) return null;
                                            n.addEventListener && n.addEventListener("webglcontextlost", (function(n) { throw n.preventDefault(), Error("webgl context is lost~") }), !1); var e = n.getContext("webgl2", this.WEBGL_ATTRIBUTES); return e ? c.set("webglVersion", 2) : (c.set("webglVersion", 1), e = n.getContext("webgl", this.WEBGL_ATTRIBUTES) || n.getContext("experimental-webgl", this.WEBGL_ATTRIBUTES)), e }, n.printStates = function(n) { console.log("1. isBlendEnable = " + n.isEnabled(n.BLEND)), console.log("2. isCullFaceEnable = " + n.isEnabled(n.CULL_FACE)), console.log("3. isDepthTestEnable = " + n.isEnabled(n.DEPTH_TEST)), console.log("4. isDitherEnable = " + n.isEnabled(n.DITHER)), console.log("5. isPolygonOffsetFillEnable = " + n.isEnabled(n.POLYGON_OFFSET_FILL)), console.log("6. isSampleAlphtToCoverageEnable = " + n.isEnabled(n.SAMPLE_ALPHA_TO_COVERAGE)), console.log("7. isSampleCoverageEnable = " + n.isEnabled(n.SAMPLE_COVERAGE)), console.log("8. isScissorTestEnable = " + n.isEnabled(n.SCISSOR_TEST)), console.log("9. isStencilTestEnable = " + n.isEnabled(n.STENCIL_TEST)) }, n.printWebGLInfo = function(n) { console.log("renderer = " + n.getParameter(n.RENDERER)), console.log("version = " + n.getParameter(n.VERSION)), console.log("vendor = " + n.getParameter(n.VENDOR)), console.log("glsl version = " + n.getParameter(n.SHADING_LANGUAGE_VERSION)) }, n.printWebGLTextureInfo = function(n) { console.log("MAX_COMBINED_TEXTURE_IMAGE_UNITS = ", n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)), console.log("MAX_TEXTURE_IMAGE_UNITS = ", n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)), console.log("MAX_TEXTURE_SIZE = ", n.getParameter(n.MAX_TEXTURE_SIZE)), console.log("MAX_CUBE_MAP_TEXTURE_SIZE = ", n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)) }, n.triggerContextLostEvent = function(n) { var e = n.getExtension("WEBGL_lose_context");
                                            null !== e && e.loseContext() }, n.checkGLError = function(n) { var e = n.getError(); return 0 !== e && (console.log("WebGL Error NO: ", e), !0) }, n.setDefaultState = function(n) { n.clearColor(0, 0, 0, 0), n.clearDepth(1), n.enable(n.DEPTH_TEST), n.enable(n.CULL_FACE), n.enable(n.SCISSOR_TEST) }, n.setViewport = function(n, e) { n.viewport(e[0], e[1], e[2], e[3]) }, n.initShader = function(n, e, t) { var o = this.createShader(n, e); return this.compileShader(n, t, o), o }, n.createShader = function(n, e) { var t; if (null === (t = e === h.VS_SHADER ? n.createShader(n.VERTEX_SHADER) : n.createShader(n.FRAGMENT_SHADER))) throw new Error("WebGLShader创建失败！"); return t }, n.compileShader = function(n, e, t) { return n.shaderSource(t, e), n.compileShader(t), !1 !== n.getShaderParameter(t, n.COMPILE_STATUS) || (console.error(n.getShaderInfoLog(t)), n.deleteShader(t), !1) }, n.createProgram = function(n) { var e = n.createProgram(); if (null === e) throw new Error("WebGLProgram创建失败！"); return e }, n.linkProgram = function(n, e, t, o, r, i) { return void 0 === r && (r = null), void 0 === i && (i = null), n.attachShader(e, t), n.attachShader(e, o), null !== r && r(n, e), n.linkProgram(e), !1 === n.getProgramParameter(e, n.LINK_STATUS) ? (console.error(n.getProgramInfoLog(e)), n.deleteShader(t), n.deleteShader(o), n.deleteProgram(e), !1) : (n.validateProgram(e), !1 === n.getProgramParameter(e, n.VALIDATE_STATUS) ? (console.error(n.getProgramInfoLog(e)), n.deleteShader(t), n.deleteShader(o), n.deleteProgram(e), !1) : (null !== i && i(n, e), !0)) }, n.getProgramActiveAttribs = function(n, e, t) { for (var o = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES), r = 0; r < o; r++) { var i = n.getActiveAttrib(e, r);
                                                i && (t[i.name] = new x(i.size, i.type, n.getAttribLocation(e, i.name))) } }, n.getProgramAtciveUniforms = function(n, e, t) { for (var o = n.getProgramParameter(e, n.ACTIVE_UNIFORMS), r = 0; r < o; r++) { var i = n.getActiveUniform(e, r); if (i) { var s = n.getUniformLocation(e, i.name);
                                                    null !== s && (t[i.name] = new P(i.size, i.type, s)) } } }, n.createBuffer = function(n) { var e = n.createBuffer(); if (null === e) throw new Error("WebGLBuffer创建失败！"); return e }, n.getColorBufferData = function(n) { var e = new Uint8Array(n.drawingBufferWidth * n.drawingBufferHeight * 4); return n.readPixels(0, 0, n.drawingBufferWidth, n.drawingBufferHeight, n.RGBA, n.UNSIGNED_BYTE, e), e }, n.setUniformParam = function(n, e, t, o) { switch (t) {
                                                case f.uniform1f:
                                                    n.uniform1f(e, o); break;
                                                case f.uniform1fv:
                                                    n.uniform1fv(e, o); break;
                                                case f.uniform1i:
                                                    n.uniform1i(e, o); break;
                                                case f.uniform1iv:
                                                    n.uniform1iv(e, o); break;
                                                case f.uniform2f:
                                                    n.uniform2f(e, o[0], o[1]); break;
                                                case f.uniform2fv:
                                                    n.uniform2fv(e, o); break;
                                                case f.uniform2i:
                                                    n.uniform2i(e, o[0], o[1]); break;
                                                case f.uniform2iv:
                                                    n.uniform2iv(e, o); break;
                                                case f.uniform3f:
                                                    n.uniform3f(e, o[0], o[1], o[2]); break;
                                                case f.uniform3fv:
                                                    n.uniform3fv(e, o); break;
                                                case f.uniform3i:
                                                    n.uniform3i(e, o[0], o[1], o[2]); break;
                                                case f.uniform3iv:
                                                    n.uniform3iv(e, o); break;
                                                case f.uniform4f:
                                                    n.uniform4f(e, o[0], o[1], o[2], o[3]); break;
                                                case f.uniform4fv:
                                                    n.uniform4fv(e, o); break;
                                                case f.uniform4i:
                                                    n.uniform4i(e, o[0], o[1], o[2], o[3]); break;
                                                case f.uniform4iv:
                                                    n.uniform4iv(e, o); break;
                                                default:
                                                    console.error("[" + t + "]: unknown uniform type") } }, n.genTextureInfoFromTensorShape = function(n, e) { var t = n || 4096,
                                                o = e.shape,
                                                r = void 0 === o ? [] : o,
                                                i = function() { for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length; var o = Array(n),
                                                        r = 0; for (e = 0; e < t; e++)
                                                        for (var i = arguments[e], s = 0, a = i.length; s < a; s++, r++) o[r] = i[s]; return o }(r).sort((function(n, e) { return n - e })),
                                                s = i[0],
                                                a = i[1],
                                                u = i[2],
                                                l = s * i[3],
                                                f = a * u; if (l > t || f > t) { var h = [l, f].sort((function(n, e) { return n - e })),
                                                    p = h[0],
                                                    d = h[1],
                                                    g = function(n, e) { var t = e; if (n % t == 0) return t; for (; t < n && n % t != 0;) t++; return t }(d, Math.ceil(d / t)); if (l = p * g, f = Math.ceil(d / g), c.get("debug") && console.error("大小超限", r, [f, l]), l > t || f > t) throw new Error("Requested texture size [" + l + "x" + f + "] greater than WebGL maximum on this browser / GPU [" + t + "x" + t + "].") }
                                            e.shape_texture = [f, l] }, n.WEBGL_ATTRIBUTES = { alpha: !1, antialias: !1, premultipliedAlpha: !1, preserveDrawingBuffer: !1, depth: !1, stencil: !1, failIfMajorPerformanceCaveat: !0, powerPreference: "high-performance" }, n.gl = null, n }();! function(n) { n[n.GL_REPEAT = 0] = "GL_REPEAT", n[n.GL_MIRRORED_REPEAT = 1] = "GL_MIRRORED_REPEAT", n[n.GL_CLAMP_TO_EDGE = 2] = "GL_CLAMP_TO_EDGE" }(v || (v = {})); var T = function() {
                                        function n() {} return n.getTextureConfig = function(n) { var e, t, o, r, i, s, a, u, l = n,
                                                f = !0,
                                                h = !0; return 2 === c.get("webglVersion") ? (e = l.getExtension("EXT_color_buffer_float"), o = l.HALF_FLOAT, r = l.R32F, i = l.RGBA32F, s = l.R16F, a = l.RGBA16F, t = l.RED, u = l.RGBA32F) : (r = l.RGBA, s = l.RGBA, a = l.RGBA, i = l.RGBA, t = l.RGBA, u = l.RGBA, e = l.getExtension("OES_texture_float"), o = l.getExtension("OES_texture_half_float").HALF_FLOAT_OES, f = this.isDownloadFloatTextureEnabled(l, u), h = this.isFloatTextureReadPixelsEnabledMethod(l, 1, f)), { textureFloat: e, textureHalfFloat: o, internalFormat: r, internalFormatPacked: i, internalFormatHalfFloat: s, internalFormatPackedHalfFloat: a, textureFormat: t, downloadInternalFormat: u, frameBufferSupportFloat: f, isFloatTextureReadPixelsEnabled: h } }, n.isFloatTextureReadPixelsEnabledMethod = function(n, e, t) { var o = n; if (0 === e) return !1; if (1 === e) { if (null == o.getExtension("OES_texture_float")) return !1 } else if (null == o.getExtension("EXT_color_buffer_float") || null == o.getExtension("EXT_color_buffer_half_float")) return !1; var r = o.createFramebuffer(),
                                                i = o.createTexture();
                                            o.bindTexture(o.TEXTURE_2D, i); var s = 2 === e ? o.RGBA32F : o.RGBA;
                                            o.texImage2D(o.TEXTURE_2D, 0, s, 1, 1, 0, o.RGBA, t ? o.FLOAT : o.getExtension("OES_texture_half_float").HALF_FLOAT_OES, null), o.bindFramebuffer(o.FRAMEBUFFER, r), o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, i, 0); var a = o.checkFramebufferStatus(o.FRAMEBUFFER) === o.FRAMEBUFFER_COMPLETE;
                                            o.readPixels(0, 0, 1, 1, o.RGBA, o.FLOAT, new Float32Array(4)); var u = o.getError() === o.NO_ERROR; return a && u }, n.isDownloadFloatTextureEnabled = function(n, e) { var t = n.createTexture();
                                            n.bindTexture(n.TEXTURE_2D, t), n.texImage2D(n.TEXTURE_2D, 0, e, 1, 1, 0, n.RGBA, n.FLOAT, null); var o = n.createFramebuffer();
                                            n.bindFramebuffer(n.FRAMEBUFFER, o), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0); var r = n.checkFramebufferStatus(n.FRAMEBUFFER) === n.FRAMEBUFFER_COMPLETE; return n.bindTexture(n.TEXTURE_2D, null), n.bindFramebuffer(n.FRAMEBUFFER, null), n.deleteTexture(t), n.deleteFramebuffer(o), r }, n.uploadDataToTexture = function(n, e, t, o) { n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE); var r = t.width_texture,
                                                i = t.height_texture,
                                                s = t.data,
                                                a = n.RGBA,
                                                u = n.RGBA,
                                                l = n.FLOAT,
                                                f = s; if (s instanceof Uint8Array || s instanceof Uint8ClampedArray || !(s instanceof Float32Array || s instanceof Array)) l = n.UNSIGNED_BYTE;
                                            else if (2 === c.get("webglVersion")) { var h = c.get("webgl_force_half_float_texture");
                                                a = o ? h ? e.internalFormatPackedHalfFloat : e.internalFormatPacked : h ? e.internalFormatHalfFloat : e.internalFormat, u = o ? n.RGBA : e.textureFormat } else { for (var p = new Float32Array(r * i * 4), d = 0; d < s.length; d++) o ? p[d] = s[d] : (p[4 * d] = s[d], p[4 * d + 1] = 0, p[4 * d + 2] = 0, p[4 * d + 3] = 0);
                                                f = p }
                                            n.texImage2D(n.TEXTURE_2D, 0, a, r, i, 0, u, l, f) }, n.genOutputTexture = function(n, e, t, o) { var r = t.interpType,
                                                i = t.width_texture,
                                                s = t.height_texture,
                                                a = n.createTexture();
                                            n.bindTexture(n.TEXTURE_2D, a), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, "LINEAR" === r ? n.LINEAR : n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, "LINEAR" === r ? n.LINEAR : n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE); var u = c.get("webgl_force_half_float_texture"),
                                                l = u ? e.internalFormatPackedHalfFloat : e.internalFormatPacked,
                                                f = 2 === c.get("webglVersion") ? u ? n.HALF_FLOAT : n.FLOAT : e.frameBufferSupportFloat ? n.FLOAT : e.textureHalfFloat,
                                                h = o ? e.isFloatTextureReadPixelsEnabled ? f : n.UNSIGNED_BYTE : null; return n.texImage2D(n.TEXTURE_2D, 0, l, i, s, 0, n.RGBA, o ? h : f, null), n.bindTexture(n.TEXTURE_2D, null), a }, n }(),
                                    y = ["\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n    varying vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    ", "#version 300 es\n    in vec4 position;\n    out vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    "],
                                    F = new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
                                    w = ["length_shape", "length_unformatted_shape", "width_shape", "height_shape", "width_texture", "height_texture", "offset_x", "offset_y", "channel", "total_shape", "numbers_shape"],
                                    E = { float: ["multi_value", "bias_value"], bool: ["fuse_relu"] };

                                function A() { return "\n    " + (c.get("useModAdaptor") ? "\n            int calMod(int a, int b) {\n                float modV = mod(float(a), float(b));\n                if (modV == float(b)) {\n                    modV = 0.0;\n                }\n                return int(modV);\n            }\n        " : "\n            int calMod(int a, int b) {\n                return a - a / b * b;\n            }\n        ") + "\n    " + (c.get("useDivisionAdaptor") ? "\n            int calDivision(int a, int b) {\n                return int(float(a) / (float(b) - 0.0001));\n            }\n        " : "\n            int calDivision(int a, int b) {\n                return a / b;\n            }\n        ") + "\n    \n    float tanh_calc(float num) {\n        float res = (exp(2.0 * num) - 1.0) / (exp(2.0 * num) + 1.0);\n        return res;\n    }\n    \n    " } const O = "\nivec4 transferFromNHWCtoNCHW(\n    int sumVal,\n    const int channel,\n    const int width_shape,\n    const int height_shape,\n    const int total_shape) {\n\n    int n_origin = int(total_shape/(channel * width_shape * height_shape));\n    int new_a = calMod(sumVal, width_shape);\n    sumVal = int((sumVal - new_a) / width_shape);\n    int new_b = calMod(sumVal, height_shape);\n    sumVal = int((sumVal - new_b) / height_shape);\n    int new_g = calMod(sumVal, channel);\n    sumVal = int((sumVal - new_g) / channel);\n    int new_r = calMod(sumVal, n_origin);\n    return ivec4(new_r,new_g,new_b,new_a);\n}\n"; var V = "\nfloat prelu(float x, float p, float b) {\n    float result = x;\n    if (x < 0.0) {\n        result = x * p;\n    }\n\n    return result;\n}",
                                    C = "\nfloat relu6(float x, float threshold, float b) {\n    float result = min(max(0.0, x), threshold);\n    return result;\n}",
                                    S = "\nfloat leakyRelu(float x, float p, float b) {\n    float result = max(x, x * p);\n    return result;\n}",
                                    k = "\nfloat scale(float x, float p, float b) {\n    float result = p * x + b;\n    return result;\n}",
                                    R = "\nfloat scaleWidthBias(float x, float p, float b) {\n    float result = p * (x + b);\n    return result;\n}",
                                    I = "\nfloat sigmoid(float x, float y, float z) {\n    float result = 1.0 / (1.0 + exp(-x));\n    return result;\n}",
                                    M = "\n    float hardSigmoid(float x, float slope, float offset) {\n        float result = max(0.0, min(1.0, slope * x + offset));\n        return result;\n    }\n",
                                    L = "\n    float sqrt(float x, float slope, float offset) {\n        return sqrt(x);\n    }\n",
                                    j = "\n    float pow_func(float x, float factor, float offset) {\n        return pow(x, factor);\n    }\n",
                                    D = "\nfloat tanh_func(float x, float y, float z) {\n    return tanh_calc(x);\n}";

                                function N(n, e) { var t = e.width_shape,
                                        o = e.height_shape,
                                        r = e.channel,
                                        i = e.width_texture; return "\n    // 根据tensor坐标获取这个tensor位置的值\n    float getValueFromTensorPos_" + n + "(int n, int c, int h, int w) {\n        int index = n * " + t * o * r + " + c * " + t * o + " + h * " + t + " + w;\n        int pos_w = int(mod(float(index), float(" + i + ")));\n        int pos_h = index / int(" + i + ");\n        vec4 pixels = TEXTURE2D(texture_" + n + ",\n            vec2(\n                (float(pos_w)  + 0.5) / float(" + i + "),\n                (float(pos_h) + 0.5) / float(" + e.height_texture + ")\n            )\n        );\n        // 只用了r通道\n        return pixels.r;\n    }" }

                                function B(n, e) { var t = e.channel,
                                        o = e.height_shape,
                                        r = e.width_texture,
                                        i = e.height_texture,
                                        s = e.width_shape; return "\n    // 根据tensor坐标获取这个tensor位置的值\n    vec4 getValueFromTensorPosPacking_" + n + "(int n, int c, int h, int w) {\n        int index = n * " + s * o * t + " + c * " + s * o + " + h * " + s + " + w;\n        int pos_w = int(mod(float(index), float(" + r + ")));\n        int pos_h = index / int(" + r + ");\n        vec4 pixels = TEXTURE2D(texture_" + n + ",\n            vec2(\n                (float(pos_w)  + 0.5) / float(" + r + "),\n                (float(pos_h) + 0.5) / float(" + i + ")\n            )\n        );\n        // 只用了r通道\n        return pixels;\n    }" }

                                function U(n, e) { var t = e.numbers_shape,
                                        o = e.length_shape; if (1 === o) return "\n            int getTensorPosFromArrayIndex_" + n + "(int n) {\n                return calMod(n, " + t[0] + ");\n            }\n        "; for (var r = "ivec" + o + "(" + t.join(", ") + ")", i = "pos[0] = n / " + t[0] + ";", s = 1; s < o; s++) i += "\n            n = calMod(n, " + t[s - 1] + ");\n            pos[" + s + "] = calDivision(n, " + t[s] + ");\n        "; return "\n    ivec" + o + " shapeVec_" + n + " = " + r + ";\n    ivec" + o + " getTensorPosFromArrayIndex_" + n + "(int n) {\n        ivec" + o + " pos;\n        " + i + "\n        return pos;\n    }\n    " }

                                function G(n) { return "\n    #define getPixelsFromTexturePos_" + n + "(pos) TEXTURE2D(texture_" + n + ", pos)\n    " }

                                function W(n, e) { return "\n    vec2 moveTexture2PosToReal_" + n + "(vec2 v) {\n        vec2 v2;\n        v2.x = v.x * float(" + e.width_texture + ");\n        v2.y = v.y * float(" + e.height_texture + ");\n        return v2;\n    }\n    " }

                                function H(n) { return "uniform sampler2D texture_" + n + ";" }

                                function X(n, e, t, o, s) { var a, u, l = "",
                                        f = e.name,
                                        h = e.mainFunc,
                                        p = e.textureFuncConf,
                                        d = void 0 === p ? {} : p,
                                        g = e.commonFuncConf; try { var _ = function(n, e, t) { for (var o = {}, r = Object.assign({}, e), i = [], s = 0, a = n; s < a.length; s++) { for (var u = a[s], l = u.name, c = {}, f = 0, h = w; f < h.length; f++) void 0 !== u[v = h[f]] && (c[v] = u[v]);
                                                    o[l] = c, i.push(l) } for (var p = 0, d = Object.keys(E); p < d.length; p++)
                                                    for (var g = d[p], _ = 0, m = E[g]; _ < m.length; _++) { var v;
                                                        void 0 !== e[v = m[_]] && (r[v] = g + "(" + e[v] + ")") }
                                                return e.active_function && (r.active_function = e.active_function), r.runtime = t, { textureParams: o, opParams: r, active_function: e.active_function } }(t, o, s),
                                            m = _.textureParams,
                                            v = _.opParams,
                                            P = _.active_function,
                                            x = 2 === c.get("webglVersion") ? " #version 300 es\n            #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision mediump float;\n            precision mediump int;\n        #endif      \n        " : " #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision highp float;\n            precision highp int;\n        #endif\n        ",
                                            b = function(n) { var e = n.frameBufferSupportFloat,
                                                    t = n.isFinalOp,
                                                    o = n.isFloatTextureReadPixelsEnabled; return 2 === c.get("webglVersion") ? "\n        // 顶点shader透传的材质坐标\n        in vec2 vCoord;\n        out vec4 outColor;\n        void setOutput(float result) {\n            result = fuse_op(result);\n            outColor.r = result;\n        }\n        void setPackedOutput(vec4 result) {\n            outColor = result;\n        }\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n        " + A() + "\n    " : e ? "\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor.r = result;\n            }\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n            " + A() + "\n    " : t && !o ? "\n        varying vec2 vCoord;\n        varying vec4 outColor;\n\n        const float FLOAT_MAX = 1.70141184e38;\n        const float FLOAT_MIN = 1.17549435e-38;\n\n        #define isnan(value) isnan_custom(value)\n        bool isnan_custom(float val) {\n            return (val > 0. || val < 1. || val == 0.) ? false : true;\n        }\n\n        " + A() + "\n\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n\n        lowp vec4 encode_float(highp float v) {\n            if (isnan(v)) {\n            return vec4(255, 255, 255, 255);\n            }\n\n            highp float av = abs(v);\n\n            if(av < FLOAT_MIN) {\n            return vec4(0.0, 0.0, 0.0, 0.0);\n            } else if(v > FLOAT_MAX) {\n            return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n            } else if(v < -FLOAT_MAX) {\n            return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n            }\n\n            highp vec4 c = vec4(0,0,0,0);\n\n            highp float e = floor(log2(av));\n            highp float m = exp2(fract(log2(av))) - 1.0;\n\n            c[2] = floor(128.0 * m);\n            m -= c[2] / 128.0;\n            c[1] = floor(32768.0 * m);\n            m -= c[1] / 32768.0;\n            c[0] = floor(8388608.0 * m);\n\n            highp float ebias = e + 127.0;\n            c[3] = floor(ebias / 2.0);\n            ebias -= c[3] * 2.0;\n            c[2] += floor(ebias) * 128.0;\n\n            c[3] += 128.0 * step(0.0, -v);\n\n            return c / 255.0;\n        }\n\n        void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor = encode_float(result);\n        }\n        " : "\n            #define isnan(value) isnan_custom(value)\n            bool isnan_custom(float val) {\n                return (val > 0. || val < 1. || val == 0.) ? false : true;\n            }\n\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                if(isnan(result)) {\n                    gl_FragColor.r = 0.0;\n                }else {\n                    gl_FragColor.r = result;\n                }\n            }\n\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n\n            " + A() + "\n\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n        " }(n),
                                            T = function(n) { var e = "",
                                                    t = ""; if (n.fuse_opt)
                                                    for (var o in n.fuse_opt) { var i = o,
                                                            s = 0,
                                                            a = 0; switch (o) {
                                                            case "scale":
                                                                var u = n.fuse_opt.scale.bias_after_scale,
                                                                    l = n.fuse_opt.scale.scale;
                                                                s = void 0 !== l ? l : 1, a = n.fuse_opt.scale.bias || 0, !1 === u && void 0 !== u && (i = "scaleWidthBias"); break;
                                                            case "relu":
                                                                i = "prelu"; break;
                                                            case "relu6":
                                                                s = n.fuse_opt[o].threshold; break;
                                                            case "hard_sigmoid":
                                                                i = "hardSigmoid", s = n.fuse_opt[o].slope || .2, a = n.fuse_opt[o].offset || .5; break;
                                                            case "leakyRelu":
                                                                s = n.fuse_opt[o].alpha; break;
                                                            case "pow":
                                                                i = "pow_func", s = n.fuse_opt[o].factor || 2; break;
                                                            case "tanh":
                                                                i = "tanh_func" }
                                                        e += r[i], t += "res = " + i + "(x, float(" + s + "), float(" + a + "));" }
                                                return "\n        " + e + "\n        \n        float fuse_op(float x) {\n            float res = x;\n            " + t + "\n            return res;\n        }\n    " }(v),
                                            y = function(n, e, t, o) { if (!n) return ""; var r = Object.assign({}, n);
                                                r["@all"] && function(n, e) { var t = e.filter((function(n) { return "out" !== n.name })),
                                                        o = n["@all"];
                                                    t.forEach((function(e) { var t = e.name;
                                                        n[t] ? n[t].concat(o) : n[t] = o })), delete n["@all"] }(r, o); for (var s = "", a = "", u = 0, l = Object.keys(r); u < l.length; u++) { var c = l[u]; if (e[c]) { a += H(c); for (var f = 0, h = r[c]; f < h.length; f++) { var p = h[f]; if (i[p]) try { s += i[p](c, e[c], t) } catch (n) { console.error(n) } } } } return "\n    " + a + "\n    " + s + "\n    " }(d, m, v, t),
                                            F = function(n) { return void 0 === n ? "" : "\n        int layer_run_time = " + n + ";\n    " }(s),
                                            O = function(n) { var e, t, o, r, i; return "\n        \n    vec2 _2d_shape_texture_out = vec2(float(" + n.width_texture + "), float(" + n.height_texture + "));\n    \n        " + (t = (e = n).height_shape, o = e.width_shape, "\n    ivec4 getOutputTensorPos() {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int(" + e.width_texture + ");\n\n        int n1 = int(index / " + (r = o * t * e.channel) + ");\n        int c1 = int(calMod(index, " + r + ") / " + (i = o * t) + ");\n        int h1 = int(calMod(index, " + i + ") / " + o + ");\n        int w1 = calMod(index, " + o + ");\n        return ivec4(n1, c1, h1, w1);\n    }\n    \n    ") }(m.out);
                                        a = l = " " + x + "\n            " + T + "\n            " + b + "\n            " + function(n) { if (!n) return ""; for (var e = "", t = 0, o = n; t < o.length; t++) { var i = o[t];
                                                r[i] && (e += r[i]) } return e }(g) + "\n            " + (P ? r[P] : "") + "\n            " + y + "\n            " + F + "\n            " + O + "\n            " + h(m, v) + "\n        ", u = 1 === c.get("webglVersion") ? "texture2D" : "texture", l = a.replace(/\bTEXTURE2D\b/g, u) } catch (n) { console.error("[" + f + "]: " + n) } return l } const z = function() {
                                    function n(n, e, t, o) { var r = n;
                                        this.vShader = e; try { this.fShader = this.initShader(r, t, "fragment"), this.shape = o && o.shape; var i = this.program = r.createProgram();
                                            r.attachShader(i, this.vShader), r.attachShader(i, this.fShader), r.linkProgram(i) } catch (n) { throw new Error(n) } } return n.prototype.initShader = function(n, e, t) { void 0 === t && (t = "vertex"); var o, r = "vertex" === t ? n.VERTEX_SHADER : n.FRAGMENT_SHADER; if ("vertex" === t && this.vShader) o = this.vShader;
                                        else if (o = n.createShader(r), "vertex" === t && (this.vShader = o), n.shaderSource(o, e), n.compileShader(o), !n.getShaderParameter(o, n.COMPILE_STATUS)) throw new Error("compile: " + n.getShaderInfoLog(o)); return o }, n.prototype.setProgram = function(n, e, t) { n.useProgram(this.program), t || this.runVertexShader(n, e) }, n.prototype.runVertexShader = function(n, e) { var t = n.getAttribLocation(this.program, "position");
                                        n.enableVertexAttribArray(t), n.bindBuffer(n.ARRAY_BUFFER, e), n.vertexAttribPointer(t, 2, n.FLOAT, !1, 0, 0) }, n.Sampler = "uSampler", n }(); var q, Y = (q = function(n, e) { return (q = Object.setPrototypeOf || { __proto__: [] }
                                            instanceof Array && function(n, e) { n.__proto__ = e } || function(n, e) { for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (n[t] = e[t]) })(n, e) }, function(n, e) {
                                        function t() { this.constructor = n }
                                        q(n, e), n.prototype = null === e ? Object.create(e) : (t.prototype = e.prototype, new t) }),
                                    K = function(n, e, t, o) { return new(t || (t = Promise))((function(r, i) {
                                            function s(n) { try { u(o.next(n)) } catch (n) { i(n) } }

                                            function a(n) { try { u(o.throw(n)) } catch (n) { i(n) } }

                                            function u(n) { var e;
                                                n.done ? r(n.value) : (e = n.value, e instanceof t ? e : new t((function(n) { n(e) }))).then(s, a) }
                                            u((o = o.apply(n, e || [])).next()) })) },
                                    Z = function(n, e) { var t, o, r, i, s = { label: 0, sent: function() { if (1 & r[0]) throw r[1]; return r[1] }, trys: [], ops: [] }; return i = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (i[Symbol.iterator] = function() { return this }), i;

                                        function a(i) { return function(a) { return function(i) { if (t) throw new TypeError("Generator is already executing."); for (; s;) try { if (t = 1, o && (r = 2 & i[0] ? o.return : i[0] ? o.throw || ((r = o.return) && r.call(o), 0) : o.next) && !(r = r.call(o, i[1])).done) return r; switch (o = 0, r && (i = [2 & i[0], r.value]), i[0]) {
                                                            case 0:
                                                            case 1:
                                                                r = i; break;
                                                            case 4:
                                                                return s.label++, { value: i[1], done: !1 };
                                                            case 5:
                                                                s.label++, o = i[1], i = [0]; continue;
                                                            case 7:
                                                                i = s.ops.pop(), s.trys.pop(); continue;
                                                            default:
                                                                if (!((r = (r = s.trys).length > 0 && r[r.length - 1]) || 6 !== i[0] && 2 !== i[0])) { s = 0; continue } if (3 === i[0] && (!r || i[1] > r[0] && i[1] < r[3])) { s.label = i[1]; break } if (6 === i[0] && s.label < r[1]) { s.label = r[1], r = i; break } if (r && s.label < r[2]) { s.label = r[2], s.ops.push(i); break }
                                                                r[2] && s.ops.pop(), s.trys.pop(); continue }
                                                        i = e.call(n, s) } catch (n) { i = [6, n], o = 0 } finally { t = r = 0 }
                                                    if (5 & i[0]) throw i[1]; return { value: i[0] ? i[1] : void 0, done: !0 } }([i, a]) } } }; const J = function(n) {
                                        function e() { var e = n.call(this) || this; return e.cacheTextures = {}, e.uniformLocations = {}, e.texturesMap = {}, e.queryList = [], e.currentTexture = null, e.width_shape_out = 1, e.height_shape_out = 1, e.width_texture_out = 1, e.height_texture_out = 1, e.channel = 0, e.total_shape = 0, e } return Y(e, n), e.prototype.init = function() { return K(this, void 0, void 0, (function() { var n; return Z(this, (function(e) { return n = this.gl = b.createWebGLRenderingContext(), this.gl ? (this.glVersion = b.getWebglVersion(), this.textureConf = T.getTextureConfig(n), this.MAX_TEXTURE_SIZE = c.get("MAX_TEXTURE_SIZE") || n.getParameter(n.MAX_TEXTURE_SIZE), n.disable(n.DEPTH_TEST), n.disable(n.STENCIL_TEST), n.disable(n.BLEND), n.disable(n.DITHER), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SAMPLE_COVERAGE), n.enable(n.SCISSOR_TEST), n.enable(n.CULL_FACE), n.cullFace(n.BACK), this.vertexBuffer = n.createBuffer(), n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer), n.bufferData(n.ARRAY_BUFFER, F, n.STATIC_DRAW), this.vShader = b.initShader(n, h.VS_SHADER, y[this.glVersion - 1]), this.frameBuffer = n.createFramebuffer(), n.bindFramebuffer(n.FRAMEBUFFER, this.frameBuffer), this.pbo = n.createBuffer(), [2]) : [2] })) })) }, e.prototype.createProgram = function(n) { var e = this,
                                                t = n.op,
                                                o = n.outTensor,
                                                r = n.inputTensors,
                                                i = n.shaderParams,
                                                s = n.runtime,
                                                a = n.isFinalOp,
                                                u = null; try { var l = function() { for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length; var o = Array(n),
                                                        r = 0; for (e = 0; e < t; e++)
                                                        for (var i = arguments[e], s = 0, a = i.length; s < a; s++, r++) o[r] = i[s]; return o }([o], r);
                                                l.forEach((function(n) { return b.genTextureInfoFromTensorShape(e.MAX_TEXTURE_SIZE, n) })); var c = X(this.textureConf, t, l, i, s);
                                                (u = new z(this.gl, this.vShader, c, o)).fsCode = c; var f = T.genOutputTexture(this.gl, this.textureConf, o, a);
                                                this.texturesMap[o.tensorId] = f, this.program = u } catch (n) { console.error("webgl createProgram: " + t.name + " -- " + n) } return u }, e.prototype.runProgram = function(n, e) { var t = this,
                                                o = function(n, e) { if (2 === e && c.get("performance")) { var t = n.getExtension("EXT_disjoint_timer_query_webgl2"); if (!t) return; var o = n.createQuery(); return n.beginQuery(t.TIME_ELAPSED_EXT, o), o } return null }(this.gl, this.glVersion),
                                                r = n.isPackedOp;
                                            n.program.forEach((function(o, i) { var s = n.outputTensors[i],
                                                    a = s.tensorId;
                                                t.setOutProps(s), "frameBuffer" === n.bufferType ? t.attachFrameBuffer(a) : t.attachColorBuffer(), o.setProgram(t.gl, t.vertexBuffer, e), t.program = o, t.render(n, e, i, r) })), n.tensorData = null, o && (this.queryList.push({ name: n.name, query: o, count: 1 }), o = function(n, e, t) { if (2 === e && c.get("performance")) { var o = n.getExtension("EXT_disjoint_timer_query_webgl2"); if (!o) return;
                                                    n.endQuery(o.TIME_ELAPSED_EXT) } return t }(this.gl, this.glVersion, o)) }, e.prototype.read = function(n) { return K(this, void 0, void 0, (function() { var e, t, o, r; return Z(this, (function(i) { switch (i.label) {
                                                        case 0:
                                                            return c.get("webgl_gpu_pipeline") ? (e = this.gl, this.frameBuffer = e.createFramebuffer(), e.bindFramebuffer(e.FRAMEBUFFER, this.frameBuffer), [2, []]) : (t = this.createPBO(), [4, this.createAndWaitForFence()]);
                                                        case 1:
                                                            return i.sent(), o = this.downloadFloat32TensorFromBuffer(t), r = n ? n.shape : [], c.get("webgl_pack_output") ? [2, o.slice(0, g(r))] : [2, o] } })) })) }, e.prototype.createPBO = function() { var n, e = this.textureConf; if (2 === this.glVersion) { var t = this.gl,
                                                    o = this.pbo;
                                                t.bindBuffer(t.PIXEL_PACK_BUFFER, o); var r = 16 * this.width_texture_out * this.height_texture_out; return t.bufferData(t.PIXEL_PACK_BUFFER, r, t.STREAM_READ), t.readPixels(0, 0, this.width_texture_out, this.height_texture_out, t.RGBA, t.FLOAT, 0), t.bindBuffer(t.PIXEL_PACK_BUFFER, null), o } var i = this.gl,
                                                s = i.FLOAT; return e.isFloatTextureReadPixelsEnabled ? n = new Float32Array(this.width_texture_out * this.height_texture_out * 4) : (n = new Uint8Array(this.width_texture_out * this.height_texture_out * 4), s = i.UNSIGNED_BYTE), i.readPixels(0, 0, this.width_texture_out, this.height_texture_out, i.RGBA, s, n), e.isFloatTextureReadPixelsEnabled ? n : new Float32Array(n.buffer) }, e.prototype.createAndWaitForFence = function() { return K(this, void 0, void 0, (function() { var n, e, t, o, r = this; return Z(this, (function(i) { return n = this.gl, e = null != n.fenceSync, t = function() { return !0 }, e && (o = n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE, 0), n.flush(), t = function() { var e = n.clientWaitSync(o, 0, 0); return e === n.ALREADY_SIGNALED || e === n.CONDITION_SATISFIED }), [2, new Promise((function(n) { r.pollItem(t, n) }))] })) })) }, e.prototype.pollItem = function(n, e) { var t = function() { n() ? e() : setTimeout(t, 1) };
                                            t() }, e.prototype.downloadFloat32TensorFromBuffer = function(n) { var e = 4 * this.width_texture_out * this.height_texture_out; if (2 === this.glVersion) { var t = this.gl,
                                                    o = new Float32Array(e);
                                                t.bindBuffer(t.PIXEL_PACK_BUFFER, n), t.getBufferSubData(t.PIXEL_PACK_BUFFER, 0, o), t.bindBuffer(t.PIXEL_PACK_BUFFER, null); var r = []; if (c.get("webgl_pack_output")) return Array.from(o); for (var i = 0; i < this.width_texture_out * this.height_texture_out; i++) r.push(o[4 * i]); return r } var s = n,
                                                a = []; for (i = 0; i < this.width_texture_out * this.height_texture_out; i++) { var u = this.textureConf.isFloatTextureReadPixelsEnabled ? 4 * i : i;
                                                a.push(s[u]) } return a }, e.prototype.setOutProps = function(n) { var e = n.width_shape,
                                                t = void 0 === e ? 1 : e,
                                                o = n.height_shape,
                                                r = void 0 === o ? 1 : o,
                                                i = n.width_texture,
                                                s = void 0 === i ? 1 : i,
                                                a = n.height_texture,
                                                u = void 0 === a ? 1 : a,
                                                l = n.channel,
                                                c = void 0 === l ? 0 : l,
                                                f = n.total_shape,
                                                h = void 0 === f ? 0 : f;
                                            this.width_shape_out = t, this.height_shape_out = r, this.width_texture_out = s, this.height_texture_out = u, this.channel = c, this.total_shape = h }, e.prototype.attachColorBuffer = function() { var n = this.gl;
                                            n.bindFramebuffer(n.FRAMEBUFFER, null), n.canvas.width = this.width_shape_out, n.canvas.height = this.height_shape_out, n.viewport(0, 0, n.canvas.width, n.canvas.height), n.scissor(0, 0, n.canvas.width, n.canvas.height) }, e.prototype.attachFrameBuffer = function(n) { this.currentTexture = this.texturesMap[n]; var e = this.gl;
                                            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.currentTexture, 0), e.viewport(0, 0, this.width_texture_out, this.height_texture_out), e.scissor(0, 0, this.width_texture_out, this.height_texture_out) }, e.prototype.render = function(n, e, t, o) { var r = this;
                                            void 0 === e && (e = !1), void 0 === o && (o = !1); var i = n.inputTensors,
                                                s = void 0 === i ? [] : i,
                                                a = n.uniform,
                                                u = void 0 === a ? null : a,
                                                l = n.iLayer,
                                                c = void 0 === l ? 0 : l,
                                                f = n.modelName,
                                                h = this.gl,
                                                p = 0;
                                            s.forEach((function(n) { r.initTexture(p, n, o); var i = r.getUniformLoc("texture_" + n.name, c, e, t, f);
                                                i && h.uniform1i(i, p++) })), u && this.setUniform(u, c, e, t, f), h.drawArrays(h.TRIANGLE_STRIP, 0, 4) }, e.prototype.initTexture = function(n, e, t) { var o, r = this.gl,
                                                i = this.textureConf,
                                                s = e.tensorId,
                                                a = t || e.isPacked,
                                                u = e.data; if (e.persistable) { this.cacheTextures = this.cacheTextures || {}; var l = this.cacheTextures[s];
                                                l ? (o = l, u && b.genTextureInfoFromTensorShape(this.MAX_TEXTURE_SIZE, e)) : (o = r.createTexture(), this.cacheTextures[s] = o) } else o = this.texturesMap[s];
                                            r.activeTexture(r["TEXTURE" + n]), r.bindTexture(r.TEXTURE_2D, o), u && (T.uploadDataToTexture(r, i, e, a), e.data = null) }, e.prototype.setUniform = function(n, e, t, o, r) { var i = this,
                                                s = Object.keys(n),
                                                a = this.gl;
                                            s.forEach((function(s) { var u = n[s].type,
                                                    l = n[s].value,
                                                    c = i.getUniformLoc(s, e, t, o, r);
                                                b.setUniformParam(a, c, u, l) })) }, e.prototype.getUniformLoc = function(n, e, t, o, r) { var i = r + "_"; if (t) return this.uniformLocations[i + e][n + o]; var s = this.gl.getUniformLocation(this.program.program, n); return this.uniformLocations[i + e] = this.uniformLocations[i + e] || {}, this.uniformLocations[i + e][n + o] = s, s }, e.prototype.dispose = function() {}, e }((function() {})),
                                    Q = { mainFunc: function(n, e) { var t = n.origin,
                                                o = n.filter,
                                                r = n.out,
                                                i = n.bias,
                                                s = e.groups,
                                                a = void 0 === s ? 1 : s,
                                                u = e.strides,
                                                l = void 0 === u ? [] : u,
                                                c = e.paddings,
                                                f = void 0 === c ? [] : c,
                                                h = e.dilations,
                                                p = void 0 === h ? [] : h,
                                                d = e.fuse_relu,
                                                g = e.filter_nearest_vec4,
                                                _ = e.filter_remainder_vec4,
                                                m = e.act_type,
                                                v = l[0],
                                                P = void 0 === v ? 1 : v,
                                                x = l[1],
                                                b = void 0 === x ? 1 : x,
                                                T = f[0],
                                                y = void 0 === T ? 0 : T,
                                                F = f[1],
                                                w = void 0 === F ? 0 : F,
                                                E = p[0],
                                                A = void 0 === E ? 1 : E,
                                                O = p[1],
                                                V = void 0 === O ? 1 : O; return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = (c / (" + r.channel + " / " + a + ")) * " + o.channel + ";\n        int oy = y * " + P + " - " + y + ";\n        for (int fy = 0; fy < " + o.height_shape + "; fy++) {\n            if (oy >= " + t.height_shape + ") {\n                break;\n            }\n            if (oy < 0) {\n                oy += " + A + ";\n                continue;\n            }\n            int ox = x * " + b + " - " + w + ";\n            for (int fx = 0; fx < " + o.width_shape + "; fx++) {\n                if (ox >= " + t.width_shape + ") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += " + V + ";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < " + g + "; j += 4) {\n                    vec4 fValues = vec4(\n                        getValueFromTensorPos_filter(c, j, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 2, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 3, fy, fx)\n                    );\n\n                    vec4 oValues = vec4(\n                        getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 2, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 3, oy, ox)\n                      );\n\n                    res += dot(fValues, oValues);\n                }\n\n                if (" + _ + " == 1) {\n                    res += dot(\n                        getValueFromTensorPos_filter(c, " + g + ", fy, fx),\n                        getValueFromTensorPos_origin(b, oTensorChannel + " + g + ", oy, ox));\n                } else if (" + _ + " == 2) {\n                    vec2 fValues = vec2(\n                        getValueFromTensorPos_filter(c, " + g + ", fy, fx),\n                        getValueFromTensorPos_filter(c, " + g + " + 1, fy, fx)\n                    );\n                    vec2 oValues = vec2(\n                        getValueFromTensorPos_origin(b, oTensorChannel + " + g + ", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + " + g + " + 1, oy, ox)\n                      );\n                    res += dot(fValues, oValues);\n                } else if (" + _ + " == 3) {\n                    vec3 fValues = vec3(\n                        getValueFromTensorPos_filter(c, " + g + ", fy, fx),\n                        getValueFromTensorPos_filter(c, " + g + " + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, " + g + " + 2, fy, fx)\n                    );\n                    vec3 oValues = vec3(\n                        getValueFromTensorPos_origin(b, oTensorChannel + " + g + ", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + " + g + " + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + " + g + " + 2, oy, ox)\n                    );\n                    res += dot(fValues, oValues);\n                }\n\n                ox += " + V + ";\n            }\n            oy += " + A + ";\n        }\n\n        " + (i ? "res += getValueFromTensorPos_bias(0, 0, 0, c);" : "") + "\n\n        if (" + d + ") {\n            res = max(0.0, res);\n        }\n        else if (" + ("relu6" === m) + ") {\n            res = min(max(0.0, res), 6.0);\n        }\n\n        setOutput(res);\n    }\n    " }, textureFuncConf: { filter: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"], bias: ["getValueFromTensorPos"] }, behaviors: ["adaptPaddings", "isApplySeparableConv", "batchComputeConv2d", "processBias"] };

                                function $(n, e) { var t = n[0],
                                        o = n[1],
                                        r = n[2],
                                        i = n[3]; if (1 === t && 1 === o) return [
                                        [1, 1, r], 3, [i], 1, [r, i]
                                    ]; var s = n.slice(0, e),
                                        a = n.slice(e); return [s, s.length, a, a.length, [s.reduce((function(n, e) { return n * e })), a.reduce((function(n, e) { return n * e }))]] }

                                function nn(n, e, t) { if (1 === t) return "\n            int getTensorPosFromArrayIndex_" + n + "(int n) {\n                return calMod(n, " + e[0] + ");\n            }\n        "; var o = d(e); return o.push(1), "\n    ivec" + t + " shapeVec_" + n + " = ivec" + t + "(" + o.join(", ") + ");\n    ivec" + t + " getTensorPosFromArrayIndex_" + n + "(int n) {\n        ivec" + t + " pos;\n        pos[0] = n / shapeVec_" + n + "[0];\n        for (int i = 1; i < " + t + "; i++) {\n            n = calMod(n, shapeVec_" + n + "[i - 1]);\n            pos[i] = n / shapeVec_" + n + "[i];\n        }\n        return pos;\n    }\n    " }

                                function en(n) { return 1 === n ? "int" : "ivec" + n }

                                function tn(n) { var e = n.total_shape,
                                        t = n.channel,
                                        o = n.height_shape,
                                        r = n.width_shape; return [e / t / o / r, t, o, r] } const on = { mainFunc: function(n, e) { var t = n.origin,
                                            o = e.transpose_X,
                                            r = void 0 !== o && o,
                                            i = e.transpose_Y,
                                            s = void 0 !== i && i,
                                            a = e.trans_x,
                                            u = void 0 !== a && a,
                                            l = e.trans_y,
                                            c = r || u,
                                            f = s || void 0 !== l && l; return "\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        if (" + c + ") {\n            origin_pos[3] = origin_pos[2];\n        }\n        ivec4 counter_pos = out_pos;\n        if (" + f + ") {\n            counter_pos[2] = counter_pos[3];\n        }\n\n        for (int j = 0; j < " + (c ? t.height_shape : t.width_shape) + "; j++) {\n            if (" + c + ") {\n                origin_pos[2] = j;\n            }\n            else {\n                origin_pos[3] = j;\n            }\n            if (" + f + ") {\n                counter_pos[3] = j;\n            }\n            else {\n                counter_pos[2] = j;\n            }\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], origin_pos[2], origin_pos[3]);\n            float c = getValueFromTensorPos_counter(counter_pos[0], counter_pos[1], counter_pos[2], counter_pos[3]);\n            \n            res += c * o;\n        }\n        setOutput(res);\n    }\n    " }, textureFuncConf: { counter: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"] } };

                                function rn(n, e) { var t = n[0],
                                        o = n[1],
                                        r = n[2],
                                        i = n[3]; if (1 === t && 1 === o) return [
                                        [1, 1, r], 3, [i], 1, [r, i]
                                    ]; var s = n.slice(0, e),
                                        a = n.slice(e); return [s, s.length, a, a.length, [s.reduce((function(n, e) { return n * e })), a.reduce((function(n, e) { return n * e }))]] }

                                function sn(n, e, t) { if (1 === t) return "\n            int getTensorPosFromArrayIndex_" + n + "(int n) {\n                return calMod(n, " + e[0] + ");\n            }\n        "; var o = d(e); return o.push(1), "\n    ivec" + t + " shapeVec_" + n + " = ivec" + t + "(" + o.join(", ") + ");\n    ivec" + t + " getTensorPosFromArrayIndex_" + n + "(int n) {\n        ivec" + t + " pos;\n        pos[0] = n / shapeVec_" + n + "[0];\n        for (int i = 1; i < " + t + "; i++) {\n            n = calMod(n, shapeVec_" + n + "[i - 1]);\n            pos[i] = n / shapeVec_" + n + "[i];\n        }\n        return pos;\n    }\n    " }

                                function an(n) { return 1 === n ? "int" : "ivec" + n }

                                function un(n) { var e = n.total_shape,
                                        t = n.channel,
                                        o = n.height_shape,
                                        r = n.width_shape; return [e / t / o / r, t, o, r] } const ln = { mainFunc: function(n, e) { return "\n    // start函数\n    void main(void) {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int(" + n.out.width_texture + ");\n        ivec4 originPos = getTensorPosFromArrayIndex_origin(index);\n        float res = getValueFromTensorPos_origin(originPos[0], originPos[1], originPos[2], originPos[3]);\n        setOutput(res);\n    }\n    " }, textureFuncConf: { origin: ["getTensorPosFromArrayIndex", "getValueFromTensorPos"] } },
                                    cn = { mainFunc: function(n, e) { var t = n.out,
                                                o = n.origin,
                                                r = e.align_mode,
                                                i = void 0 === r ? 1 : r,
                                                s = e.align_corners,
                                                a = void 0 === s || s; return "\n    // start函数\n\n    vec4 getData(float n, float scale, bool align_flag, int in_len) {\n        float m = align_flag ? ((n + 0.5) / scale - 0.5) : (n / scale);\n        int a1 = int(floor(m));\n        a1 = a1 > 0 ? a1 : 0;\n        int a2 = (a1 + 1) < (in_len - 1) ? (a1 + 1) : (in_len - 1);\n\n        float idx_src = (n + 0.5) / scale - 0.5;\n        idx_src = idx_src > 0.0 ? idx_src : 0.0;\n        float b1 = align_flag ? (idx_src - float(a1)) : (n / scale - float(a1));\n        float b2 = 1.0 - b1;\n        return vec4(float(a1), float(a2), b1, b2);\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        bool align_flag = " + i + " == 0 && !" + a + ";\n\n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if (" + a + ") {\n            scale_x = float(" + t.width_shape + " - 1) / float(" + o.width_shape + " - 1);\n            scale_y = float(" + t.height_shape + " - 1) / float(" + o.height_shape + " - 1);\n        }\n        else {\n            scale_x = float(" + t.width_shape + ") / float(" + o.width_shape + ");\n            scale_y = float(" + t.height_shape + ") / float(" + o.height_shape + ");\n        }\n\n        vec4 vx = getData(float(oPos.a), scale_x, align_flag, " + o.width_shape + ");\n        vec4 vy = getData(float(oPos.b), scale_y, align_flag, " + o.height_shape + ");\n\n        int x1 = int(vx.r);\n        int x2 = int(vx.g);\n        float x3 = vx.b;\n        float x4 = vx.a;\n        int y1 = int(vy.r);\n        int y2 = int(vy.g);\n        float y3 = vy.b;\n        float y4 = vy.a;\n\n        float value11 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x1);\n        float value12 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x1);\n        float value21 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x2);\n        float value22 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x2);\n        float value = x4 * y4 * value11 + x4 * y3 * value12 + x3 * y4 * value21 + x3 * y3 * value22;\n        setOutput(float(value));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] } },
                                    fn = cn; var hn = { relu: ["transToPrelu"], relu6: ["transToRelu6"], leaky_relu: ["transToLeakyrelu"], transToLeakyrelu: ["transToLeakyrelu"], scale: ["transToScale"], sigmoid: ["transToSigmoid"], hard_sigmoid: ["transToHardSigmoid"], pow: ["transToPow"], sqrt: ["transToSqrt"], tanh: ["transToTanh"] };

                                function pn(n, e) { var t = e.multi_value,
                                        o = void 0 === t ? 1 : t,
                                        r = e.bias_value,
                                        i = void 0 === r ? 0 : r; return "\n    // start函数\n    void main(void) {\n        // 输出数据\n        float o = getPixelsFromTexturePos_origin(vCoord).r;\n        float res = " + e.active_function + "(o, float(" + o + "), float(" + i + "));\n        setOutput(res);\n    }\n    " }

                                function dn(n) { return { mainFunc: pn, textureFuncConf: { origin: ["getPixelsFromTexturePos"] }, behaviors: hn[n] } } const gn = { mainFunc: function(n, e) { var t = e.axes,
                                                o = Array.isArray(t) ? t : [t],
                                                r = [0, 1, 2, 3].filter((function(n) { return n >= o.length })); return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin(" + [0, 1, 2, 3].map((function(n) { return o.indexOf(n) > -1 ? 0 : "oPos[" + r.splice(0, 1) + "]" })).join(",") + ");\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] } },
                                    _n = { mainFunc: function(n, e) { var t = n.origin,
                                                o = n.out,
                                                r = e.align_corners; return "\n    // start函数\n    int getData(float n, float scale, bool align_corners) {\n        float m = align_corners ? (n / scale + 0.5) : (n / scale);\n        return int(floor(m));\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        \n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if (" + r + ") {\n            scale_x = float(" + o.width_shape + " -1) / float(" + t.width_shape + " - 1);\n            scale_y = float(" + o.height_shape + " - 1) / float(" + t.height_shape + " - 1);\n        }\n        else {\n            scale_x = float(" + o.width_shape + ") / float(" + t.width_shape + ");\n            scale_y = float(" + o.height_shape + ") / float(" + t.height_shape + ");\n        }\n    \n        int vx = getData(float(oPos.a), scale_x, " + r + ");\n        int vy = getData(float(oPos.b), scale_y, " + r + ");\n        \n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, vy, vx);\n        setOutput(float(o));\n}\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, commonFuncConf: ["transferFromNHWCtoNCHW"] }; var mn = function() { for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length; var o = Array(n),
                                        r = 0; for (e = 0; e < t; e++)
                                        for (var i = arguments[e], s = 0, a = i.length; s < a; s++, r++) o[r] = i[s]; return o }; const vn = { mainFunc: function(n, e) { var t = n.origin,
                                                o = n.image,
                                                r = n.out,
                                                i = e.variances,
                                                s = void 0 === i ? [.1, .1, .2, .2] : i,
                                                a = e.fixed_sizes,
                                                u = e.fixed_ratios,
                                                l = e.densities,
                                                c = e.flatten_to_2d,
                                                f = e.clip,
                                                h = e.step_w,
                                                p = void 0 === h ? 0 : h,
                                                g = e.step_h,
                                                _ = void 0 === g ? 0 : g,
                                                v = e.offset,
                                                P = void 0 === v ? .5 : v,
                                                x = e.runtime,
                                                b = void 0 === x ? 0 : x,
                                                T = o.height_shape,
                                                y = o.width_shape,
                                                F = t.height_shape,
                                                w = t.width_shape,
                                                E = r.total_shape,
                                                A = r.channel,
                                                O = r.height_shape,
                                                V = r.width_shape,
                                                C = E / A / O / V,
                                                S = d([C, A, O, V]),
                                                k = p,
                                                R = _;
                                            0 !== p && 0 !== _ || (k = y / w, R = T / F); var I = Math.round(.5 * (k + R)),
                                                M = u.map((function(n) { return Math.sqrt(n) })),
                                                L = 1 === M.length ? "sqrt_fixed_ratios" : "sqrt_fixed_ratios[r]",
                                                j = u.length,
                                                D = O,
                                                N = C,
                                                B = A;
                                            c && (N = F, B = w, D = O / F / w); var G = d([N, B, D, V]),
                                                W = U("out1", { numbers_shape: mn(G, [1]), length_shape: 4 }),
                                                H = l.map((function(n) { return n * n * j })),
                                                X = H.length,
                                                z = function(n) { var e = "ivec2 calRemain(int remain, int curAccIndex, int s) {",
                                                        t = n.length; if (1 === t) e += "\n            int accIndex0 = density_acc_shape;\n\n            if (remain >= accIndex0) {\n                s++;\n                remain -= accIndex0;\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";
                                                    else
                                                        for (var o = 0; o < t; o++) e += "\n            int accIndex" + o + " = density_acc_shape[" + o + "];\n\n            if (remain >= accIndex" + o + ") {\n                s++;\n                remain -= accIndex" + o + ";\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            "; return e + "\n    }\n    " }(H),
                                                q = f ? "v = min(max(v, 0.), 1.);" : "",
                                                Y = 1 === X ? "density_acc_shape" : "density_acc_shape[0]",
                                                K = "\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    float getFloat3TensorVal(vec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    float getFloat2TensorVal(vec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n    float getFloat1TensorVal(float tensor, int index) {\n        return tensor;\n    }\n    int getInt4TensorVal(ivec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    int getInt3TensorVal(ivec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    int getInt2TensorVal(ivec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n\n    int getInt1TensorVal(int tensor, int index) {\n       return tensor;\n    }\n\n    " + W + "\n    \n        " + m(l, "densities") + "\n        " + m(a, "fixed_sizes") + "\n        " + m(M, "sqrt_fixed_ratios") + "\n        " + function(n, e) { if (1 === n.length) return "int " + e + " = int(" + n[0] + ");"; for (var t = n.length, o = "\n        ivec" + t + " " + e + " = ivec" + t + "(\n    ", r = 0; r < t; r++) o += n[r] + ","; return o.slice(0, -1) + ");" }(H, "density_acc_shape") + "\n    \n    " + z + "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int rr = int(oPos.r);\n        int gg = int(oPos.g);\n        int bb = int(oPos.b);\n        int aa = int(oPos.a);\n\n        // 输出坐标转换为输入坐标\n        int index = rr * " + S[0] + " + gg * " + S[1] + " + bb * " + S[2] + " + aa;\n        ivec4 realOutPos = getTensorPosFromArrayIndex_out1(index);\n        int h = realOutPos.r;\n        int w = realOutPos.g;\n        int b = realOutPos.b;\n        int a = realOutPos.a;\n    "; return 1 === b ? "\n        " + m(s, "variances") + "\n        " + K + "\n        setOutput(getFloat4TensorVal(variances, aa));\n        }" : "\n            " + K + "\n            // 求idx 对应的 s, r, di, dj\n            int s = 0;\n            int remain = b;\n            int curAccIndex = " + Y + ";\n\n            ivec2 remainInfo = calRemain(remain, curAccIndex, s);\n            remain = remainInfo[0];\n            s = remainInfo[1];\n            int density = int(getFloat" + l.length + "TensorVal(densities, s));\n            int r = int(floor(float(remain / density / density)));\n            remain -= r * density * density;\n\n            float di = floor(float(remain / density));\n            float dj = float(remain - int(di) * density);\n\n            float center_x = (float(w) + float(" + P + ")) * float(" + k + ");\n            float center_y = (float(h) + float(" + P + ")) * float(" + R + ");\n            float fixed_size = getFloat" + a.length + "TensorVal(fixed_sizes, s);\n            float shift = float(" + I + ") / float(density);\n\n            float v = 0.0;\n            if (a == 0 || a == 2) {\n                float box_width_ratio = fixed_size * " + L + ";\n                float density_center_x = center_x - float(" + I + ") / 2. + shift / 2.;\n                float center_x_temp = density_center_x + dj * shift;\n                if (a == 0) {\n                    v = max((center_x_temp - box_width_ratio / 2.) / float(" + y + "), 0.);\n                }\n                else {\n                    v = min((center_x_temp + box_width_ratio / 2.) / float(" + y + "), 1.);\n                }\n            }\n            else {\n                float box_height_ratio = fixed_size / " + L + ";\n                float density_center_y = center_y - float(" + I + ") / 2. + shift / 2.;\n                float center_y_temp = density_center_y + di * shift;\n                if (a == 1) {\n                    v = max((center_y_temp - box_height_ratio / 2.) / float(" + T + "), 0.);\n                }\n                else {\n                    v = min((center_y_temp + box_height_ratio / 2.) / float(" + T + "), 1.);\n                }\n            }\n\n            " + q + "\n\n            setOutput(v);\n        }\n        " }, textureFuncConf: { image: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"] } },
                                    Pn = { mainFunc: function(n, e) { var t = n.origin,
                                                o = n.image,
                                                r = n.out,
                                                i = e.variances,
                                                s = void 0 === i ? [.1, .1, .2, .2] : i,
                                                a = e.flip,
                                                u = e.clip,
                                                l = e.step_w,
                                                c = void 0 === l ? 0 : l,
                                                f = e.step_h,
                                                h = void 0 === f ? 0 : f,
                                                p = e.offset,
                                                d = void 0 === p ? .5 : p,
                                                g = e.runtime,
                                                v = void 0 === g ? 0 : g,
                                                P = e.min_sizes,
                                                x = void 0 === P ? [] : P,
                                                b = e.max_sizes,
                                                T = void 0 === b ? [] : b,
                                                y = e.aspect_ratios,
                                                F = void 0 === y ? [] : y,
                                                w = e.min_max_aspect_ratios_order,
                                                E = void 0 !== w && w,
                                                A = o.height_shape,
                                                O = o.width_shape,
                                                V = t.height_shape,
                                                C = t.width_shape,
                                                S = r.channel,
                                                k = r.height_shape,
                                                R = c,
                                                I = h;
                                            0 !== c && 0 !== h || (R = O / C, I = A / V); var M = [1];
                                            F.forEach((function(n) { 1 !== n && (M.push(Math.sqrt(n)), a && M.push(Math.sqrt(1 / n))) })); var L = M.length,
                                                j = u ? "res = min(max(res, 0.), 1.);" : "",
                                                D = "\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int nn = int(oPos.r);\n        int cc = int(oPos.g);\n        int hh = int(oPos.b);\n        int ww = int(oPos.a);\n\n\n        \n        " + _(x, "min_sizes") + "\n        " + _(T, "max_sizes") + "\n        " + _(M, "aspect_ratios") + "\n    \n\n    "; return 1 === v ? "\n            " + m(s, "variances") + "\n            " + D + "\n            float res = 0.0;\n            res = getFloat4TensorVal(variances, ww);\n            setOutput(float(res));\n        }" : "\n            " + D + "\n            int idx = nn * " + S * k + " + cc * " + k + " + hh;\n            int as_num = " + L + ";\n            float offset = " + d + ";\n            \n            int feature_width = " + C + ";\n            int num_priors = " + k + ";\n            float step_width = float(" + R + ");\n            float step_height = float(" + I + ");\n\n            float im_width = float(" + O + ");\n            float im_height = float(" + A + ");\n\n            bool min_max_aspect_ratios_order = " + E + ";\n\n            // 求idx 对应的 h w p m\n            int h = int(idx / (num_priors * feature_width));\n            int w = (idx / num_priors) % feature_width;\n            int p = idx % num_priors;\n            int m = " + (T.length > 0) + " ? int(p / (as_num + 1)) : int(p / as_num);\n            float cx = (float(w) + offset) * step_width;\n            float cy = (float(h) + offset) * step_height;\n            float min_size = float(min_sizes[m]);\n            float bw = 0.0;\n            float bh = 0.0;\n\n            " + (T.length > 0 ? "\n            int s = p % (as_num + 1);\n            if (" + !E + ") {\n                if (s < as_num) {\n                    float ar = aspect_ratios[s];\n                    bw = min_size * ar / 2.0;\n                    bh = min_size / ar / 2.0;\n                }\n                else {\n                    float max_size = float(max_sizes[m]);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n            }\n            else {\n                if (s == 0) {\n                    bh = min_size / 2.0;\n                    bw = bh;\n                }\n                else if (s == 1) {\n                    float max_size = float(max_sizes[m]);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n                else {\n                    float ar = aspect_ratios[s - 1];\n                    bw = min_size * sqrt(ar) / 2.0;\n                    bh = min_size / sqrt(ar) / 2.0;\n                }\n            }" : "\n            int s = p % as_num;\n            float ar = aspect_ratios[s];\n            bw = min_size * ar / 2.0;\n            bh = min_size / ar / 2.0;\n        ") + "\n            float res = 0.0;\n            if (ww == 0) {\n                res = (cx - bw) / im_width;\n            }\n            else if (ww == 1) {\n                res = (cy - bh) / im_height;\n            }\n            else if (ww == 2) {\n                res = (cx + bw) / im_width;\n            }\n            else {\n                res = (cy + bh) / im_height;\n            }\n\n            " + j + "\n\n            setOutput(float(res));\n        }\n        " }, textureFuncConf: { image: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"] }, behaviors: [] }; var xn = { arg_max: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = e.axis,
                                                    r = void 0 === o ? -1 : o,
                                                    i = e.flatten,
                                                    s = t.total_shape,
                                                    a = t.height_shape,
                                                    u = t.width_shape,
                                                    l = t.channel,
                                                    c = t.length_unformatted_shape,
                                                    f = s / (u * a * l),
                                                    h = r < 0 ? 3 : 4 - c + r,
                                                    p = [f, l, a, u][h]; return "\n\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if (" + !i + ") {\n            if (" + h + " == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < " + p + "; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if (" + h + " == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < " + p + "; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if (" + h + " == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < " + p + "; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < " + p + "; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < " + f + "; n++) {\n                for (int c = 0; c < " + l + "; c++) {\n                    for (int h = 0; h < " + a + "; h++) {\n                        for (int w = 0; w < " + u + "; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o > tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }" }, textureFuncConf: { origin: ["getValueFromTensorPos"] } }, arg_min: { mainFunc: function(n, e) { for (var t = n.origin, o = e.axis, r = void 0 === o ? -1 : o, i = e.flatten, s = t.total_shape, a = t.height_shape, u = t.width_shape, l = t.channel, c = s / (u * a * l), f = [c, l, a, u], h = 0, p = 0; p < 4 && !(f[p] > 1); p++) h++; var d = r < 0 ? 4 - h + r : r,
                                                    g = f[d = h + d]; return "\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if (" + !i + ") {\n            if (" + d + " == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < " + g + "; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if (" + d + " == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < " + g + "; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if (" + d + " == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < " + g + "; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }     \n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < " + g + "; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < " + c + "; n++) {\n                for (int c = 0; c < " + l + "; c++) {\n                    for (int h = 0; h < " + a + "; h++) {\n                        for (int w = 0; w < " + u + "; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o < tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }" }, textureFuncConf: { origin: ["getValueFromTensorPos"] } }, conv2d: Q, conv2d_packing: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = n.filter,
                                                    r = n.out,
                                                    i = n.bias,
                                                    s = e.groups,
                                                    a = void 0 === s ? 1 : s,
                                                    u = e.strides,
                                                    l = void 0 === u ? [] : u,
                                                    c = e.paddings,
                                                    f = void 0 === c ? [] : c,
                                                    h = e.dilations,
                                                    p = void 0 === h ? [] : h,
                                                    d = e.fuse_relu,
                                                    g = e.act_type,
                                                    _ = l[0],
                                                    m = void 0 === _ ? 1 : _,
                                                    v = l[1],
                                                    P = void 0 === v ? 1 : v,
                                                    x = f[0],
                                                    b = void 0 === x ? 0 : x,
                                                    T = f[1],
                                                    y = void 0 === T ? 0 : T,
                                                    F = p[0],
                                                    w = void 0 === F ? 1 : F,
                                                    E = p[1],
                                                    A = void 0 === E ? 1 : E; return "\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n\n        int oy = y * " + m + " - " + b + ";\n        for (int fy = 0; fy < " + o.height_shape + "; fy++) {\n            if (oy >= " + t.height_shape + ") {\n                break;\n            }\n            if (oy < 0) {\n                oy += " + w + ";\n                continue;\n            }\n            int ox = x * " + P + " - " + y + ";\n            for (int fx = 0; fx < " + o.width_shape + "; fx++) {\n                if (ox >= " + t.width_shape + ") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += " + A + ";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < " + o.channel + "; j += 1) {\n                    int c0 = (c / (" + r.channel + " * 4 / " + a + ")) * " + o.channel + " + j;\n                    vec4 fValue = getValueFromTensorPosPacking_filter(c * 4, j, fy, fx);\n                    vec4 oValue = getValueFromTensorPosPacking_origin(b, c0, oy, ox);\n\n                    for (int packed_index = 0; packed_index < 4; packed_index++) {\n                        if (packed_index == 0) {\n                            res.r += dot(fValue, oValue);\n                        } else if (packed_index == 1) {\n                            int c1 = ((c + 1) / (" + r.channel + " * 4 / " + a + ")) * " + o.channel + " + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c1, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 1, j, fy, fx);\n                            res.g += dot(fValue, oValue);\n                        } else if (packed_index == 2) {\n                            int c2 = ((c + 2) / (" + r.channel + " * 4 / " + a + ")) * " + o.channel + " + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c2, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 2, j, fy, fx);\n                            res.b += dot(fValue, oValue);\n                        } else if (packed_index == 3) {\n                            int c3 = ((c + 3) / (" + r.channel + " * 4 / " + a + ")) * " + o.channel + " + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c3, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 3, j, fy, fx);\n                            res.a += dot(fValue, oValue);\n                        }\n                    }\n                }\n                ox += " + A + ";\n            }\n            oy += " + w + ";\n        }\n\n        " + (i ? "res += getValueFromTensorPosPacking_bias(0, c, 0, 0);" : "") + "\n\n        if (" + d + ") {\n            res = max(vec4(0.0, 0.0, 0.0, 0.0), res);\n        }\n        else if (" + ("relu6" === g) + ") {\n            res = min(max(vec4(0.0, 0.0, 0.0, 0.0), res), vec4(6.0, 6.0, 6.0, 6.0));\n        }\n        setPackedOutput(res);\n    }\n    " }, textureFuncConf: { filter: ["getValueFromTensorPosPacking"], origin: ["getValueFromTensorPosPacking"], bias: ["getValueFromTensorPosPacking"] }, behaviors: ["adaptPaddings", "isApplySeparableConv", "batchComputeConv2d", "processBias"] }, conv2d_transpose: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = n.filter,
                                                    r = n.out,
                                                    i = e.groups,
                                                    s = void 0 === i ? 1 : i,
                                                    a = e.strides,
                                                    u = void 0 === a ? [] : a,
                                                    l = e.paddings,
                                                    c = void 0 === l ? [] : l,
                                                    f = e.dilations,
                                                    h = void 0 === f ? [] : f,
                                                    p = u[0],
                                                    d = void 0 === p ? 1 : p,
                                                    g = u[1],
                                                    _ = void 0 === g ? 1 : g,
                                                    m = c[0],
                                                    v = void 0 === m ? 0 : m,
                                                    P = c[1],
                                                    x = void 0 === P ? 0 : P;
                                                x = o.height_shape - x - 1, v = o.width_shape - v - 1; var b = h[0],
                                                    T = void 0 === b ? 1 : b,
                                                    y = h[1],
                                                    F = void 0 === y ? 1 : y; return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n        int temp_x = 0;\n        int temp_y = 0;\n        float o = 0.0;\n        float f = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = int(c * " + s + " / " + r.channel + ") * " + t.channel + ";\n        int oy = y - " + x + ";\n        const int groupLen = int(" + t.channel + " / " + s + ");\n        int groupIndex = int(c / groupLen);\n\n        for (int fy = 0; fy < " + o.height_shape + "; fy++) {\n            if (oy < 0) {\n                oy += " + T + ";\n                continue;\n            }\n            int ox = x - " + v + ";\n            for (int fx = 0; fx < " + o.width_shape + "; fx++) {\n\n                if (ox < 0) {\n                    ox += " + F + ";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < groupLen; j++) {\n                    int curIndex = j + b * groupLen;\n                    if (calMod(ox, int(" + _ + ")) == 0 && calMod(oy, int(" + d + ")) == 0) {\n                        temp_x = int(floor(float(ox) / float(" + _ + ")));\n                        temp_y = int(floor(float(oy) / float(" + d + ")));\n                        if (temp_x < " + t.width_shape + " && temp_y < " + t.height_shape + ") {\n                            o = getValueFromTensorPos_origin(b, curIndex , temp_y, temp_x);\n                            f = getValueFromTensorPos_filter(\n                                curIndex,\n                                int(c / " + s + "),\n                                " + o.height_shape + "-1-fy,\n                                " + o.width_shape + "-1-fx\n                            );\n                            res += f * o;\n                        }\n                    }\n                }\n                ox += " + F + ";\n            }\n            oy += " + T + ";\n        }\n        setOutput(float(res));\n    }\n" }, textureFuncConf: { filter: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"] }, behaviors: ["adaptPaddings", "isApplySeparableConv", "batchComputeConv2d", "processBias"] }, depthwise_conv2d: Q, conv2d_depthwise: Q, conv2d_elementwise_add: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = n.filter,
                                                    r = n.out,
                                                    i = n.counter,
                                                    s = e.active_function,
                                                    a = e.groups,
                                                    u = void 0 === a ? 1 : a,
                                                    l = e.axis,
                                                    c = e.strides,
                                                    f = void 0 === c ? [] : c,
                                                    h = e.paddings,
                                                    p = void 0 === h ? [] : h,
                                                    d = e.dilations,
                                                    g = void 0 === d ? [] : d,
                                                    _ = e.multi_value,
                                                    m = e.bias_value,
                                                    v = f[0],
                                                    P = void 0 === v ? 1 : v,
                                                    x = f[1],
                                                    b = void 0 === x ? 1 : x,
                                                    T = p[0],
                                                    y = void 0 === T ? 0 : T,
                                                    F = p[1],
                                                    w = void 0 === F ? 0 : F,
                                                    E = g[0],
                                                    A = void 0 === E ? 1 : E,
                                                    O = g[1],
                                                    V = void 0 === O ? 1 : O; return "\n    // start函数\n\n    float getValueFromCounter(int index) {\n        float xPos = float(index) / float(" + i.width_shape + ");\n        vec4 pixels = TEXTURE2D(texture_counter, vec2(xPos, 0.5));\n        return pixels.r;\n    }\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        int addAxis = oPos[" + l + "];\n        float res = getValueFromCounter(addAxis);\n\n        // 获取output的坐标\n        int oTensorChannel = (c / (" + r.channel + " / " + u + ")) * " + o.channel + ";\n        int oy = y * " + P + " - " + y + ";\n        for (int fy = 0; fy < " + o.height_shape + "; fy++) {\n            if (oy >= " + t.height_shape + ") {\n                break;\n            }\n            if (oy < 0) {\n                oy += " + A + ";\n                continue;\n            }\n            int ox = x * " + b + " - " + w + ";\n            for (int fx = 0; fx < " + o.width_shape + "; fx++) {\n                if (ox >= " + t.width_shape + ") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += " + V + ";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < " + o.channel + "; j++) {\n                    float f = getValueFromTensorPos_filter(c, j, fy, fx);\n                    float o = getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox);\n                    res += f * o;\n                }\n                ox += " + V + ";\n            }\n            oy += " + A + ";\n        }\n        setOutput(" + s + "(res,  " + _ + ",  " + m + "));\n    }\n" }, textureFuncConf: { filter: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"], counter: ["getValueFromTensorPos"] }, behaviors: ["mergeAttrs", "checkIsMerge", "setActiveFunc"] }, pool2d: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = e.strides,
                                                    r = void 0 === o ? [] : o,
                                                    i = e.paddings,
                                                    s = void 0 === i ? [] : i,
                                                    a = e.pooling_type,
                                                    u = e.ksize,
                                                    l = r[0],
                                                    c = void 0 === l ? 1 : l,
                                                    f = r[1],
                                                    h = void 0 === f ? 1 : f,
                                                    p = s[0],
                                                    d = void 0 === p ? 0 : p,
                                                    g = s[1],
                                                    _ = void 0 === g ? 0 : g,
                                                    m = u[0],
                                                    v = u[1]; return "\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        if (" + a + " == 1) {\n            res = -1.70141184e38;\n        }\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * " + c + " - " + d + ";\n        int ox_base = out_pos[3] * " + h + " - " + _ + ";\n        for (int fy = 0; fy < " + m + "; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= " + t.height_shape + ") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < " + v + "; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= " + t.width_shape + ") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                if (" + a + " == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if (" + a + " != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, behaviors: ["isMax", "setPacked", "setAdaptive", "isGlobalPooling"] }, pool2d_max: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = e.strides,
                                                    r = void 0 === o ? [] : o,
                                                    i = e.paddings,
                                                    s = void 0 === i ? [] : i,
                                                    a = e.ksize,
                                                    u = e.global_pooling,
                                                    l = e.runtime,
                                                    c = r[0],
                                                    f = void 0 === c ? 1 : c,
                                                    h = r[1],
                                                    p = void 0 === h ? 1 : h,
                                                    d = s[0],
                                                    g = void 0 === d ? 0 : d,
                                                    _ = s[1],
                                                    m = void 0 === _ ? 0 : _,
                                                    v = a[0],
                                                    P = a[1],
                                                    x = function(n) { var e = n.total_shape,
                                                            t = n.channel,
                                                            o = n.height_shape,
                                                            r = n.width_shape; return [e / t / o / r, t, o, r] }(t),
                                                    b = "",
                                                    T = "setOutput(float(res));"; return 0 === l && !0 === u && (b = "\n            if (curr > res) {\n                index = " + x[2] * x[3] + " * out_pos[1] + " + x[3] + " * oy + ox;\n            }\n        ", T = "setOutput(float(index));"), "\n    // start函数\n    void main(void) {\n        float res = -1.70141184e38;\n        int index = 0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        int b = out_pos[0];\n        int c = out_pos[1];\n        int y = out_pos[2];\n        int x = out_pos[3];\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * " + f + " - " + g + ";\n        int ox_base = out_pos[3] * " + p + " - " + m + ";\n        for (int fy = 0; fy < " + v + "; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= " + t.height_shape + ") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < " + P + "; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= " + t.width_shape + ") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                " + b + "\n                res = max(res, curr);\n            }\n        }\n        " + T + "\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, behaviors: ["isMax", "setPacked", "setAdaptive", "isGlobalPooling"] }, pool2d_winograd: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = n.pool,
                                                    r = e.strides,
                                                    i = void 0 === r ? [] : r,
                                                    s = e.paddings,
                                                    a = void 0 === s ? [] : s,
                                                    u = e.type_pool,
                                                    l = i[0],
                                                    c = void 0 === l ? 1 : l,
                                                    f = i[1],
                                                    h = void 0 === f ? 1 : f,
                                                    p = a[0],
                                                    d = void 0 === p ? 0 : p,
                                                    g = a[1],
                                                    _ = void 0 === g ? 0 : g,
                                                    m = t.height_shape,
                                                    v = t.width_texture,
                                                    P = t.height_texture; return "\n\n    float getValueFromTensorPosPacked_origin(int r, int g, int b, int a) {\n        int y = b / 2;\n        int yOffset = calMod(b, 2);\n        int x = a / 2;\n        int xOffset = calMod(a, 2);\n        int height = " + m + " + " + t.offset_y + ";\n        vec4 pixels = TEXTURE2D(\n            texture_origin,\n            vec2((float(x) + 0.5) / float(" + v + "),\n            (float(g * height / 2 + y) + 0.5) / float(" + P + "))\n        );\n        int index = 0;\n        if (xOffset == 0 && yOffset == 0) {\n            return pixels[0];\n        }\n        else if (xOffset == 1 && yOffset == 0) {\n            return pixels[1];\n        }\n        else if (xOffset == 0 && yOffset == 1) {\n            return pixels[2];\n        }\n        return pixels[3];\n    }\n\n    // start函数\n    void main(void) {\n        float res = (-1.0 / exp(-20.0));\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // int b = out_pos[0];\n        // int c = out_pos[1];\n        // int y = out_pos[2];\n        // int x = out_pos[3];\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * " + c + " - " + d + ";\n        int ox_base = out_pos[3] * " + h + " - " + _ + ";\n\n        for (int fy = 0; fy < " + o.height_shape + "; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= " + t.height_shape + ") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < " + o.width_shape + "; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= " + t.width_shape + ") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPosPacked_origin(out_pos[0], out_pos[1], oy, ox);\n                if (" + u + " == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if (" + u + " != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    " }, behaviors: ["isMax", "setPacked", "setAdaptive", "isGlobalPooling"] }, elementwise_add: { mainFunc: function(n, e) { var t = e.counterPos,
                                                    o = e.Scale_y,
                                                    r = void 0 === o ? 1 : o,
                                                    i = e.Scale_x,
                                                    s = void 0 === i ? 1 : i,
                                                    a = e.Scale_out,
                                                    u = void 0 === a ? 1 : a; return "\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter(" + t + ");\n        float res = float(" + u / r + ") * c + float(" + u / s + ") * o;\n        setOutput(float(res));\n    }\n    " }, textureFuncConf: { counter: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"] }, behaviors: ["processElementwiseAxis", "genElementwiseCounterPos"] }, elementwise_mul: { mainFunc: function(n, e) { var t = n.counter,
                                                    o = e.counterPos,
                                                    r = e.Scale_y,
                                                    i = void 0 === r ? 1 : r,
                                                    s = e.Scale_x,
                                                    a = void 0 === s ? 1 : s,
                                                    u = e.Scale_out,
                                                    l = void 0 === u ? 1 : u; return "\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= " + t.height_texture / t.height_shape + ") {\n            newN = int(" + t.height_texture / t.height_shape + ");\n        }\n        if (c >= " + t.channel + ") {\n            newC = int(" + (t.channel - 1) + ");\n        }\n        if (h >= " + t.height_shape + ") {\n            newH = " + (t.height_shape - 1) + ";\n        }\n        if (w >= " + t.width_shape + ") {\n            newW = " + (t.width_shape - 1) + ";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter(" + o + ");\n        float res = float(" + l / a + ") * o * float(" + 1 / i + ") * c;\n        setOutput(float(res));\n    }\n\n    " }, textureFuncConf: { counter: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"] }, behaviors: ["processElementwiseAxis", "genElementwiseCounterPos"] }, elementwise_div: { mainFunc: function(n, e) { var t = n.counter,
                                                    o = e.counterPos,
                                                    r = e.Scale_y,
                                                    i = void 0 === r ? 1 : r,
                                                    s = e.Scale_x,
                                                    a = void 0 === s ? 1 : s,
                                                    u = e.Scale_out,
                                                    l = void 0 === u ? 1 : u; return "\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= " + t.height_texture / t.height_shape + ") {\n            newN = int(" + t.height_texture / t.height_shape + ");\n        }\n        if (c >= " + t.channel + ") {\n            newC = int(" + (t.channel - 1) + ");\n        }\n        if (h >= " + t.height_shape + ") {\n            newH = " + (t.height_shape - 1) + ";\n        }\n        if (w >= " + t.width_shape + ") {\n            newW = " + (t.width_shape - 1) + ";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter(" + o + ");\n        float res = float(" + l + ") * (float(" + 1 / a + ") * o / (float(" + 1 / i + ") * c));\n        setOutput(float(res));\n    }\n\n    " }, textureFuncConf: { counter: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"] }, behaviors: ["processElementwiseAxis", "genElementwiseCounterPos"] }, elementwise_pow: { mainFunc: function(n, e) { var t = e.counterPos,
                                                    o = e.Scale_y,
                                                    r = void 0 === o ? 1 : o,
                                                    i = e.Scale_x,
                                                    s = void 0 === i ? 1 : i,
                                                    a = e.Scale_out,
                                                    u = void 0 === a ? 1 : a; return "\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter(" + t + ");\n        float res = pow(float(" + u / s + ") * o, float(" + u / r + ") * c);\n        setOutput(float(res));\n    }\n    " }, textureFuncConf: { counter: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"] }, behaviors: ["processElementwiseAxis", "genElementwiseCounterPos"] }, elementwise_sub: { mainFunc: function(n, e) { var t = e.counterPos,
                                                    o = e.Scale_y,
                                                    r = void 0 === o ? 1 : o,
                                                    i = e.Scale_x,
                                                    s = void 0 === i ? 1 : i,
                                                    a = e.Scale_out,
                                                    u = void 0 === a ? 1 : a; return "\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter(" + t + ");\n        float res = float(" + u / s + ") * o - float(" + u / r + ") * c;\n        setOutput(float(res));\n    }\n    " }, textureFuncConf: { counter: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"] }, behaviors: ["processElementwiseAxis", "genElementwiseCounterPos"] }, mul: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = n.counter,
                                                    r = e.x_num_col_dims,
                                                    i = e.y_num_col_dims,
                                                    s = tn(t),
                                                    a = tn(o),
                                                    u = $(s, r),
                                                    l = u[0],
                                                    c = u[1],
                                                    f = u[2],
                                                    h = u[3],
                                                    p = u[4],
                                                    d = $(a, i),
                                                    g = d[0],
                                                    _ = d[1],
                                                    m = d[2],
                                                    v = d[3]; return "\n    " + nn("x1", l, c) + "\n    " + nn("x2", f, h) + "\n    " + nn("y1", g, _) + "\n    " + nn("y2", m, v) + "\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        " + en(c) + " x1 = getTensorPosFromArrayIndex_x1(b);\n        " + en(v) + " y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < " + p[1] + "; j++) {\n            " + en(h) + " x2 = getTensorPosFromArrayIndex_x2(j);\n            " + en(_) + " y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4(" + en(c) + "(x1), " + en(h) + "(x2));\n            ivec4 yPos = ivec4(" + en(_) + "(y1), " + en(v) + "(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_counter(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        setOutput(res);\n    }\n    " }, textureFuncConf: { counter: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"] } }, matmul: on, matmul_v2: on, fc: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = n.weight,
                                                    r = e.x_num_col_dims,
                                                    i = e.y_num_col_dims,
                                                    s = un(t),
                                                    a = un(o),
                                                    u = rn(s, r),
                                                    l = u[0],
                                                    c = u[1],
                                                    f = u[2],
                                                    h = u[3],
                                                    p = u[4],
                                                    d = rn(a, i),
                                                    g = d[0],
                                                    _ = d[1],
                                                    m = d[2],
                                                    v = d[3]; return "\n    " + sn("x1", l, c) + "\n    " + sn("x2", f, h) + "\n    " + sn("y1", g, _) + "\n    " + sn("y2", m, v) + "\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float bias = getValueFromTensorPos_bias(opos.r, opos.g, opos.b, opos.a);\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        " + an(c) + " x1 = getTensorPosFromArrayIndex_x1(b);\n        " + an(v) + " y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < " + p[1] + "; j++) {\n            " + an(h) + " x2 = getTensorPosFromArrayIndex_x2(j);\n            " + an(_) + " y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4(" + an(c) + "(x1), " + an(h) + "(x2));\n            ivec4 yPos = ivec4(" + an(_) + "(y1), " + an(v) + "(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_weight(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        res = res + bias;\n        setOutput(res);\n    }\n    " }, textureFuncConf: { weight: ["getValueFromTensorPos"], origin: ["getValueFromTensorPos"], bias: ["getValueFromTensorPos"] } }, dropout: { mainFunc: function(n, e) { return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        if (" + ("downgrade_in_infer" === e.dropout_implementation) + ") {\n            o = o * (1.0 - " + e.dropout_prob + ");\n        }\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] } }, concat: { mainFunc: function(n, e) { var t = e.dim,
                                                    o = Object.keys(n).filter((function(n) { return "out" !== n })).map((function(e) { return n[e] })).map((function(n) { var e = n.width_shape,
                                                            o = n.height_shape,
                                                            r = n.channel; return [n.total_shape / (e * o * r), r, o, e][t] })),
                                                    r = o.map((function(n, e) { return o.slice(0, e + 1).reduce((function(n, e) { return n + e }), 0) })),
                                                    i = ""; return r.forEach((function(n, e) { i += 0 === e ? "\n            if (oPos[" + t + "] < " + n + ") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            " : "\n            else if (oPos[" + t + "] < " + n + ") {\n                oPos[" + t + "] = oPos[" + t + "] - " + r[e - 1] + ";\n                o = getValueFromTensorPos_origin_" + e + "(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            " })), "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        " + i + "\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { "@all": ["getValueFromTensorPos"] }, behaviors: ["normalizeDim"] }, concat_mul: { mainFunc: function(n, e) { var t = e.dim,
                                                    o = Object.keys(n).filter((function(n) { return "out" !== n })).map((function(e) { return n[e] })).map((function(n) { var e = n.width_shape,
                                                            o = n.height_shape,
                                                            r = n.channel; return [n.total_shape / (e * o * r), r, o, e][t] })),
                                                    r = o.map((function(n, e) { return o.slice(0, e + 1).reduce((function(n, e) { return n + e }), 0) })),
                                                    i = ""; return r.forEach((function(n, e) { i += 0 === e ? "\n            if (oPos[" + t + "] < " + n + ") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }" : "\n            else if (oPos[" + t + "] < " + n + ") {\n                oPos[" + t + "] = oPos[" + t + "] - " + r[e - 1] + ";\n                o = getValueFromTensorPos_origin_" + e + "(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            " })), "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        " + i + "\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { "@all": ["getValueFromTensorPos"] }, behaviors: ["normalizeDim"] }, split: { mainFunc: function(n, e) { var t = e.target_length,
                                                    o = e.num,
                                                    r = e.dim; return "\n    // start函数\n    void main(void) {\n        int length = int(" + t + " / " + o + ");\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        oPos[" + r + "] = oPos[" + r + "] + layer_run_time * length;\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, behaviors: ["normalizeDim"] }, softmax: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = e.axis,
                                                    r = o; return (!o || o < 0) && (r = (o || -1) + 4), "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        const int n = int(" + t.total_shape + "/" + t.channel + "/" + t.height_shape + "/" + t.width_shape + ");\n        float o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        // 输出坐标转换为输入坐标\n        float total = 0.0;\n        float res = 0.0;\n        if (" + r + " == 0) {\n            for (int i = 0; i < n; i++){\n            float temp = getValueFromTensorPos_origin(i, oPos[1], oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else if (" + r + " == 1) {\n            for (int i = 0; i < " + t.channel + "; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], i, oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else {\n            for (int i = 0; i < " + t.width_shape + "; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], i);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        setOutput(res);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] } }, batchnorm: { mainFunc: function(n, e) { var t = n.bias,
                                                    o = n.scale,
                                                    r = n.mean,
                                                    i = n.variance,
                                                    s = e.epsilon; return "\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        // 归一化数据\n        vec4 scale = getPixelsFromTexturePos_scale(vec2( float(oPos.g) / float(" + o.width_texture + ") + 0.00001, 0.0));\n        vec4 bias = getPixelsFromTexturePos_bias(vec2( float(oPos.g) / float(" + t.width_texture + ") + 0.00001, 0.0));\n        vec4 mean = getPixelsFromTexturePos_mean(vec2((float(oPos.g)) / float(" + r.width_texture + ")  + 0.00001, 0.0));\n        vec4 variance = getPixelsFromTexturePos_variance(\n            vec2((float(oPos.g)) / float(" + i.width_texture + ") + 0.00001,\n            0.0)\n        );\n\n        float x = (o - mean[0]) / sqrt(variance[0] + " + s + ");\n        float res = scale[0] * x + bias[0];\n        setOutput(res);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"], scale: ["getPixelsFromTexturePos"], bias: ["getPixelsFromTexturePos"], mean: ["getPixelsFromTexturePos"], variance: ["getPixelsFromTexturePos"] } }, reshape: ln, reshape2: ln, bilinear_interp: cn, transpose2: { mainFunc: function(n, e) { var t = e.perm_arr,
                                                    o = e.perm_size,
                                                    r = t[0],
                                                    i = t[1],
                                                    s = t[2]; return "\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        // 转置 坐标变换\n        float o = 0.0;\n        if (" + o + " == 1) {\n            o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        }\n        else if (" + o + " == 2) {\n            o = getValueFromTensorPos_origin(\n                oPos[0], oPos[1],\n                oPos[(2 + " + r + ") > 3 ? 3 : (2 + " + r + ")],\n                oPos[(2 + " + i + ") > 3 ? 3 : (2 + " + i + ")]\n            );\n        }\n        else if (" + o + " == 3) {\n            o = getValueFromTensorPos_origin(\n                oPos[0],\n                oPos[(1 + " + r + ") > 3 ? 3 : (1 + " + r + ")],\n                oPos[(1 + " + i + ") > 3 ? 3 : (1 + " + i + ")],\n                oPos[(1 + " + s + ") > 3 ? 3 : (1 + " + s + ")]\n            );\n        }\n        else if (" + o + " == 4) {\n            o = getValueFromTensorPos_origin(\n                oPos[" + r + "],\n                oPos[" + i + "],\n                oPos[" + s + "],\n                oPos[" + t[3] + "]\n            );\n        }\n\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, behaviors: ["normalizePerm"] }, unpacked_2_packed: { mainFunc: function(n, e) { return "\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec4 out4;\n        for (int i = 0; i < 4; i++) {\n            vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] * 4 + i, oPos[2], oPos[3]);\n            out4[i] = o[0];\n        }\n        setPackedOutput(out4);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPosPacking"] } }, packed_2_unpacked: { mainFunc: function(n, e) { return "\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float res = 0.0;\n        int c1 = calMod(oPos[1], 4);\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n        setOutput(res);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPosPacking"] } }, unsqueeze2: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = e.axes,
                                                    r = t.length_unformatted_shape,
                                                    i = Array.isArray(o) ? o : [o],
                                                    s = 4 - r - i.length,
                                                    a = i.map((function(n) { return n + s })),
                                                    u = [0, 1, 2, 3].filter((function(n) { return -1 === a.indexOf(n) })).map((function(n) { return "oPos[" + n + "]" })),
                                                    l = Array.from(new Array(a.length), (function() { return "0" })); return u.splice.apply(u, function() { for (var n = 0, e = 0, t = arguments.length; e < t; e++) n += arguments[e].length; var o = Array(n),
                                                        r = 0; for (e = 0; e < t; e++)
                                                        for (var i = arguments[e], s = 0, a = i.length; s < a; s++, r++) o[r] = i[s]; return o }([0, 0], l)), "\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        o = getValueFromTensorPos_origin(" + u.join(",") + ");\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] } }, flatten_contiguous_range: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = n.out; return "\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * " + o.width_shape + "\n            + oPos.g * " + o.height_shape + " * " + o.width_shape + "\n            + oPos.r * " + o.channel + " * " + o.width_shape + " * " + o.height_shape + ";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            " + t.channel + ",\n            " + t.width_shape + ",\n            " + t.height_shape + ",\n            " + t.total_shape + "\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, commonFuncConf: ["transferFromNHWCtoNCHW"] }, flatten2: ln, greater_than: { mainFunc: function(n, e) { return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        setOutput(bool(x >= y));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"], counter: ["getValueFromTensorPos"] } }, reduce_sum: { mainFunc: function(n, e) { return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < " + e.inputs_dim + "; i++) {\n            oPos[" + e.dim + "] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);;\n        }\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, behaviors: ["normalizeDim"] }, where: { mainFunc: function(n, e) { return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n        float condition = getValueFromTensorPos_condition(oPos.r, oPos.g, oPos.b, oPos.a);\n        float o = 0.0;\n\n        if (bool(condition)) {\n            o = x;\n        }\n        else {\n            o = y;\n        }\n        setOutput(o);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"], counter: ["getValueFromTensorPos"], condition: ["getValueFromTensorPos"] } }, connect: { mainFunc: function(n, e) { var t = n.out,
                                                    o = t.total_shape,
                                                    r = t.width_shape,
                                                    i = t.height_shape,
                                                    s = t.channel,
                                                    a = d([o / (r * i * s), s, i, r]),
                                                    u = Object.keys(n).filter((function(n) { return "out" !== n })).map((function(e) { return n[e].total_shape })),
                                                    l = u.map((function(n, e) { return u.slice(0, e + 1).reduce((function(n, e) { return n + e }), 0) })),
                                                    c = ""; return l.forEach((function(n, e) { c += 0 === e ? "\n            if (sumVal < " + n + ") {\n                co = getTensorPosFromArrayIndex_origin(sumVal);\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n            }" : "\n            else if (sumVal < " + n + ") {\n                co = getTensorPosFromArrayIndex_origin_" + e + "(sumVal - " + l[e - 1] + ");\n                o = getValueFromTensorPos_origin_" + e + "(co.r, co.g, co.b, co.a);\n            }\n            " })), "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        ivec4 co;\n        int sumVal = oPos.b * " + a[2] + " + oPos.a;\n        " + c + "\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { "@all": ["getValueFromTensorPos", "getTensorPosFromArrayIndex"] } }, reduce_mean: { mainFunc: function(n, e) { var t = e.inputs_dim; return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < " + t + "; i++) {\n            oPos[" + e.dim + "] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        }\n        o = o / float(" + t + ");\n        setOutput(o);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, behaviors: ["normalizeDim"] }, hard_swish: { mainFunc: function(n, e) { var t = e.offset,
                                                    o = void 0 === t ? 3 : t,
                                                    r = e.scale,
                                                    i = void 0 === r ? 6 : r,
                                                    s = e.threshold; return "\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float res = o * min(max(0.0, o + float(" + o + ")), float(" + (void 0 === s ? 6 : s) + ")) / float(" + i + ");\n        setOutput(res);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] } }, nearest_interp: _n, nearest_interp_v2: _n, cast: { mainFunc: function(n, e) { var t = ""; switch (e.out_dtype) {
                                                    case 0:
                                                        t = "\n            float res_bool = 0.0;\n            if (o != 0.0) {\n                res_bool = 1.0;\n            }\n            setOutput(res_bool);"; break;
                                                    case 1:
                                                    case 2:
                                                    case 3:
                                                        t = "\n            int res_int = int(o);\n            setOutput(float(res_int));"; break;
                                                    default:
                                                        t = "       \n            float res_float = o;\n            setOutput(res_float);" } return "\n    void main() {\n       // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        " + t + "\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] } }, fill_constant_batch_size_like: { mainFunc: function(n, e) { return "\n    // start函数\n    void main(void) {\n        float res = float(" + e.value + ");\n        setOutput(res);\n    }\n" } }, rnn_matmul: { mainFunc: function(n, e) { var t = n.weightlist_0,
                                                    o = e.input_axis,
                                                    r = e.state_axis,
                                                    i = e.batch,
                                                    s = e.reverse,
                                                    a = void 0 !== s && s ? i - o - 1 : o; return "\n    void main() {\n         float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        \n        if (" + (0 === o) + ") {\n            res = getValueFromTensorPos_origin(out_pos[0], " + a + ", out_pos[2], out_pos[3]);\n            setOutput(res);\n            return;\n        }\n        \n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n\n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float o = 0.0;\n        float w_hh = 0.0;\n        float prestate_h = 0.0;\n        res = getValueFromTensorPos_origin(out_pos[0], " + a + ", out_pos[2], out_pos[3]);\n        for (int j = 0; j < " + t.width_shape + "; j++) {\n            prestate_h = getValueFromTensorPos_prestate(origin_pos[0], origin_pos[1], origin_pos[2], j);\n            w_hh = getValueFromTensorPos_weightlist_0(out_pos[0], " + r + ", out_pos[3], j);\n            o += w_hh * prestate_h;\n        }\n        res += o;\n\n        setOutput(res);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"], prestate: ["getValueFromTensorPos"], weightlist_0: ["getValueFromTensorPos"] } }, rnn_hidden: { mainFunc: function(n, e) { var t = e.state_axis,
                                                    o = e.hidden_size; return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + " + o + ");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + " + 2 * o + ");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + " + 3 * o + ");\n        float counter  = getValueFromTensorPos_counter(oPos.r, " + t + ", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float o = 1.0 / (1.0 + exp(-fourth));\n        float c = f * counter + i * tanh_calc(appender);\n        float h = o * tanh_calc(c);\n        \n        setOutput(h);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"], counter: ["getValueFromTensorPos"] } }, rnn_cell: { mainFunc: function(n, e) { var t = e.state_axis,
                                                    o = e.hidden_size; return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + " + o + ");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + " + 2 * o + ");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + " + 3 * o + ");\n        float counter  = getValueFromTensorPos_counter(oPos.r, " + t + ", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float c = f * counter + i * tanh_calc(appender);\n        \n        setOutput(c);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"], counter: ["getValueFromTensorPos"] } }, rnn_origin: { mainFunc: function(n, e) { var t = n.weightlist_0,
                                                    o = n.weightlist_1,
                                                    r = e.state_axis; return "\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n      \n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float b_ih = getValueFromTensorPos_weightlist_2(0, 0, 0, out_pos[3]);\n        float b_hh = getValueFromTensorPos_weightlist_3(0, 0, 0, out_pos[3]);\n        \n        for (int j = 0; j < " + t.width_shape + "; j++) {\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], 0, j);\n            float w_ih = getValueFromTensorPos_weightlist_0(0, 0, out_pos[3], j);\n            res += w_ih * o;\n        }\n        res += b_ih;\n\n        for (int j = 0; j < " + o.width_shape + "; j++) {\n                float prestate = getValueFromTensorPos_prestate(0, 0, 0, j);\n                float w_hh = getValueFromTensorPos_weightlist_1(0, " + r + ", out_pos[3], j);\n                res += w_hh * prestate;\n        }\n        res += b_hh;\n \n        setOutput(res);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"], prestate: ["getValueFromTensorPos"], weightlist_0: ["getValueFromTensorPos"], weightlist_1: ["getValueFromTensorPos"], weightlist_2: ["getValueFromTensorPos"], weightlist_3: ["getValueFromTensorPos"] } }, pool2d_avg: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = e.strides,
                                                    r = void 0 === o ? [] : o,
                                                    i = e.paddings,
                                                    s = void 0 === i ? [] : i,
                                                    a = e.ksize,
                                                    u = r[0],
                                                    l = void 0 === u ? 1 : u,
                                                    c = r[1],
                                                    f = void 0 === c ? 1 : c,
                                                    h = s[0],
                                                    p = void 0 === h ? 0 : h,
                                                    d = s[1],
                                                    g = void 0 === d ? 0 : d,
                                                    _ = a[0],
                                                    m = a[1]; return "\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * " + l + " - " + p + ";\n        int ox_base = out_pos[3] * " + f + " - " + g + ";\n        for (int fy = 0; fy < " + _ + "; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= " + t.height_shape + ") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < " + m + "; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= " + t.width_shape + ") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                res += curr;\n                // 在平均池化模式忽略填充值(exclusive默认为true）\n            }\n        }\n        res = res / float(" + _ + " * " + m + ");\n        setOutput(res);\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, behaviors: ["setPacked", "setAdaptive", "isGlobalPooling"] }, prelu: dn("prelu"), relu6: dn("relu6"), leakyRelu: dn("leakyRelu"), scale: dn("scale"), sigmoid: dn("sigmoid"), relu: dn("relu"), hard_sigmoid: dn("hard_sigmoid"), pow: dn("pow"), sqrt: dn("sqrt"), tanh: dn("tanh"), squeeze2: gn, pad3d: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = e.paddings,
                                                    r = e.mode,
                                                    i = e.value,
                                                    s = function(n) { var e = n.total_shape,
                                                            t = n.channel,
                                                            o = n.height_shape,
                                                            r = n.width_shape; return [e / t / o / r, t, o, r] }(t),
                                                    a = { reflect: "\n            int a;\n            int b;\n            if (oPos.a - " + o[0] + " < 0) {\n                a = " + o[0] + " - oPos.a;\n            }\n            else if (oPos.a - " + o[0] + " >= " + s[3] + ") {\n                a = " + s[3] + " - (oPos.a - " + o[0] + " - " + s[3] + " + 1) - 1;\n            }\n            else {\n                a = oPos.a - " + o[0] + ";\n            }\n            if (oPos.b - " + o[2] + " < 0) {\n                b = " + o[2] + " - oPos.b;\n            }\n            else if (oPos.b - " + o[2] + " >= " + s[2] + ") {\n                b = " + s[2] + " - (oPos.b - " + o[2] + " - " + s[2] + " + 1) - 1;\n            }\n            else {\n                b = oPos.b - " + o[2] + ";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ", replicate: "\n            int a;\n            int b;\n            if (oPos.a - " + o[0] + " < 0) {\n                a = 0;\n            }\n            else if (oPos.a - " + o[0] + " >= " + s[3] + ") {\n                a = " + s[3] + " - 1;\n            }\n            else {\n                a = oPos.a - " + o[0] + ";\n            }\n            if (oPos.b - " + o[2] + " < 0) {\n                b = 0;\n            }\n            else if (oPos.b - " + o[2] + " >= " + s[2] + ") {\n                b = " + s[2] + " - 1;\n            }\n            else {\n                b = oPos.b - " + o[2] + ";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ", circular: "\n            int a;\n            int b;\n            if (oPos.a - " + o[0] + " < 0) {\n                a = int(mod(float(" + o[0] + " + oPos.a - 1), float(" + s[3] + ")));\n            }\n            else if (oPos.a - " + o[0] + " >= " + s[3] + ") {\n                a = int(mod(float(oPos.a - " + o[0] + " - " + s[3] + "), float(" + s[3] + ")));\n            }\n            else {\n                a = oPos.a - " + o[0] + ";\n            }\n            if (oPos.b - " + o[2] + " < 0) {\n                b = int(mod(float(" + o[2] + " + oPos.b - 1), float(" + s[2] + ")));\n            }\n            else if (oPos.b - " + o[2] + " >= " + s[2] + ") {\n                b = int(mod(float(oPos.b - " + o[2] + " - " + s[2] + "), float(" + s[2] + ")));\n            }\n            else {\n                b = oPos.b - " + o[2] + ";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ", constant: "", undefined: "" }; return "\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = " + (i || "0.0") + ";\n        if (oPos.a - " + o[0] + " >= 0\n            && oPos.b - " + o[2] + " >= 0\n            && oPos.a - " + o[0] + " < " + s[3] + "\n            && oPos.b - " + o[2] + " < " + s[2] + "\n        ) {\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b - " + o[2] + ", oPos.a - " + o[0] + ");\n        }\n        else {\n            " + a[r] + "\n        }\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] } }, bilinear_interp_v2: fn, shuffle_channel: { mainFunc: function(n, e) { var t = n.out,
                                                    o = e.group,
                                                    r = void 0 === o ? 2 : o,
                                                    i = t.total_shape,
                                                    s = t.height_shape,
                                                    a = t.width_shape,
                                                    u = t.channel,
                                                    l = [1, 0, 2, 3]; return "\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n\n        int sumVal = oPos.a\n            + oPos.b * " + a + "\n            + oPos.g * " + s + " * " + a + "\n            + oPos.r * " + u + " * " + a + " * " + s + ";\n\n        ivec4 transpose_out_pos = transferFromNHWCtoNCHW(\n            sumVal,\n            " + r + ",\n            " + a + ",\n            " + s + ",\n            " + i + "\n        );\n\n        ivec4 transpose_in_pos = ivec4(transpose_out_pos[" + l[0] + "],\n            transpose_out_pos[" + l[1] + "], transpose_out_pos[" + l[2] + "], transpose_out_pos[" + l[3] + "]);\n        int sumVal2 = transpose_in_pos.a\n            + transpose_in_pos.b * " + a + "\n            + transpose_in_pos.g * " + s + " * " + a + "\n            + transpose_in_pos.r * " + u / r + " * " + a + " * " + s + ";\n        ivec4 origin_oPos = transferFromNHWCtoNCHW(\n            sumVal2,\n            " + u + ",\n            " + a + ",\n            " + s + ",\n            " + i + "\n        );\n\n\n        o = getValueFromTensorPos_origin(\n            origin_oPos[0],\n            origin_oPos[1],\n            origin_oPos[2],\n            origin_oPos[3]\n        );\n\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, commonFuncConf: ["transferFromNHWCtoNCHW"] }, pack_out: { mainFunc: function(n, e) { return "\n\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec2 outCoord = vCoord.xy * _2d_shape_texture_out;\n        int index = int(outCoord.x) + int(outCoord.y) * int(" + n.out.width_texture + ");\n\n        int first = index * 4;\n        int sec = index * 4 + 1;\n        int third = index * 4 + 2;\n        int fourth = index * 4 + 3;\n\n        ivec4 rPos = getTensorPosFromArrayIndex_origin(first);\n        ivec4 gPos = getTensorPosFromArrayIndex_origin(sec);\n        ivec4 bPos = getTensorPosFromArrayIndex_origin(third);\n        ivec4 aPos = getTensorPosFromArrayIndex_origin(fourth);\n\n        float r = getValueFromTensorPos_origin(rPos.r, rPos.g, rPos.b, rPos.a);\n        float g = getValueFromTensorPos_origin(gPos.r, gPos.g, gPos.b, gPos.a);\n        float b = getValueFromTensorPos_origin(bPos.r, bPos.g, bPos.b, bPos.a);\n        float a = getValueFromTensorPos_origin(aPos.r, aPos.g, aPos.b, aPos.a);\n\n        setPackedOutput(vec4(r, g, b, a));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos", "getTensorPosFromArrayIndex"] } }, nhwc_2_nchw: { mainFunc: function(n, e) { var t = n.origin,
                                                    o = n.out; return "\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a * " + o.channel + "\n            + oPos.b * " + o.width_shape + " * " + o.channel + "\n            + oPos.g\n            + oPos.r * " + o.channel + " * " + o.width_shape + " * " + o.height_shape + ";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            " + t.channel + ",\n            " + t.width_shape + ",\n            " + t.height_shape + ",\n            " + t.total_shape + "\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPos"] }, commonFuncConf: ["transferFromNHWCtoNCHW"] }, feedPost: { mainFunc: function(n, e) { var t = n.out,
                                                    o = e.mean,
                                                    r = void 0 === o ? [0, 0, 0] : o,
                                                    i = e.std,
                                                    s = void 0 === i ? [1, 1, 1] : i,
                                                    a = t.total_shape,
                                                    u = t.height_shape,
                                                    l = t.width_shape,
                                                    c = t.channel; return "\n    // start函数\n    void main(void) {\n        ivec4 nhwcPos = getOutputTensorPos();\n        int sumVal = nhwcPos.a\n            + nhwcPos.b * " + l + "\n            + nhwcPos.g * " + u + " * " + l + "\n            + nhwcPos.r * " + c + " * " + l + " * " + u + ";\n\n        ivec4 oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            " + c + ",\n            " + l + ",\n            " + u + ",\n            " + a + "\n        );\n        float res = 0.0;\n        int c1 = int(mod(float(oPos[1]), 4.0));\n        int c = oPos[1];\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], c / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n\n        if (c == 0) {\n            res = (res - float(" + r[0] + ")) / float(" + s[0] + ");\n        } else if (c == 1) {\n            res = (res - float(" + r[1] + ")) / float(" + s[1] + ");\n        } else if (c == 2) {\n            res = (res - float(" + r[2] + ")) / float(" + s[2] + ");\n        }\n        setOutput(float(res));\n    }\n    " }, textureFuncConf: { origin: ["getValueFromTensorPosPacking"] }, commonFuncConf: ["transferFromNHWCtoNCHW"] }, imgFeed: { mainFunc: function() { return "\n    uniform vec2 u_scale;\n    void main(void) {\n        vec2 outCoord = vCoord.xy;\n        vec2 newPos = vCoord / u_scale;\n        vec2 startPos = (1.0 / u_scale - 1.0) / 2.0;\n        bool exceedX = u_scale.y == 1.0 && (newPos.x < startPos.x || newPos.x > (1.0 + startPos.x));\n        bool exceedY = u_scale.x == 1.0 && (newPos.y < startPos.y || newPos.y > (1.0 + startPos.y));\n        if (exceedX || exceedY) {\n            setPackedOutput(vec4(1.0, 1.0, 1.0, 1.0));\n            return;\n        }\n        newPos = newPos - startPos;\n        vec4 counter = TEXTURE2D(texture_origin, newPos);\n        setPackedOutput(counter);\n    }\n    " }, textureFuncConf: { origin: [] } }, box_coder: { mainFunc: function(n, e) { var t = "decode_center_size" === e.code_type; return "\n    // start函数\n    vec2 getPriorBoxData(int r, int g, int b, int m, int n) {\n        float start = getValueFromTensorPos_priorbox(r, g, b, m);\n        float end = getValueFromTensorPos_priorbox(r, g, b, n);\n        float len = end - start;\n        return vec2(start + len / 2.0, len);\n    }\n    vec2 getBoxVarData(int r, int g, int b, int m, int n) {\n        return vec2(\n            getValueFromTensorPos_priorboxvar(r, g, b, m),\n            getValueFromTensorPos_priorboxvar(r, g, b, n)\n        );\n    }\n    vec2 getTargetBoxData(int r, int g, int b, int m, int n) {\n        " + (t ? "\n            return vec2(\n                getValueFromTensorPos_targetbox(r, g, b, m),\n                getValueFromTensorPos_targetbox(r, g, b, n)\n            );\n        " : "\n            float start = getValueFromTensorPos_targetbox(r, g, b, m);\n            float end = getValueFromTensorPos_targetbox(r, g, b, n);\n            float len = end - start;\n            return vec2(start + len / 2.0, len);\n        ") + "\n    }\n\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int r = int(oPos.r);\n        int g = int(oPos.g);\n        int b = int(oPos.b);\n        int a = int(oPos.a);\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n\n        int m = 0;\n        int n = 0;\n        if (a == 0 || a == " + (t ? 2 : 1) + ") {\n            m = 0;\n            n = 2;\n        }\n        else {\n            m = 1;\n            n = 3;\n        }\n        vec2 priorbox = getPriorBoxData(r, g, b, m, n);\n        vec2 boxvar = getBoxVarData(r, g, b, m, n);\n        vec2 targetbox = getTargetBoxData(r, g, b, m, n);\n        float p1 = priorbox.r;\n        float p2 = priorbox.g;\n        float t1 = targetbox.r;\n        float t2 = targetbox.g;\n        float v1 = boxvar.r;\n        float v2 = boxvar.g;\n\n        " + (t ? "\n            float b1 = p2 * v1 * t1 + p1;\n            float b2 = exp(v2 * t2) * p2;\n            if (a == 0 || a == 1) {\n                o = b1 - b2 / 2.0 ;\n            }\n            else {\n                o = b1 + b2 / 2.0;\n            }\n        " : "\n            if (a == 0 || a == 1) {\n                o = (t1 - p1) / p2 / v1;\n            }\n            else {\n                o = log(abs(t2 / p2)) / v2;\n            }\n        ") + "\n        setOutput(float(o));\n    }\n    " }, textureFuncConf: { targetbox: ["getValueFromTensorPos"], priorbox: ["getValueFromTensorPos"], priorboxvar: ["getValueFromTensorPos"] }, behaviors: [] }, density_prior_box: vn, prior_box: Pn },
                                    bn = new J;! function(n, e, t) { u.backend = n, e && (u.backendInstance = e), t && Object.keys(t).forEach((function(n) {! function(n, e) { var t = n.conf,
                                                o = n.params,
                                                r = n.main,
                                                i = n.mainFunc,
                                                s = n.textureFuncConf,
                                                a = n.commonFuncConf,
                                                l = n.behaviors,
                                                c = void 0 === l ? [] : l,
                                                f = u.backend + "_" + e;
                                            u.opRegistry.ops[f] || (u.opRegistry.ops[f] = { name: e, conf: t, params: o, main: r, mainFunc: i, textureFuncConf: s, commonFuncConf: a, behaviors: c }) }(t[n], n) })) }("webgl", bn, xn) } },
                        e = {};

                    function t(o) { if (e[o]) return e[o].exports; var r = e[o] = { exports: {} }; return n[o](r, r.exports, t), r.exports } return t.d = (n, e) => { for (var o in e) t.o(e, o) && !t.o(n, o) && Object.defineProperty(n, o, { enumerable: !0, get: e[o] }) }, t.g = function() { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (n) { if ("object" == typeof window) return window } }(), t.o = (n, e) => Object.prototype.hasOwnProperty.call(n, e), t.r = n => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n, "__esModule", { value: !0 }) }, t(646) })() }]) }));

        /***/
    })

    /******/
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BwYWRkbGVqcy1tb2RlbHMvZmFjZWRldGVjdC9saWIvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGd0U7QUFFeEUsSUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQXNCLENBQUM7QUFDNUUsSUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQTZCLENBQUM7QUFDdEUsSUFBTSxjQUFjLEdBQUcsNkJBQTZCLENBQUM7QUFDckQsSUFBTSxVQUFVLEdBQUcsSUFBSSxVQUFVLEVBQUUsQ0FBQztBQUNw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MkRBQTJELGdDQUFnQyxnQ0FBZ0MsaUNBQWlDLGlDQUFpQyw4QkFBOEIsOEJBQThCLDZEQUE2RCwyQ0FBMkMscUNBQXFDLHFDQUFxQyxlQUFlLG9CQUFvQixvQ0FBb0MsZUFBZSxrREFBa0QsMENBQTBDLGVBQWUsb0JBQW9CLDZDQUE2QyxlQUFlLDRDQUE0QyxPQUFPLFFBQVEsa0JBQWtCLDZHQUE2RyxjQUFjLG1DQUFtQyxVQUFVLGlCQUFpQiw0RUFBNEUsZUFBZSx1SUFBdUksMkNBQTJDLHdGQUF3RixFQUFFLFNBQVMsR0FBRyxpQkFBaUIsTUFBTSxjQUFjLDRCQUE0QixZQUFZLFlBQVkscUNBQXFDLG1CQUFtQiwrREFBK0QsdUJBQXVCLEVBQUUsZ0JBQWdCLGlEQUFpRCxJQUFJLDJDQUEyQyxTQUFTLDBDQUEwQyxnRUFBZ0UsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxRQUFRLElBQUksR0FBRyxHIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2luZGV4LnRzXCIpO1xuIiwiaW1wb3J0IHsgRmFjZURldGVjdG9yLCBjcmVhdGVJbWFnZSB9IGZyb20gJ0BwYWRkbGVqcy1tb2RlbHMvZmFjZWRldGVjdCc7XHJcblxyXG5jb25zdCByZXNDYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzQ2FudmFzJykgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XHJcbmNvbnN0IHJlc0N0eCA9IHJlc0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuY29uc3QgZGVmYXVsdEltZ1BhdGggPSAnLi9pbWcvbXVsdGlfc21hbGxfZmFjZS5qcGVnJztcclxuY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbmNvbnN0IGxvYWRpbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hZGluZycpO1xyXG5jb25zdCBmYWNlRGV0ZWN0b3IgPSBuZXcgRmFjZURldGVjdG9yKCk7XHJcbmxldCBmYWNlRGVjb3JhdGlvbiA9IG51bGwgYXMgSFRNTEltYWdlRWxlbWVudDtcclxuXHJcbmxvYWQoKTtcclxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VwbG9hZEltZycpIS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGxvYWRGaWxlKHRoaXMpO1xyXG59O1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gbG9hZCgpIHtcclxuICAgIGF3YWl0IGZhY2VEZXRlY3Rvci5pbml0KCk7XHJcbiAgICBmYWNlRGVjb3JhdGlvbiA9IGF3YWl0IGNyZWF0ZUltYWdlKCcuL2ltZy9mYWNlZGVjb3JhdGlvbi5wbmcnKTtcclxuICAgIHJ1bihkZWZhdWx0SW1nUGF0aCk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHJ1bihpbWdQYXRoOiBzdHJpbmcpIHtcclxuICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICBjb25zdCBpbWdFbGUgPSBhd2FpdCBjcmVhdGVJbWFnZShpbWdQYXRoKTtcclxuICAgIGRyYXdJbWFnZShpbWdFbGUpO1xyXG4gICAgLy8g6aKE5rWLXHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmYWNlRGV0ZWN0b3IuZGV0ZWN0KGltZ0VsZSwgeyBzaHJpbms6IDAuNCB9KTtcclxuICAgIGRyYXdEZWNvcmF0aW9uKHJlcyk7XHJcbiAgICBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbn1cclxuXHJcbi8vIOe7mOWbvlxyXG5mdW5jdGlvbiBkcmF3SW1hZ2UoaW1nOiBIVE1MSW1hZ2VFbGVtZW50KSB7XHJcbiAgICBjb25zdCB7IG5hdHVyYWxXaWR0aCwgbmF0dXJhbEhlaWdodCB9ID0gaW1nO1xyXG4gICAgcmVzQ2FudmFzLndpZHRoID0gbmF0dXJhbFdpZHRoO1xyXG4gICAgcmVzQ2FudmFzLmhlaWdodCA9IG5hdHVyYWxIZWlnaHQ7XHJcbiAgICByZXNDdHguZHJhd0ltYWdlKGltZywgMCwgMCwgbmF0dXJhbFdpZHRoLCBuYXR1cmFsSGVpZ2h0KTtcclxufVxyXG5cclxuLy8g57uY5Yi25aS05YOP5qGGXHJcbmZ1bmN0aW9uIGRyYXdEZWNvcmF0aW9uKGRhdGEpIHtcclxuICAgIC8vIOaMieeFp+S6uuiEuOahhumdouenr+aOkuW6jyDov5HlpKfov5zlsI9cclxuICAgIGRhdGEuc29ydCgoaXRlbTEsIGl0ZW0yKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0xLndpZHRoICogaXRlbTEuaGVpZ2h0IC0gaXRlbTIud2lkdGggKiBpdGVtMi5oZWlnaHQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkYXRhLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgcmVzQ3R4LmxpbmVXaWR0aCA9IDQ7XHJcbiAgICAgICAgLy8g5Lq66IS45qGG5L2N572uXHJcbiAgICAgICAgY29uc3QgeCA9IGl0ZW0ubGVmdCAqIHJlc0NhbnZhcy53aWR0aDtcclxuICAgICAgICBjb25zdCB5ID0gaXRlbS50b3AgKiByZXNDYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IHcgPSBpdGVtLndpZHRoICogcmVzQ2FudmFzLndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGggPSBpdGVtLmhlaWdodCAqIHJlc0NhbnZhcy5oZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIOS6uuiEuOijhemlsOS9jee9rlxyXG4gICAgICAgIGNvbnN0IHJhdGlvID0gMS43O1xyXG4gICAgICAgIGNvbnN0IGRlY1cgPSByYXRpbyAqIHc7XHJcbiAgICAgICAgY29uc3QgZGVjSCA9IHJhdGlvICogaDtcclxuICAgICAgICBjb25zdCBkZWNZID0geSAtIChkZWNIIC0gaCkgLyAyO1xyXG4gICAgICAgIGNvbnN0IGRlY1ggPSB4IC0gKGRlY1cgLSB3KSAvIDI7XHJcbiAgICAgICAgcmVzQ3R4LmRyYXdJbWFnZShmYWNlRGVjb3JhdGlvbiwgZGVjWCwgZGVjWSwgZGVjVywgZGVjSCk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZEZpbGUoaXB0KSB7XHJcbiAgICBpZiAoIWlwdC5maWxlcyB8fCAhaXB0LmZpbGVzWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgaWYgKGV2dC50YXJnZXQgJiYgdHlwZW9mIGV2dC50YXJnZXQucmVzdWx0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBydW4oZXZ0LnRhcmdldC5yZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoaXB0LmZpbGVzWzBdKTtcclxufVxyXG4iLCIhZnVuY3Rpb24obixlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLmZhY2VkZXRlY3Q9ZSgpOihuLnBhZGRsZWpzPW4ucGFkZGxlanN8fHt9LG4ucGFkZGxlanMuZmFjZWRldGVjdD1lKCkpfSh0aGlzLChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihuKXt2YXIgZT17fTtmdW5jdGlvbiB0KG8pe2lmKGVbb10pcmV0dXJuIGVbb10uZXhwb3J0czt2YXIgcj1lW29dPXtpOm8sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gbltvXS5jYWxsKHIuZXhwb3J0cyxyLHIuZXhwb3J0cyx0KSxyLmw9ITAsci5leHBvcnRzfXJldHVybiB0Lm09bix0LmM9ZSx0LmQ9ZnVuY3Rpb24obixlLG8pe3QubyhuLGUpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkobixlLHtlbnVtZXJhYmxlOiEwLGdldDpvfSl9LHQucj1mdW5jdGlvbihuKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSx0LnQ9ZnVuY3Rpb24obixlKXtpZigxJmUmJihuPXQobikpLDgmZSlyZXR1cm4gbjtpZig0JmUmJlwib2JqZWN0XCI9PXR5cGVvZiBuJiZuJiZuLl9fZXNNb2R1bGUpcmV0dXJuIG47dmFyIG89T2JqZWN0LmNyZWF0ZShudWxsKTtpZih0LnIobyksT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6bn0pLDImZSYmXCJzdHJpbmdcIiE9dHlwZW9mIG4pZm9yKHZhciByIGluIG4pdC5kKG8scixmdW5jdGlvbihlKXtyZXR1cm4gbltlXX0uYmluZChudWxsLHIpKTtyZXR1cm4gb30sdC5uPWZ1bmN0aW9uKG4pe3ZhciBlPW4mJm4uX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBuLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIG59O3JldHVybiB0LmQoZSxcImFcIixlKSxlfSx0Lm89ZnVuY3Rpb24obixlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sZSl9LHQucD1cIi9cIix0KHQucz0xKX0oW2Z1bmN0aW9uKG4sZSx0KXtuLmV4cG9ydHM9KCgpPT57dmFyIG49ezkxMToobixlKT0+e1widXNlIHN0cmljdFwiO3ZhciB0PWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYpcmV0dXJuIHNlbGY7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdylyZXR1cm4gd2luZG93O2lmKHZvaWQgMCE9PXQpcmV0dXJuIHQ7dGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCIpfSgpO24uZXhwb3J0cz1lPXQuZmV0Y2gsdC5mZXRjaCYmKGUuZGVmYXVsdD10LmZldGNoLmJpbmQodCkpLGUuSGVhZGVycz10LkhlYWRlcnMsZS5SZXF1ZXN0PXQuUmVxdWVzdCxlLlJlc3BvbnNlPXQuUmVzcG9uc2V9LDk5NDoobixlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7dC5yKGUpLHQuZChlLHtQYWRkbGVqc0JhY2tlbmQ6KCk9PlBuLFJ1bm5lcjooKT0+dm4sVHJhbnNmb3JtZXI6KCk9PkYsY29yZVV0aWxzOigpPT5vLGVudjooKT0+ZixpbnRlcmZhY2VzOigpPT5yLHJlZ2lzdGVyQmFja2VuZDooKT0+YixyZWdpc3Rlck9wOigpPT54fSk7dmFyIG89e307dC5yKG8pLHQuZChvLHtBZGRJdGVtVG9WYXJzOigpPT51LGRlbFVzZWxlc3NEYXRhOigpPT5jLGZpbmRWYXJCeUtleTooKT0+YSxnZXRHbG9iYWxJbnRlcmZhY2U6KCk9PmksZ2V0T3JNYWtlR2xvYmFsUHJvcGVydHk6KCk9PnMsdHJhdmVyc2VWYXJzOigpPT5sfSk7dmFyIHI9e307ZnVuY3Rpb24gaSgpe3ZhciBuO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cpbj13aW5kb3c7ZWxzZSBpZih2b2lkIDAhPT10Lmcpbj10Lmc7ZWxzZXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZil0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIGdsb2JhbCBvYmplY3RcIik7bj1zZWxmfXJldHVybiBufWZ1bmN0aW9uIHMobixlKXt2YXIgdD1pKCk7cmV0dXJuIHRbbl18fCh0W25dPWUpLHRbbl19ZnVuY3Rpb24gYShuLGUpe3JldHVybiBBcnJheS5pc0FycmF5KG4pP24uZmluZCgoZnVuY3Rpb24obil7cmV0dXJuIG4ubmFtZT09PWV9KSk6bltlXX1mdW5jdGlvbiB1KG4sZSl7dmFyIHQ9QXJyYXkuaXNBcnJheShuKSxvPUFycmF5LmlzQXJyYXkoZSk/ZTpbZV07dD9vLmZvckVhY2goKGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1udWxsLG89MDtvPG4ubGVuZ3RoO28rKylpZihuW29dLm5hbWU9PT1lLm5hbWUpe3Q9bzticmVha31udWxsIT09dD9uW3RdPWU6bi5wdXNoKGUpfSkpOm8uZm9yRWFjaCgoZnVuY3Rpb24oZSl7bltlLm5hbWVdPWV9KSl9ZnVuY3Rpb24gbChuLGUpe0FycmF5LmlzQXJyYXkobik/bi5mb3JFYWNoKChmdW5jdGlvbihuKXtlKG4pfSkpOk9iamVjdC5rZXlzKG4pLmZvckVhY2goKGZ1bmN0aW9uKHQpe2Uoblt0XSl9KSl9ZnVuY3Rpb24gYyhuKXtpZihuLm9wcz1udWxsLG4udmFycyBpbnN0YW5jZW9mIEFycmF5KWZvcih2YXIgZT0wO2U8bi52YXJzLmxlbmd0aDtlKyspbi52YXJzW2VdLmRhdGEmJmRlbGV0ZSBuLnZhcnNbZV0uZGF0YTtlbHNlIGZvcih2YXIgdCBpbiBuLnZhcnMpbi52YXJzW3RdLmRhdGEmJmRlbGV0ZSBuLnZhcnNbdF0uZGF0YX10LnIociksdC5kKHIse0J1ZmZlclR5cGU6KCk9PmcsR3JhcGhUeXBlOigpPT52LFVuaWZvcm1UeXBlOigpPT5tLFdhc21NZW1vcnlUeXBlOigpPT5ffSk7Y29uc3QgZj1zKFwiZW52XCIsbmV3KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gbigpe3RoaXMuRU5WPXt9fXJldHVybiBuLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24obixlKXt0aGlzLkVOVltuXT1lfSxuLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuRU5WW25dfSxufSgpKSk7dmFyIGg9ZnVuY3Rpb24obixlLHQsbyl7cmV0dXJuIG5ldyh0fHwodD1Qcm9taXNlKSkoKGZ1bmN0aW9uKHIsaSl7ZnVuY3Rpb24gcyhuKXt0cnl7dShvLm5leHQobikpfWNhdGNoKG4pe2kobil9fWZ1bmN0aW9uIGEobil7dHJ5e3Uoby50aHJvdyhuKSl9Y2F0Y2gobil7aShuKX19ZnVuY3Rpb24gdShuKXt2YXIgZTtuLmRvbmU/cihuLnZhbHVlKTooZT1uLnZhbHVlLGUgaW5zdGFuY2VvZiB0P2U6bmV3IHQoKGZ1bmN0aW9uKG4pe24oZSl9KSkpLnRoZW4ocyxhKX11KChvPW8uYXBwbHkobixlfHxbXSkpLm5leHQoKSl9KSl9LHA9ZnVuY3Rpb24obixlKXt2YXIgdCxvLHIsaSxzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJnJbMF0pdGhyb3cgclsxXTtyZXR1cm4gclsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBpPXtuZXh0OmEoMCksdGhyb3c6YSgxKSxyZXR1cm46YSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoaVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxpO2Z1bmN0aW9uIGEoaSl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihpKXtpZih0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKHQ9MSxvJiYocj0yJmlbMF0/by5yZXR1cm46aVswXT9vLnRocm93fHwoKHI9by5yZXR1cm4pJiZyLmNhbGwobyksMCk6by5uZXh0KSYmIShyPXIuY2FsbChvLGlbMV0pKS5kb25lKXJldHVybiByO3N3aXRjaChvPTAsciYmKGk9WzImaVswXSxyLnZhbHVlXSksaVswXSl7Y2FzZSAwOmNhc2UgMTpyPWk7YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOmlbMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxvPWlbMV0saT1bMF07Y29udGludWU7Y2FzZSA3Omk9cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoISgocj0ocj1zLnRyeXMpLmxlbmd0aD4wJiZyW3IubGVuZ3RoLTFdKXx8NiE9PWlbMF0mJjIhPT1pWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1pWzBdJiYoIXJ8fGlbMV0+clswXSYmaVsxXTxyWzNdKSl7cy5sYWJlbD1pWzFdO2JyZWFrfWlmKDY9PT1pWzBdJiZzLmxhYmVsPHJbMV0pe3MubGFiZWw9clsxXSxyPWk7YnJlYWt9aWYociYmcy5sYWJlbDxyWzJdKXtzLmxhYmVsPXJbMl0scy5vcHMucHVzaChpKTticmVha31yWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9aT1lLmNhbGwobixzKX1jYXRjaChuKXtpPVs2LG5dLG89MH1maW5hbGx5e3Q9cj0wfWlmKDUmaVswXSl0aHJvdyBpWzFdO3JldHVybnt2YWx1ZTppWzBdP2lbMV06dm9pZCAwLGRvbmU6ITB9fShbaSxhXSl9fX07Y29uc3QgZD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obil7dGhpcy51cmxDb25mPXtkaXI6XCJcIixtYWluOlwiXCJ9LHRoaXMuc2VwYXJhdGVDaHVuaz0hMCx0aGlzLmNodW5rTnVtPTEsdGhpcy5kYXRhVHlwZT1cImJpbmFyeVwiLHRoaXMucGFyYW1zPXt0eXBlOlwiZmV0Y2hcIn0sdGhpcy5pbk5vZGU9ITEsdGhpcy5pc0xvY2FsRmlsZT0hMSx0aGlzLnJlYWxGZXRjaD1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIkVSUk9SOiBlbXB0eSBmZXRjaCBmdW5jaXRvblwiKX07dmFyIGU9bix0PVwibW9kZWwuanNvblwiO2lmKG4uZW5kc1dpdGgoXCIuanNvblwiKSl7dmFyIG89bi5sYXN0SW5kZXhPZihcIi9cIikrMTtlPW4uc3Vic3RyKDAsbyksdD1uLnN1YnN0cihvKX1lbHNlXCIvXCIhPT1uLmNoYXJBdChuLmxlbmd0aC0xKSYmKGU9bitcIi9cIik7dGhpcy5pc0xvY2FsRmlsZT0wIT09ZS5pbmRleE9mKFwiaHR0cFwiKSx0aGlzLnVybENvbmY9e2Rpcjp0aGlzLmlzTG9jYWxGaWxlP1wiL1wiPT09ZS5jaGFyQXQoMCk/XCJcIitlOlwiL1wiK2U6ZSxtYWluOnR9LHRoaXMuaW5Ob2RlPVwibm9kZVwiPT09Zi5nZXQoXCJwbGF0Zm9ybVwiKX1yZXR1cm4gbi5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBoKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gcCh0aGlzLChmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZmV0Y2hNb2RlbCgpXTtjYXNlIDE6cmV0dXJuIGU9dC5zZW50KCksdGhpcy5zZXBhcmF0ZUNodW5rPSEhZS5jaHVua051bSYmZS5jaHVua051bT4wLHRoaXMuY2h1bmtOdW09dGhpcy5zZXBhcmF0ZUNodW5rP2UuY2h1bmtOdW06MCx0aGlzLnNlcGFyYXRlQ2h1bms/XCJiaW5hcnlcIiE9PXRoaXMuZGF0YVR5cGU/WzMsM106WzQsdGhpcy5mZXRjaENodW5rcygpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBuLmFsbG9jYXRlUGFyYW1zVmFyKGUudmFycyx0KX0pKV06WzMsM107Y2FzZSAyOnQuc2VudCgpLHQubGFiZWw9MztjYXNlIDM6cmV0dXJuWzIsZV19fSkpfSkpfSxuLnByb3RvdHlwZS5mZXRjaE9uZUNodW5rPWZ1bmN0aW9uKG4pe3JldHVybiBoKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiBmLmdldChcImZldGNoXCIpP1s0LGYuZ2V0KFwiZmV0Y2hcIikobix7dHlwZTpcImFycmF5QnVmZmVyXCJ9KV06WzMsMl07Y2FzZSAxOnJldHVyblsyLGUuc2VudCgpXTtjYXNlIDI6cmV0dXJuWzIsdGhpcy5mZXRjaChuKS50aGVuKChmdW5jdGlvbihuKXtyZXR1cm4gbi5hcnJheUJ1ZmZlcigpfSkpXX19KSl9KSl9LG4ucHJvdG90eXBlLmZldGNoSnNvbj1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5mZXRjaChuKS50aGVuKChmdW5jdGlvbihuKXtyZXR1cm4gbi5qc29uKCl9KSl9LG4ucHJvdG90eXBlLmdldEZpbGVOYW1lPWZ1bmN0aW9uKG4pe3JldHVyblwiY2h1bmtfXCIrbitcIi5kYXRcIn0sbi5wcm90b3R5cGUuZmV0Y2hDaHVua3M9ZnVuY3Rpb24oKXtyZXR1cm4gaCh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sZSx0O3JldHVybiBwKHRoaXMsKGZ1bmN0aW9uKG8pe2ZvcihuPXRoaXMuY2h1bmtOdW0sZT1bXSx0PTE7dDw9bjt0KyspZS5wdXNoKHRoaXMuZmV0Y2hPbmVDaHVuayh0aGlzLnVybENvbmYuZGlyK3RoaXMuZ2V0RmlsZU5hbWUodCkpKTtyZXR1cm5bMixQcm9taXNlLmFsbChlKS50aGVuKChmdW5jdGlvbihuKXt2YXIgZSx0PTAsbz1bXTtuLmZvckVhY2goKGZ1bmN0aW9uKG4pe2U9bmV3IEZsb2F0MzJBcnJheShuKSxvLnB1c2goZSksdCs9ZS5sZW5ndGh9KSk7dmFyIHI9bmV3IEZsb2F0MzJBcnJheSh0KSxpPTA7cmV0dXJuIG8uZm9yRWFjaCgoZnVuY3Rpb24obil7bi5mb3JFYWNoKChmdW5jdGlvbihuKXtyW2ldPW4saSs9MX0pKX0pKSxyfSkpXX0pKX0pKX0sbi5hbGxvY2F0ZVBhcmFtc1Zhcj1mdW5jdGlvbihuLGUpe3ZhciB0LG89MDtsKG4sKGZ1bmN0aW9uKG4pe3Q9bi5zaGFwZS5yZWR1Y2UoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4qZX0pKSxuLnBlcnNpc3RhYmxlJiYobi5kYXRhPWUuc2xpY2UobyxvK3QpLG8rPXQpfSkpfSxuLnByb3RvdHlwZS5mZXRjaD1mdW5jdGlvbihuLGUpe2lmKGYuZ2V0KFwiZmV0Y2hcIikpcmV0dXJuIGYuZ2V0KFwiZmV0Y2hcIikobixlfHx7fSk7dmFyIG89KGV8fHRoaXMucGFyYW1zKS5tZXRob2R8fFwiZ2V0XCIscj1uZXcodGhpcy5pbk5vZGU/dCg5MTEpLkhlYWRlcnM6SGVhZGVycyk7cmV0dXJuIHRoaXMucmVhbEZldGNoPXRoaXMuaW5Ob2RlP3RoaXMuaXNMb2NhbEZpbGU/dGhpcy5mZXRjaExvY2FsRmlsZTp0KDkxMSk6d2luZG93LmZldGNoLmJpbmQod2luZG93KSx0aGlzLnJlYWxGZXRjaChuLHttZXRob2Q6byxoZWFkZXJzOnJ9KX0sbi5wcm90b3R5cGUuZmV0Y2hMb2NhbEZpbGU9ZnVuY3Rpb24obil7dmFyIGU9dCg5OTMpO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxvKXt0cnl7dChlLnJlYWRGaWxlU3luYyhuLFwidXRmOFwiKSl9Y2F0Y2gobil7byhuKX19KSl9LG4ucHJvdG90eXBlLmZldGNoTW9kZWw9ZnVuY3Rpb24oKXt2YXIgbj10aGlzLGU9dGhpcy5wYXJhbXMsdD10aGlzLnVybENvbmYuZGlyK3RoaXMudXJsQ29uZi5tYWluLG89bnVsbDtyZXR1cm5cImZldGNoXCI9PT1lLnR5cGUmJihvPW5ldyBQcm9taXNlKChmdW5jdGlvbihvLHIpe24uZmV0Y2godCxlKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gZi5nZXQoXCJmZXRjaFwiKT9lOm4uaXNMb2NhbEZpbGUmJm4uaW5Ob2RlP0pTT04ucGFyc2UoZSk6ZS5qc29uKCl9KSkudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIG8obil9KSkudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIHIobil9KSl9KSkpLG99LG59KCk7dmFyIGcsXyxtLHY7IWZ1bmN0aW9uKG4pe24uRnJhbWVCdWZmZXI9XCJmcmFtZUJ1ZmZlclwiLG4uQ29sb3JCdWZmZXI9XCJjb2xvckJ1ZmZlclwifShnfHwoZz17fSkpLGZ1bmN0aW9uKG4pe24ubWVtb3J5MTAwPVwiMTAwXCIsbi5tZW1vcnkyMDA9XCIyMDBcIixuLm1lbW9yeTMwMD1cIjMwMFwiLG4ubWVtb3J5NDAwPVwiNDAwXCIsbi5tZW1vcnk1MDA9XCI1MDBcIixuLm1lbW9yeTYwMD1cIjYwMFwiLG4ubWVtb3J5NzAwPVwiNzAwXCIsbi5tZW1vcnk4MDA9XCI4MDBcIixuLm1lbW9yeTkwMD1cIjkwMFwifShffHwoXz17fSkpLGZ1bmN0aW9uKG4pe24udW5pZm9ybTFmPVwiMWZcIixuLnVuaWZvcm0xZnY9XCIxZnZcIixuLnVuaWZvcm0xaT1cIjFpXCIsbi51bmlmb3JtMWl2PVwiMWl2XCIsbi51bmlmb3JtMmY9XCIyZlwiLG4udW5pZm9ybTJmdj1cIjJmdlwiLG4udW5pZm9ybTJpPVwiMmlcIixuLnVuaWZvcm0yaXY9XCIyaXZcIixuLnVuaWZvcm0zZj1cIjNmXCIsbi51bmlmb3JtM2Z2PVwiM2Z2XCIsbi51bmlmb3JtM2k9XCIzaVwiLG4udW5pZm9ybTNpdj1cIjNpdlwiLG4udW5pZm9ybTRmPVwiNGZcIixuLnVuaWZvcm00ZnY9XCI0ZnZcIixuLnVuaWZvcm00aT1cIjRpXCIsbi51bmlmb3JtNGl2PVwiNGl2XCJ9KG18fChtPXt9KSksZnVuY3Rpb24obil7bi5TaW5nbGVPdXRwdXQ9XCJzaW5nbGVcIixuLk11bHRpcGxlT3V0cHV0PVwibXVsdGlwbGVcIixuLk11bHRpcGxlSW5wdXQ9XCJtdWx0aXBsZUlucHV0XCJ9KHZ8fCh2PXt9KSk7dmFyIFA9e29wUmVnaXN0cnk6e29wczp7fX0sYmFja2VuZDpcIlwiLGJhY2tlbmRJbnN0YW5jZTpudWxsfTtmdW5jdGlvbiB4KG4sZSl7dmFyIHQ9bi5jb25mLG89bi5wYXJhbXMscj1uLm1haW4saT1uLm1haW5GdW5jLHM9bi50ZXh0dXJlRnVuY0NvbmYsYT1uLmNvbW1vbkZ1bmNDb25mLHU9bi5iZWhhdmlvcnMsbD12b2lkIDA9PT11P1tdOnUsYz1QLmJhY2tlbmQrXCJfXCIrZTtQLm9wUmVnaXN0cnkub3BzW2NdfHwoUC5vcFJlZ2lzdHJ5Lm9wc1tjXT17bmFtZTplLGNvbmY6dCxwYXJhbXM6byxtYWluOnIsbWFpbkZ1bmM6aSx0ZXh0dXJlRnVuY0NvbmY6cyxjb21tb25GdW5jQ29uZjphLGJlaGF2aW9yczpsfSl9ZnVuY3Rpb24gYihuLGUsdCl7biYmKFAuYmFja2VuZD1uKSxlJiYoUC5iYWNrZW5kSW5zdGFuY2U9ZSksdCYmT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZnVuY3Rpb24obil7eCh0W25dLG4pfSkpfVA9cyhcIkdMT0JBTFNcIixQKTt2YXIgVD1pKCk7VC5JbWFnZUJpdG1hcHx8KFQuSW1hZ2VCaXRtYXA9ZnVuY3Rpb24oKXt9KTtjb25zdCB5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLGUpe3RoaXMuaWQ9XCJcIix0aGlzLnR5cGU9XCJcIix0aGlzLmlucHV0cz17fSx0aGlzLm91dHB1dHM9e30sdGhpcy5hdHRycz17fSx0aGlzLnN1YkF0dHJzPVtdLHRoaXMubmV4dD1cIlwiLHRoaXMub3BEYXRhPW51bGwsdGhpcy5pc1BhY2tlZD0hMSx0aGlzLmJ1ZmZlclR5cGU9Zy5GcmFtZUJ1ZmZlcix0aGlzLnVuaWZvcm09bnVsbDt2YXIgdD1uLmlucHV0cyxvPW4ub3V0cHV0cyxyPW4uYXR0cnMsaT12b2lkIDA9PT1yP3t9OnIscz1uLnR5cGUsYT1uLmlzUGFja2VkLHU9dm9pZCAwIT09YSYmYSxsPW4uYnVmZmVyVHlwZSxjPXZvaWQgMD09PWw/Zy5GcmFtZUJ1ZmZlcjpsLGY9bi51bmlmb3JtLGg9dm9pZCAwPT09Zj9udWxsOmY7dGhpcy5pZD1zK1wiX1wiKyArbmV3IERhdGUrXCJfXCIrZSx0aGlzLmlucHV0cz10LHRoaXMub3V0cHV0cz1vLHRoaXMuYXR0cnM9aSx0aGlzLnN1YkF0dHJzPW5bXCJzdWItYXR0cnNcIl18fFtdLHRoaXMudW5pZm9ybT1oLHRoaXMudHlwZT1zLHRoaXMuaXNQYWNrZWQ9dSx0aGlzLmJ1ZmZlclR5cGU9Yyx0aGlzLm5leHQ9XCJcIix0aGlzLm9wRGF0YT1udWxsfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkobi5wcm90b3R5cGUsXCJpbnB1dHNOYW1lXCIse2dldDpmdW5jdGlvbigpe3ZhciBuPXRoaXMsZT1bXTtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5pbnB1dHMpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2UucHVzaChuLmlucHV0c1t0XVswXSl9KSksZX0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobi5wcm90b3R5cGUsXCJvdXRwdXRzTmFtZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vdXRwdXRzLk91dHB1dHx8dGhpcy5vdXRwdXRzLk91dHx8dGhpcy5vdXRwdXRzLll9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksbi5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihuKXtQLmJhY2tlbmRJbnN0YW5jZS5ydW5Qcm9ncmFtKHRoaXMub3BEYXRhLG4pfSxufSgpLEY9ZnVuY3Rpb24obil7dGhpcy5uYW1lPW59O3ZhciB3LEU9KHc9ZnVuY3Rpb24obixlKXtyZXR1cm4odz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24obixlKXtuLl9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24obixlKXtmb3IodmFyIHQgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSYmKG5bdF09ZVt0XSl9KShuLGUpfSxmdW5jdGlvbihuLGUpe2Z1bmN0aW9uIHQoKXt0aGlzLmNvbnN0cnVjdG9yPW59dyhuLGUpLG4ucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KHQucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyB0KX0pLEE9e2NvbnYyZDpmdW5jdGlvbihuLGUpe3ZhciB0PW4uYXR0cnMuc3RyaWRlcyxvPW4uaW5wdXRzLklucHV0WzBdLHI9bi5pbnB1dHMuRmlsdGVyWzBdO2lmKFwiaW1hZ2VcIj09PW8pcmV0dXJuITE7dmFyIGk9YShlLG8pLnNoYXBlLHM9YShlLHIpLnNoYXBlO3JldHVybiF0LmZpbmQoKGZ1bmN0aW9uKG4pe3JldHVybiBuPjF9KSkmJmlbaS5sZW5ndGgtMS0yXSU0PT0wJiY0PT09cy5sZW5ndGgmJnNbMF0lND09MCYmc1sxXSU0PT0wfX07ZnVuY3Rpb24gTyhuKXtyZXR1cm57dHlwZTpcInBhY2tlZF8yX3VucGFja2VkXCIsYXR0cnM6e30saW5wdXRzOntJbnB1dDpbbi5pbnB1dE5hbWVdfSxvdXRwdXRzOntPdXRwdXQ6W24ub3V0cHV0TmFtZV19fX1mdW5jdGlvbiBWKG4pe3JldHVybnt0eXBlOlwidW5wYWNrZWRfMl9wYWNrZWRcIixhdHRyczp7fSxpbnB1dHM6e0lucHV0OltuLmlucHV0TmFtZV19LG91dHB1dHM6e091dHB1dDpbbi5vdXRwdXROYW1lXX19fWZ1bmN0aW9uIEMobixlKXtPYmplY3Qua2V5cyhuLmlucHV0cykuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bi5pbnB1dHNbZV09W24uaW5wdXRzW2VdK1wiX3BhY2tlZFwiXX0pKSxPYmplY3Qua2V5cyhuLm91dHB1dHMpLmZvckVhY2goKGZ1bmN0aW9uKGUpe24ub3V0cHV0c1tlXT1bbi5vdXRwdXRzW2VdK1wiX3BhY2tlZFwiXX0pKSxuLnR5cGU9bi50eXBlK1wiX3BhY2tpbmdcIixuLmlkPW4udHlwZStcIl9cIisgK25ldyBEYXRlK1wiX1wiK2UubGVuZ3RoLG4uaXNQYWNrZWQ9ITB9Y29uc3QgUz1mdW5jdGlvbihuKXtmdW5jdGlvbiBlKCl7cmV0dXJuIG4uY2FsbCh0aGlzLFwiVGV4dHVyZVBhY2tpbmdcIil8fHRoaXN9cmV0dXJuIEUoZSxuKSxlLnByb3RvdHlwZS50cmFuc2Zvcm09ZnVuY3Rpb24oKXtmb3IodmFyIG49W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspbltlXT1hcmd1bWVudHNbZV07aWYoXCJ3ZWJnbFwiPT09UC5iYWNrZW5kJiZmLmdldChcIndlYmdsX3BhY2tfY2hhbm5lbFwiKSl7dmFyIHQ9blswXSxvPW5bMV0scj1uWzJdLGk9XCJkZXB0aHdpc2VfY29udjJkXCI9PT10LnR5cGU/XCJjb252MmRcIjp0LnR5cGUscz1BW2ldO2lmKHMmJnModCxvKSl7dmFyIGE9dC5pbnB1dHMsdT10Lm91dHB1dHMsbD1hLklucHV0WzBdLGM9dS5PdXRwdXQ/dS5PdXRwdXRbMF06dS5PdXRbMF0saD1WKHtpbnB1dE5hbWU6bCxvdXRwdXROYW1lOmwrXCJfcGFja2VkXCJ9KSxwPXIubGVuZ3RoO3IucHVzaChuZXcgeShoLHApKSxDKHQscik7dmFyIGQ9Tyh7aW5wdXROYW1lOmMrXCJfcGFja2VkXCIsb3V0cHV0TmFtZTpjfSksZz1yLmxlbmd0aCsxO3IucHVzaChuZXcgeShkLGcpKX19fSxlfShGKTt2YXIgaz1mdW5jdGlvbigpe3ZhciBuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKG49T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKG4sZSl7bi5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKG4sZSl7Zm9yKHZhciB0IGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkmJihuW3RdPWVbdF0pfSkoZSx0KX07cmV0dXJuIGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbygpe3RoaXMuY29uc3RydWN0b3I9ZX1uKGUsdCksZS5wcm90b3R5cGU9bnVsbD09PXQ/T2JqZWN0LmNyZWF0ZSh0KTooby5wcm90b3R5cGU9dC5wcm90b3R5cGUsbmV3IG8pfX0oKTtjb25zdCBSPWZ1bmN0aW9uKG4pe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbi5jYWxsKHRoaXMsXCJGb3JtYXRJbnB1dHNYXCIpfHx0aGlzfXJldHVybiBrKGUsbiksZS5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKW5bZV09YXJndW1lbnRzW2VdO3ZhciB0PW5bMF0sbz1bXCJjb25jYXRcIixcImNvbm5lY3RcIixcImZjXCIsXCJybm5fb3JpZ2luXCIsXCJybm5fbWF0bXVsXCJdO2lmKG8uaW5jbHVkZXModC50eXBlKSl7dmFyIHI9dC5pbnB1dHM7aWYoKFwicm5uX29yaWdpblwiPT09dC50eXBlfHxcInJubl9tYXRtdWxcIj09PXQudHlwZSkmJnIuV2VpZ2h0TGlzdC5sZW5ndGg+MClyLldlaWdodExpc3QuZm9yRWFjaCgoZnVuY3Rpb24obixlKXtyW1wid2VpZ2h0bGlzdF9cIitlXT1bbl19KSk7ZWxzZXt2YXIgaT1yLlh8fHIuSW5wdXQ7aS5sZW5ndGg+MSYmKGkuZm9yRWFjaCgoZnVuY3Rpb24obixlKXtyW1wib3JpZ2luXCIrKGU+MD9cIl9cIitlOlwiXCIpXT1bbl19KSksZGVsZXRlIHIuWCxkZWxldGUgci5JbnB1dCl9fX0sZX0oRik7dmFyIEk9ZnVuY3Rpb24oKXt2YXIgbj1mdW5jdGlvbihlLHQpe3JldHVybihuPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLGUpe24uX19wcm90b19fPWV9fHxmdW5jdGlvbihuLGUpe2Zvcih2YXIgdCBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpJiYoblt0XT1lW3RdKX0pKGUsdCl9O3JldHVybiBmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG8oKXt0aGlzLmNvbnN0cnVjdG9yPWV9bihlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KG8ucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyBvKX19KCksTT1mdW5jdGlvbigpe2Zvcih2YXIgbj0wLGU9MCx0PWFyZ3VtZW50cy5sZW5ndGg7ZTx0O2UrKyluKz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciBvPUFycmF5KG4pLHI9MDtmb3IoZT0wO2U8dDtlKyspZm9yKHZhciBpPWFyZ3VtZW50c1tlXSxzPTAsYT1pLmxlbmd0aDtzPGE7cysrLHIrKylvW3JdPWlbc107cmV0dXJuIG99O2Z1bmN0aW9uIEwobixlKXt2YXIgdD1hKGUsbik7cmV0dXJuIHQ/dC5zaGFwZTpbXX1mdW5jdGlvbiBqKG4sZSx0LG8pe2Zvcih2YXIgcj1NKGUpLGk9MCxzPTAsYT1uO3M8YS5sZW5ndGg7cysrKWkrPUwoYVtzXSxvKVt0XTtyZXR1cm4gclt0XT1pLHtuYW1lOm5bbi5sZW5ndGgtMV0rXCJfb3V0XCIsc2hhcGU6cn19Y29uc3QgRD1mdW5jdGlvbihuKXtmdW5jdGlvbiBlKCl7cmV0dXJuIG4uY2FsbCh0aGlzLFwic3BsaXRPcFwiKXx8dGhpc31yZXR1cm4gSShlLG4pLGUucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbigpe2Zvcih2YXIgbixlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWVbdF09YXJndW1lbnRzW3RdO2Zvcih2YXIgbz1lWzBdLHI9ZVsxXSxpPTAscz1vLmxlbmd0aDtpPHM7aSsrKXt2YXIgYT1vW2ldO2lmKFwiY29uY2F0XCI9PT1hLnR5cGUmJihudWxsPT09KG49YS5pbnB1dHMpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLlgpJiYhKGEuaW5wdXRzLlgubGVuZ3RoPD00KSl7dmFyIGw9YS5hdHRycyxjPWEuaW5wdXRzLGY9YS5vdXRwdXRzLGg9Yy5YLHA9aC5sZW5ndGgsZD1NYXRoLmNlaWwoKHAtNCkvMykrMSxnPWYuT3V0WzBdLF89TChnLHIpLG09bC5heGlzfHwwO209bT4tMT9tOl8ubGVuZ3RoK207Zm9yKHZhciB2PVtdLFA9W10seD1oLnNsaWNlKDAsNCksYj12b2lkIDAsVD0wO1Q8ZDtUKyspe3ZhciB5PTA9PT1UP3g6aC5zbGljZSgzKlQrMSwzKihUKzEpKzEpLEY9aih5LF8sbSxyKTswIT09VCYmeS5zcGxpY2UoMCwwLGIubmFtZSksRi5zaGFwZVttXSs9Yj9iLnNoYXBlW21dOjA7dmFyIHc9e091dDpbRi5uYW1lXX07UC5wdXNoKHthdHRyczpsLGlucHV0czp7WDp5fSxvdXRwdXRzOncsdHlwZTpcImNvbmNhdFwifSksdi5wdXNoKEYpLGI9Rn1QW2QtMV0ub3V0cHV0cy5PdXQ9W2ddLG8uc3BsaWNlLmFwcGx5KG8sTShbaSwxXSxQKSksdShyLHYpfX19LGV9KEYpO3ZhciBOPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPTAsZT0wLHQ9YXJndW1lbnRzLmxlbmd0aDtlPHQ7ZSsrKW4rPWFyZ3VtZW50c1tlXS5sZW5ndGg7dmFyIG89QXJyYXkobikscj0wO2ZvcihlPTA7ZTx0O2UrKylmb3IodmFyIGk9YXJndW1lbnRzW2VdLHM9MCxhPWkubGVuZ3RoO3M8YTtzKysscisrKW9bcl09aVtzXTtyZXR1cm4gb307ZnVuY3Rpb24gQihuKXtpZihuLmxlbmd0aDw0KXtmb3IodmFyIGU9W10sdD0wO3Q8NC1uLmxlbmd0aDt0KyspZS5wdXNoKDEpO3JldHVybiBlLmNvbmNhdChuKX1yZXR1cm4gTihuKX1mdW5jdGlvbiBVKG4pe3JldHVybiBuLnJlZHVjZSgoZnVuY3Rpb24obixlKXtyZXR1cm4gbitlfSkpfWZ1bmN0aW9uIEcobixlKXt2YXIgdD1uLmxlbmd0aDtyZXR1cm4gNC10KyhlPi0xP2U6dCtlKX1mdW5jdGlvbiBXKG4sZSl7Zm9yKHZhciB0PWVbMF0sbz1lWzFdLHI9ZVsyXSxpPWVbM10scz1yKmksYT1vKnIqaSx1PVtdLGw9MDtsPHQ7bCsrKWZvcih2YXIgYz0wO2M8aTtjKyspZm9yKHZhciBmPTA7ZjxvO2YrKylmb3IodmFyIGg9MDtoPHI7aCsrKXUucHVzaChuW2wqYStmKnMraCppK2NdKTtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh1KX1mdW5jdGlvbiBIKG4pe2Zvcih2YXIgZSx0PW4uZGF0YSxvPW4uc2hhcGUscj1OKG8pLnJldmVyc2UoKSxpPTAscz1yLmxlbmd0aC0xO2k8cztpKyspZT1YKGV8fHQscltpXSk7cmV0dXJuIGV9ZnVuY3Rpb24gWChuLGUpe2Zvcih2YXIgdD1bXSxvPTAscj1uLmxlbmd0aDtvPHI7bys9ZSl0LnB1c2gobi5zbGljZShvLG8rZSkpO3JldHVybiB0fXZhciB6PWZ1bmN0aW9uKCl7dmFyIG49ZnVuY3Rpb24oZSx0KXtyZXR1cm4obj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24obixlKXtuLl9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24obixlKXtmb3IodmFyIHQgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSYmKG5bdF09ZVt0XSl9KShlLHQpfTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBvKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfW4oZSx0KSxlLnByb3RvdHlwZT1udWxsPT09dD9PYmplY3QuY3JlYXRlKHQpOihvLnByb3RvdHlwZT10LnByb3RvdHlwZSxuZXcgbyl9fSgpLHE9XCJmZXRjaF9wYWNrXCI7Y29uc3QgWT1mdW5jdGlvbihuKXtmdW5jdGlvbiBlKCl7cmV0dXJuIG4uY2FsbCh0aGlzLFwiUGFja091dFwiKXx8dGhpc31yZXR1cm4geihlLG4pLGUucHJvdG90eXBlLnRyYW5zZm9ybT1mdW5jdGlvbigpe2Zvcih2YXIgbj1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyluW2VdPWFyZ3VtZW50c1tlXTtpZihmLmdldChcIndlYmdsX3BhY2tfb3V0cHV0XCIpKXt2YXIgdD1uWzBdLG89blsxXSxyPXQuZmluZCgoZnVuY3Rpb24obil7cmV0dXJuXCJmZXRjaFwiPT09bi50eXBlfSkpLGk9ci5pbnB1dHMuWFswXSxzPWEobyxpKSxsPUIocy5zaGFwZSksYz1sWzBdLGg9bFsxXSxwPWxbMl0sZD1sWzNdLGc9e2F0dHJzOnt9LGlucHV0czp7WDpbaV19LG91dHB1dHM6e1k6W3FdfSx0eXBlOlwicGFja19vdXRcIn0sXz1oKmQsbT1NYXRoLmNlaWwoYypwLzQpLHY9e25hbWU6cSxzaGFwZTpbMSwxLG0sX10scGVyc2lzdGFibGU6ITF9O3IuaW5wdXRzLlg9W3FdLHIuYXR0cnMub3JpZ2luX3NoYXBlPVtjLGgscCxkXSx0LnB1c2goZyksdShvLFt2XSl9fSxlfShGKTt2YXIgSz1mdW5jdGlvbigpe3ZhciBuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKG49T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKG4sZSl7bi5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKG4sZSl7Zm9yKHZhciB0IGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkmJihuW3RdPWVbdF0pfSkoZSx0KX07cmV0dXJuIGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbygpe3RoaXMuY29uc3RydWN0b3I9ZX1uKGUsdCksZS5wcm90b3R5cGU9bnVsbD09PXQ/T2JqZWN0LmNyZWF0ZSh0KTooby5wcm90b3R5cGU9dC5wcm90b3R5cGUsbmV3IG8pfX0oKSxaPVwiaW1nX3ByZV9wcm9jZXNzZWRcIixKPVwiaW1nX29yaWdpblwiO2NvbnN0IFE9ZnVuY3Rpb24obil7ZnVuY3Rpb24gZSgpe3JldHVybiBuLmNhbGwodGhpcyxcIkZlZWRQcm9jZXNzXCIpfHx0aGlzfXJldHVybiBLKGUsbiksZS5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKW5bZV09YXJndW1lbnRzW2VdO3ZhciB0PW5bMF0sbz1uWzFdLHI9blsyXTtpZihyLndlYmdsRmVlZFByb2Nlc3N8fGYuZ2V0KFwid2ViZ2xfZ3B1X3BpcGVsaW5lXCIpKXt2YXIgaT1yLm1lYW4scz12b2lkIDA9PT1pP1swLDAsMF06aSxsPXIuc3RkLGM9dm9pZCAwPT09bD9bMSwxLDFdOmwsaD1yLnNjYWxlLHA9dm9pZCAwPT09aD9bMSwxXTpoLGQ9ci5wb3MsZz12b2lkIDA9PT1kP1swLDBdOmQsXz1yLmZlZWRTaGFwZSx2PWEobyxcImltYWdlXCIpLFA9di5zaGFwZSx4PVBbMl0sYj1QWzNdO3Yuc2hhcGU9WzEsMSx4LGJdO3ZhciBUPU9iamVjdC5hc3NpZ24oe30sdik7VC5uYW1lPVosVC5zaGFwZT1bMSwzLF8uZmgsXy5md10sVC5wZXJzaXN0YWJsZT0hMSxkZWxldGUgVC5kYXRhO3ZhciB5PU9iamVjdC5hc3NpZ24oe30sdik7eS5uYW1lPUoseS5zaGFwZT1bMSwxLF8uZmgsXy5md10seS5wZXJzaXN0YWJsZT0hMSxkZWxldGUgeS5kYXRhLHUobyxbeSxUXSk7dmFyIEY9dC5maW5kKChmdW5jdGlvbihuKXt2YXIgZT1uLmlucHV0cztyZXR1cm4gT2JqZWN0LmtleXMoZSkuZmluZCgoZnVuY3Rpb24obil7cmV0dXJuXCJpbWFnZVwiPT09ZVtuXVswXX0pKX0pKSx3PUYuaW5wdXRzO09iamVjdC5rZXlzKHcpLmZvckVhY2goKGZ1bmN0aW9uKG4pe1wiaW1hZ2VcIj09PXdbbl1bMF0mJih3W25dWzBdPVopfSkpO3ZhciBFPXthdHRyczp7bWVhbjpzLHN0ZDpjfSxpbnB1dHM6e1g6W0pdfSxvdXRwdXRzOntZOltaXX0sdHlwZTpcImZlZWRQb3N0XCJ9LEE9e2F0dHJzOnttZWFuOnMsc3RkOmMsc2NhbGU6cCxwb3M6Z30saW5wdXRzOntYOltcImltYWdlXCJdfSxvdXRwdXRzOntZOltKXX0sdHlwZTpcImltZ0ZlZWRcIix1bmlmb3JtOnt1X3NjYWxlOnt0eXBlOm0udW5pZm9ybTJmdix2YWx1ZTpbMSwxXX0sdV9wb3M6e3R5cGU6bS51bmlmb3JtMmZ2LHZhbHVlOlswLDBdfX0saXNQYWNrZWQ6ITB9O3Quc3BsaWNlKDEsMCxFKSx0LnNwbGljZSgxLDAsQSl9fSxlfShGKSwkPXtwcmVUcmFuc2Zvcm1zOltuZXcgRCxuZXcgWSxuZXcgUV0sdHJhbnNmb3JtczpbbmV3IFIsbmV3IFNdLHBvc3RUcmFuc2Zvcm1zOltdfTt2YXIgbm4sZW49ZnVuY3Rpb24oKXtmb3IodmFyIG49MCxlPTAsdD1hcmd1bWVudHMubGVuZ3RoO2U8dDtlKyspbis9YXJndW1lbnRzW2VdLmxlbmd0aDt2YXIgbz1BcnJheShuKSxyPTA7Zm9yKGU9MDtlPHQ7ZSsrKWZvcih2YXIgaT1hcmd1bWVudHNbZV0scz0wLGE9aS5sZW5ndGg7czxhO3MrKyxyKyspb1tyXT1pW3NdO3JldHVybiBvfTtmdW5jdGlvbiB0bihuLGUpe3JldHVybiBuJiZuW2VdfHxbXX0hZnVuY3Rpb24obil7bi5QcmVUcmFuc2Zvcm1zPVwicHJlVHJhbnNmb3Jtc1wiLG4uVHJhbnNmb3Jtcz1cInRyYW5zZm9ybXNcIixuLlBvc3RUcmFuc2Zvcm1zPVwicG9zdFRyYW5zZm9ybXNcIn0obm58fChubj17fSkpO2NvbnN0IG9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLGUpe3RoaXMud2VpZ2h0TWFwPVtdLHRoaXMub3BzPVtdLHRoaXMudmFycz1bXSx0aGlzLmNvbmZpZz17fSx0aGlzLnR5cGU9di5TaW5nbGVPdXRwdXQsdGhpcy5wbHVnaW5zPW51bGwsdGhpcy5vcHM9bi5vcHMsdGhpcy52YXJzPW4udmFycyx0aGlzLnR5cGU9ZS50eXBlfHx0aGlzLnR5cGUsdGhpcy5wbHVnaW5zPWUucGx1Z2lucyx0aGlzLmNvbmZpZz1lLG4uZmVlZFNoYXBlJiYodGhpcy5jb25maWcuZmVlZFNoYXBlPW4uZmVlZFNoYXBlKX1yZXR1cm4gbi5wcm90b3R5cGUuY3JlYXRlR3JhcGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmVUcmFuc2Zvcm1zKCksdGhpcy5jcmVhdGVPcHNNYXAoKSx0aGlzLmFycmFuZ2VNYXAoKSx0aGlzLnBvc3RUcmFuc2Zvcm1zKCksdGhpcy53ZWlnaHRNYXB9LG4ucHJvdG90eXBlLnByZVRyYW5zZm9ybXM9ZnVuY3Rpb24oKXt2YXIgbj10aGlzO2VuKCQucHJlVHJhbnNmb3Jtcyx0bih0aGlzLnBsdWdpbnMsbm4uUHJlVHJhbnNmb3JtcykpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UudHJhbnNmb3JtKG4ub3BzLG4udmFycyxuLmNvbmZpZyl9KSl9LG4ucHJvdG90eXBlLnRyYW5zZm9ybXM9ZnVuY3Rpb24obixlKXt2YXIgdD10aGlzO2VuKCQudHJhbnNmb3Jtcyx0bih0aGlzLnBsdWdpbnMsbm4uVHJhbnNmb3JtcykpLmZvckVhY2goKGZ1bmN0aW9uKG8pe28udHJhbnNmb3JtKG4sdC52YXJzLGUpfSkpfSxuLnByb3RvdHlwZS5wb3N0VHJhbnNmb3Jtcz1mdW5jdGlvbigpe3ZhciBuPXRoaXM7ZW4oJC5wb3N0VHJhbnNmb3Jtcyx0bih0aGlzLnBsdWdpbnMsbm4uUG9zdFRyYW5zZm9ybXMpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtlLnRyYW5zZm9ybShuLndlaWdodE1hcCxuLnZhcnMsbi50eXBlKX0pKX0sbi5wcm90b3R5cGUuY3JlYXRlT3BzTWFwPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPVtdLGU9MDtlPHRoaXMub3BzLmxlbmd0aDtlKyspe3ZhciB0PW4ubGVuZ3RoLG89dGhpcy5vcHNbZV0scj1uZXcgeShvLHQpO3RoaXMudHJhbnNmb3JtcyhyLG4pLG4ucHVzaChyKX10aGlzLndlaWdodE1hcD1ufSxuLnByb3RvdHlwZS5hcnJhbmdlTWFwPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPXt9LGU9W10sdD17fSxvPWZ1bmN0aW9uKG8pe2Zvcih2YXIgaT1yLndlaWdodE1hcFtvXSxzPTA7czxpLm91dHB1dHNOYW1lLmxlbmd0aDtzKyspe3ZhciBhPWkub3V0cHV0c05hbWVbc107blthXT0hMH1lW29dPTAsdFtpLmlkXT1vLGkuaW5wdXRzTmFtZS5sZW5ndGg+MT9pLmlucHV0c05hbWUuZm9yRWFjaCgoZnVuY3Rpb24odCl7ITA9PT1uW3RdJiZlW29dKyt9KSk6ZVtvXT1pLmlucHV0c05hbWUubGVuZ3RofSxyPXRoaXMsaT0wO2k8dGhpcy53ZWlnaHRNYXAubGVuZ3RoO2krKylvKGkpO3RoaXMudG9wb1NvcnQodGhpcy53ZWlnaHRNYXAsZSx0KX0sbi5wcm90b3R5cGUudG9wb1NvcnQ9ZnVuY3Rpb24obixlLHQpe3ZhciBvPVtdO28ucHVzaChuWzBdKTtmb3IodmFyIHI9bi5zbGljZSgwKSxpPW51bGwscz1uWzBdO28ubGVuZ3RoPjA7KXtudWxsIT1pJiYoblt0W2kuaWRdXS5uZXh0PXMuaWQpLGk9cyxzPW8ucG9wKCl8fHt9O2Zvcih2YXIgYT0wO2E8cy5vdXRwdXRzTmFtZS5sZW5ndGg7YSsrKWZvcih2YXIgdT0wO3U8ci5sZW5ndGg7dSsrKWZvcih2YXIgbD0wO2w8clt1XS5pbnB1dHNOYW1lLmxlbmd0aDtsKyspaWYoclt1XS5pbnB1dHNOYW1lW2xdPT09cy5vdXRwdXRzTmFtZVthXSYmKGVbdFtyW3VdLmlkXV0tLSwwPT09ZVt0W3JbdV0uaWRdXSkpe28ucHVzaChuW3Rbclt1XS5pZF1dKSxyLnNwbGljZSh1LDEpLHUtLTticmVha319fSxuLnByb3RvdHlwZS5nZXRGZWVkRXhlY3V0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53ZWlnaHRNYXAuZmluZCgoZnVuY3Rpb24obil7cmV0dXJuXCJmZWVkXCI9PT1uLnR5cGV9KSl9LG4ucHJvdG90eXBlLmdldEZldGNoRXhlY3V0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53ZWlnaHRNYXAuZmluZCgoZnVuY3Rpb24obil7cmV0dXJuXCJmZXRjaFwiPT09bi50eXBlfSkpfSxuLnByb3RvdHlwZS5nZXRFeGVjdXRvckJ5SWQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMud2VpZ2h0TWFwLmZpbmQoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkPT09bn0pKX0sbn0oKSxybj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obil7dGhpcy5vcHRzPXt9LHRoaXMuaXNQYWNrZWQ9ITEsdGhpcy5uYW1lPVwiXCIsdGhpcy50ZW5zb3JJZD1cIlwiLHRoaXMudG90YWw9MSx0aGlzLnNoYXBlPVtdLHRoaXMudW5mb3JtYXR0ZWRTaGFwZUxlbmd0aD0wLHRoaXMuc2hhcGVfdGV4dHVyZT1bXSx0aGlzLmV4Y2VlZE1heD0hMSx0aGlzLmRhdGE9bnVsbCx0aGlzLnBlcnNpc3RhYmxlPSExLHRoaXMuaW50ZXJwVHlwZT1cIk5FQVJFU1RcIix0aGlzLmRhdGFMYXlvdXQ9XCJcIix0aGlzLnJ1bnRpbWU9MCx0aGlzLmJpbmRpbmc9MDt2YXIgZT1uLmlzUGFja2VkLHQ9dm9pZCAwIT09ZSYmZSxvPW4ubmFtZSxyPW4ucnVudGltZSxpPXZvaWQgMD09PXI/MDpyLHM9bi5wZXJzaXN0YWJsZSxhPXZvaWQgMCE9PXMmJnMsdT1uLnR5cGUsbD1uLmRhdGFMYXlvdXQsYz1uLmludGVycFR5cGUsZj12b2lkIDA9PT1jP1wiTkVBUkVTVFwiOmMsaD1uLnNoYXBlLHA9bi5kYXRhLGQ9bi5iaW5kaW5nLGc9dm9pZCAwPT09ZD8wOmQ7dGhpcy5vcHRzPW4sdGhpcy5pc1BhY2tlZD10LHRoaXMubmFtZT1vLHRoaXMucnVudGltZT1pLHRoaXMuYmluZGluZz1nLHRoaXMucGVyc2lzdGFibGU9YSx0aGlzLmludGVycFR5cGU9Zix0aGlzLnRlbnNvcklkPXUsdGhpcy5kYXRhTGF5b3V0PWwsdGhpcy51bmZvcm1hdHRlZFNoYXBlTGVuZ3RoPWgubGVuZ3RoLHRoaXMuc2hhcGU9QihoKSx0aGlzLnRvdGFsPXRoaXMuc2hhcGUucmVkdWNlKChmdW5jdGlvbihuLGUpe3JldHVybiBuKmV9KSksbi5ub0xheW91dHx8cCYmcC5sZW5ndGgmJih0aGlzLmRhdGE9ZnVuY3Rpb24obixlLHQsbyl7aWYoXCJuaHdjXCI9PT1lKXt2YXIgcj10WzBdLGk9dFsxXSxzPVcobixbcix0WzJdLHRbM10saSoobz80OjEpXSk7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkocyl9cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobil9KHAsdGhpcy5kYXRhTGF5b3V0LHRoaXMuc2hhcGUsdGhpcy5pc1BhY2tlZCksbi5kYXRhPW51bGwpfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkobi5wcm90b3R5cGUsXCJ3aWR0aF90ZXh0dXJlXCIse2dldDpmdW5jdGlvbigpe3ZhciBuPXRoaXMuc2hhcGVfdGV4dHVyZS5sZW5ndGg7cmV0dXJuIHRoaXMuc2hhcGVfdGV4dHVyZVtuLTFdfHwxfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLnByb3RvdHlwZSxcImhlaWdodF90ZXh0dXJlXCIse2dldDpmdW5jdGlvbigpe3ZhciBuPXRoaXMuc2hhcGVfdGV4dHVyZS5sZW5ndGg7cmV0dXJuIHRoaXMuc2hhcGVfdGV4dHVyZVtuLTJdfHwxfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLnByb3RvdHlwZSxcIndpZHRoX3NoYXBlXCIse2dldDpmdW5jdGlvbigpe3ZhciBuPXRoaXMuc2hhcGUubGVuZ3RoO3JldHVybiB0aGlzLnNoYXBlW24tMV19LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLFwiaGVpZ2h0X3NoYXBlXCIse2dldDpmdW5jdGlvbigpe3ZhciBuPXRoaXMuc2hhcGUubGVuZ3RoO3JldHVybiB0aGlzLnNoYXBlW24tMl19LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLFwiY2hhbm5lbFwiLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgbj10aGlzLnNoYXBlLmxlbmd0aDtyZXR1cm4gdGhpcy5zaGFwZVtuLTNdfSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLnByb3RvdHlwZSxcImxlbmd0aF9zaGFwZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh8fDB9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLFwibGVuZ3RoX3VuZm9ybWF0dGVkX3NoYXBlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVuZm9ybWF0dGVkU2hhcGVMZW5ndGh8fDB9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLFwidG90YWxfc2hhcGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG90YWx9LGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLFwibnVtYmVyc19zaGFwZVwiLHtnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIG49W10sZT10aGlzLnNoYXBlLmxlbmd0aCx0PTA7dDxlLTE7dCsrKXt2YXIgbz10aGlzLnNoYXBlLnNsaWNlKHQrMSkucmVkdWNlKChmdW5jdGlvbihuLGUpe3JldHVybiBuKmV9KSk7bi5wdXNoKG8pfXJldHVybiBuLnB1c2goMSksbn0sZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9KSxufSgpLHNuPXthZGFwdFBhZGRpbmdzOmZ1bmN0aW9uKCl7Zm9yKHZhciBuIGluIHRoaXMucHJvY2Vzc2VkQXR0cnMpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvY2Vzc2VkQXR0cnMsbikmJlwicGFkZGluZ3NcIj09PW4pe3ZhciBlPXRoaXMucHJvY2Vzc2VkQXR0cnNbbl0sdD1lWzBdLG89ZVsxXTtyZXR1cm4gdm9pZCgwPT09dCYmMT09PW8mJih0aGlzLnByb2Nlc3NlZEF0dHJzW25dWzFdPTApKX19LHNldEFkYXB0aXZlOmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5hZGFwdGl2ZSYmMj09PXRoaXMucHJvY2Vzc2VkQXR0cnMua3NpemUubGVuZ3RoJiYxPT09dGhpcy5wcm9jZXNzZWRBdHRycy5rc2l6ZVswXSYmMT09PXRoaXMucHJvY2Vzc2VkQXR0cnMua3NpemVbMV0mJih0aGlzLnByb2Nlc3NlZEF0dHJzLmFkYXB0aXZlPSExLHRoaXMucHJvY2Vzc2VkQXR0cnMuZ2xvYmFsX3Bvb2xpbmc9ITApfSxpc0dsb2JhbFBvb2xpbmc6ZnVuY3Rpb24oKXt2YXIgbixlPXRoaXMudGVuc29yRGF0YU1hcC5vcmlnaW4sdD0obnVsbD09PShuPW51bGw9PWU/dm9pZCAwOmUuc2hhcGUpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLmxlbmd0aCl8fDA7dD4yJiZ0aGlzLnByb2Nlc3NlZEF0dHJzLmdsb2JhbF9wb29saW5nJiYodGhpcy5wcm9jZXNzZWRBdHRycy5rc2l6ZT1bZS5zaGFwZVt0LTJdLGUuc2hhcGVbdC0xXV0pfSxzZXRQYWNrZWQ6ZnVuY3Rpb24oKXt2YXIgbj10aGlzLnByb2Nlc3NlZEF0dHJzLmlzcGFja2VkO3RoaXMudGVuc29yRGF0YU1hcC5vcmlnaW4mJm4mJnRoaXMubmFtZS5pbmRleE9mKFwicG9vbFwiKT4tMSYmKHRoaXMubmFtZSs9XCJfd2lub2dyYWRcIil9LG1lcmdlQXR0cnM6ZnVuY3Rpb24oKXt0aGlzLnByb2Nlc3NlZEF0dHJzPXRoaXMuc3ViQXR0cnMucmVkdWNlKChmdW5jdGlvbihuLGUpe3JldHVybiBPYmplY3QuYXNzaWduKG4sZSl9KSx7fSl9LGlzQXBwbHlTZXBhcmFibGVDb252OmZ1bmN0aW9uKCl7aWYoIXRoaXMuaXNQYWNrZWRPcCl7dmFyIG49dGhpcy5wcm9jZXNzZWRBdHRycy5ncm91cHMsZT10aGlzLnRlbnNvckRhdGFNYXAuZmlsdGVyO2lmKFwiZGVwdGh3aXNlX2NvbnYyZFwiPT09dGhpcy5uYW1lJiYodGhpcy5uYW1lPVwiY29udjJkXCIpLGUpe3ZhciB0PWUuc2hhcGUsbz10WzBdLHI9dFsxXTtvPT09biYmMT09PXImJih0aGlzLm5hbWUrPVwiX2RlcHRod2lzZVwiKX19fSxiYXRjaENvbXB1dGVDb252MmQ6ZnVuY3Rpb24oKXt2YXIgbj10aGlzLnRlbnNvckRhdGFNYXAuZmlsdGVyLnNoYXBlWzFdO3RoaXMucHJvY2Vzc2VkQXR0cnMuZmlsdGVyX25lYXJlc3RfdmVjND00Kk1hdGguZmxvb3Iobi80KSx0aGlzLnByb2Nlc3NlZEF0dHJzLmZpbHRlcl9yZW1haW5kZXJfdmVjND1uJTR9LHByb2Nlc3NCaWFzOmZ1bmN0aW9uKCl7dmFyIG49dGhpcy50ZW5zb3JEYXRhTWFwLmJpYXM7aWYobiYmdGhpcy5pc1BhY2tlZE9wKXtuLnBhY2tlZD0hMDt2YXIgZT1uLnNoYXBlLHQ9W2VbZS5sZW5ndGgtMV0vNCwxLDFdO24uc2hhcGU9dH19LGlzTWF4OmZ1bmN0aW9uKCl7dmFyIG49XCJtYXhcIj09PXRoaXMucHJvY2Vzc2VkQXR0cnMucG9vbGluZ190eXBlPzE6MDt0aGlzLnByb2Nlc3NlZEF0dHJzLnBvb2xpbmdfdHlwZT1uLDE9PT1uJiYodGhpcy5uYW1lKz1cIl9tYXhcIil9LHRyYW5zVG9QcmVsdTpmdW5jdGlvbigpe3RoaXMucHJvY2Vzc2VkQXR0cnMubXVsdGlfdmFsdWU9XCIwLjBcIix0aGlzLnByb2Nlc3NlZEF0dHJzLmFjdGl2ZV9mdW5jdGlvbj1cInByZWx1XCJ9LHRyYW5zVG9SZWx1NjpmdW5jdGlvbigpe3RoaXMucHJvY2Vzc2VkQXR0cnMubXVsdGlfdmFsdWU9dGhpcy5wcm9jZXNzZWRBdHRycy50aHJlc2hvbGQsdGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJyZWx1NlwifSx0cmFuc1RvSGFyZFNpZ21vaWQ6ZnVuY3Rpb24oKXt0aGlzLnByb2Nlc3NlZEF0dHJzLm11bHRpX3ZhbHVlPXRoaXMucHJvY2Vzc2VkQXR0cnMuc2xvcGV8fC4yLHRoaXMucHJvY2Vzc2VkQXR0cnMuYmlhc192YWx1ZT10aGlzLnByb2Nlc3NlZEF0dHJzLm9mZnNldHx8LjUsdGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJoYXJkU2lnbW9pZFwifSx0cmFuc1RvTGVha3lyZWx1OmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5tdWx0aV92YWx1ZT10aGlzLnByb2Nlc3NlZEF0dHJzLmFscGhhLHRoaXMucHJvY2Vzc2VkQXR0cnMuYWN0aXZlX2Z1bmN0aW9uPVwibGVha3lSZWx1XCIsdGhpcy5uYW1lPVwicmVsdVwifSx0cmFuc1RvUG93OmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5tdWx0aV92YWx1ZT10aGlzLnByb2Nlc3NlZEF0dHJzLmZhY3Rvcnx8Mix0aGlzLnByb2Nlc3NlZEF0dHJzLmFjdGl2ZV9mdW5jdGlvbj1cInBvd19mdW5jXCIsdGhpcy5uYW1lPVwicG93XCJ9LHRyYW5zVG9TaWdtb2lkOmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJzaWdtb2lkXCJ9LHRyYW5zVG9TcXJ0OmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJzcXJ0XCJ9LHRyYW5zVG9UYW5oOmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJ0YW5oX2Z1bmNcIn0sdHJhbnNUb1NjYWxlOmZ1bmN0aW9uKCl7dmFyIG49dGhpcy5wcm9jZXNzZWRBdHRycy5zY2FsZTt0aGlzLnByb2Nlc3NlZEF0dHJzLm11bHRpX3ZhbHVlPXZvaWQgMCE9PW4/bjoxLHRoaXMucHJvY2Vzc2VkQXR0cnMuYmlhc192YWx1ZT10aGlzLnByb2Nlc3NlZEF0dHJzLmJpYXN8fDA7dmFyIGU9dGhpcy5wcm9jZXNzZWRBdHRycy5iaWFzX2FmdGVyX3NjYWxlO3RoaXMucHJvY2Vzc2VkQXR0cnMuYWN0aXZlX2Z1bmN0aW9uPWV8fHZvaWQgMD09PWU/XCJzY2FsZVwiOlwic2NhbGVXaWR0aEJpYXNcIn0sc2V0QWN0aXZlRnVuYzpmdW5jdGlvbigpe3ZhciBuPXRoaXMubmFtZS5yZXBsYWNlKFwiY29udjJkLWVsZW1lbnR3aXNlX2FkZC1cIixcIlwiKTt0aGlzLnByb2Nlc3NlZEF0dHJzPU9iamVjdC5hc3NpZ24oe2FjdGl2ZV9mdW5jdGlvbjpcInNjYWxlXCIsbXVsdGlfdmFsdWU6XCIxLjBcIixiaWFzX3ZhbHVlOlwiMC4wXCIsZnVzZV9yZWx1OiExfSx0aGlzLnByb2Nlc3NlZEF0dHJzKSxcImxlYWt5X3JlbHVcIj09PW4mJih0aGlzLnByb2Nlc3NlZEF0dHJzLm11bHRpX3ZhbHVlPXRoaXMucHJvY2Vzc2VkQXR0cnMuYWxwaGEsdGhpcy5wcm9jZXNzZWRBdHRycy5hY3RpdmVfZnVuY3Rpb249XCJsZWFreVJlbHVcIil9LG5vcm1hbGl6ZVBlcm06ZnVuY3Rpb24oKXt2YXIgbj10aGlzLnRlbnNvckRhdGFNYXAub3JpZ2luLnNoYXBlLmxlbmd0aCxlPXRoaXMucHJvY2Vzc2VkQXR0cnMuYXhpcyx0PWUubGVuZ3RoO2lmKHQtbj4wJiYodD0oZT1lLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuIG4tMX0pKS5maWx0ZXIoKGZ1bmN0aW9uKG4pe3JldHVybiBuPj0wfSkpKS5sZW5ndGgpLHQ+NCl0aHJvdyBFcnJvcihcIm9wIHRyYW5zcG9lczIgYXhpcyBsZW5ndGggZXhjZWVkcyBtYXhpbXVtIGxlbmd0aCA0LCBnZXQgXCIrdCk7Zm9yKHZhciBvPW5ldyBBcnJheSh0KS5maWxsKDApLHI9MDtyPHQ7cisrKW9bZVtyXV09cjt2YXIgaT1bXTtmb3Iocj0wO3I8NDtyKyspaVtyXT1vW3JdfHwwO3RoaXMucHJvY2Vzc2VkQXR0cnMucGVybV9hcnI9aSx0aGlzLnByb2Nlc3NlZEF0dHJzLnBlcm1fc2l6ZT10fSxub3JtYWxpemVEaW06ZnVuY3Rpb24oKXtmb3IodmFyIG49dGhpcy50ZW5zb3JEYXRhTWFwLm9yaWdpbi5zaGFwZSxlPUIobiksdD1HKG4sdGhpcy5wcm9jZXNzZWRBdHRycy5heGlzKSxvPVtdLHI9MDtyPGVbdF07cisrKW9bcl09cjt0aGlzLnByb2Nlc3NlZEF0dHJzLnRhcmdldF9sZW5ndGg9by5sZW5ndGgsdGhpcy5wcm9jZXNzZWRBdHRycy50YXJnZXRfdmFsdWU9byx0aGlzLnByb2Nlc3NlZEF0dHJzLmlucHV0c19kaW09ZVt0XSx0aGlzLnByb2Nlc3NlZEF0dHJzLmRpbT10LDA9PT10aGlzLnByb2Nlc3NlZEF0dHJzLm51bSYmKHRoaXMucHJvY2Vzc2VkQXR0cnMubnVtPU9iamVjdC52YWx1ZXModGhpcy50ZW5zb3JEYXRhTWFwKS5maWx0ZXIoKGZ1bmN0aW9uKG4pe3JldHVyblwib3V0XCI9PT1uLnRlbnNvck5hbWV9KSkubGVuZ3RofHwxKX0scHJvY2Vzc0VsZW1lbnR3aXNlQXhpczpmdW5jdGlvbigpe3ZhciBuPXRoaXMudGVuc29yRGF0YU1hcC5vcmlnaW4uc2hhcGUsZT10aGlzLnRlbnNvckRhdGFNYXAuY291bnRlci5zaGFwZSx0PXRoaXMucHJvY2Vzc2VkQXR0cnMuYXhpc3x8LTE7dGhpcy5wcm9jZXNzZWRBdHRycy5jb3VudGVyTGVuPWUubGVuZ3RoLFUobik9PT1VKGUpPyh0aGlzLnByb2Nlc3NlZEF0dHJzLmF4aXM9MCx0aGlzLnByb2Nlc3NlZEF0dHJzLmNvdW50ZXJMZW49NCk6KC0xPT09dCYmKHQ9bi5sZW5ndGgtZS5sZW5ndGgpLHRoaXMucHJvY2Vzc2VkQXR0cnMuYXhpcz1HKG4sdCkpfSxnZW5FbGVtZW50d2lzZUNvdW50ZXJQb3M6ZnVuY3Rpb24oKXtmb3IodmFyIG49dGhpcy5wcm9jZXNzZWRBdHRycyxlPW4uY291bnRlckxlbix0PVtcIjBcIixcIjBcIixcIjBcIixcIjBcIl0sbz1uLmF4aXMscj00LWU7cjw0O3IrKyl0W3JdPVwib1Bvc1tcIitvKysrXCJdXCI7dGhpcy5wcm9jZXNzZWRBdHRycy5jb3VudGVyUG9zPXQuam9pbihcIixcIil9LGZsYXR0ZW5TaGFwZTpmdW5jdGlvbigpe3ZhciBuPU9iamVjdC52YWx1ZXModGhpcy50ZW5zb3JEYXRhTWFwKS5maW5kKChmdW5jdGlvbihuKXtyZXR1cm4gbi5zaGFwZS5sZW5ndGg+Mn0pKTtpZihuKXt2YXIgZT1CKG4uc2hhcGUpO24uc2hhcGU9W2VbMF0qZVsyXSxlWzFdKmVbM11dfX0scmVzaGFwZTpmdW5jdGlvbigpe3ZhciBuPXRoaXMudGVuc29yRGF0YU1hcC5vcmlnaW4sZT10aGlzLnRlbnNvckRhdGFNYXAuY291bnRlcix0PXRoaXMudGVuc29yRGF0YU1hcC5vdXQ7aWYoZS5zaGFwZS5sZW5ndGg+bi5zaGFwZS5sZW5ndGgpe3ZhciBvPWU7ZT1uLG49b31pZihuLnNoYXBlLmxlbmd0aD4yJiYyPT09ZS5zaGFwZS5sZW5ndGgpe3ZhciByPWZ1bmN0aW9uKG4sZSl7dm9pZCAwPT09biYmKG49W10pLHZvaWQgMD09PWUmJihlPVtdKTt2YXIgdD1uLnJlZHVjZSgoZnVuY3Rpb24obixlKXtyZXR1cm4gbiplfSkpO3JldHVybiAxPT09ZS5sZW5ndGg/WzEsdF06W2VbMF0sdC9lWzBdXX0obi5zaGFwZSx0LnNoYXBlKTtuLnNoYXBlPXJ9fSxjaGVja0lzTWVyZ2U6ZnVuY3Rpb24oKXt2YXIgbj10aGlzLm5hbWUucmVwbGFjZShcImNvbnYyZC1lbGVtZW50d2lzZV9hZGQtXCIsXCJcIik7dGhpcy5uYW1lPVwiY29udjJkX2VsZW1lbnR3aXNlX2FkZFwiLFwibGVha3lfcmVsdVwiPT09biYmKHRoaXMucHJvY2Vzc2VkQXR0cnMuYWxwaGEmJih0aGlzLnByb2Nlc3NlZEF0dHJzLm11bHRpX3ZhbHVlPXRoaXMucHJvY2Vzc2VkQXR0cnMuYWxwaGEpLHRoaXMucHJvY2Vzc2VkQXR0cnMuYWN0aXZlX2Z1bmN0aW9uPVwibGVha3lSZWx1XCIpfX07dmFyIGFuPWZ1bmN0aW9uKCl7cmV0dXJuKGFuPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKG4pe2Zvcih2YXIgZSx0PTEsbz1hcmd1bWVudHMubGVuZ3RoO3Q8bzt0KyspZm9yKHZhciByIGluIGU9YXJndW1lbnRzW3RdKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYobltyXT1lW3JdKTtyZXR1cm4gbn0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07Y29uc3QgdW49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKG4sZSx0LG8scil7dGhpcy5uYW1lPVwiXCIsdGhpcy5pc1BhY2tlZE9wPSExLHRoaXMucHJvY2Vzc2VkQXR0cnM9e30sdGhpcy5zdWJBdHRycz1bXSx0aGlzLnVuaWZvcm09bnVsbCx0aGlzLmlucHV0VGVuc29ycz1bXSx0aGlzLm91dHB1dFRlbnNvcnM9W10sdGhpcy5kYXRhTGF5b3V0PVwiXCIsdGhpcy5pTGF5ZXI9MCx0aGlzLnByb2dyYW09W10sdGhpcy5pc0ZpbmFsT3A9ITEsdGhpcy5idWZmZXJUeXBlPWcuRnJhbWVCdWZmZXIsdGhpcy50ZW5zb3JEYXRhTWFwPXt9LHRoaXMudGVuc29yRGF0YT1bXTt2YXIgaT1uLnR5cGUscz1uLmlucHV0cyxhPW4ub3V0cHV0cyx1PW4uYXR0cnMsbD1uLmlzUGFja2VkLGM9bi5idWZmZXJUeXBlLGY9dm9pZCAwPT09Yz9nLkZyYW1lQnVmZmVyOmMsaD1uLnVuaWZvcm0scD12b2lkIDA9PT1oP251bGw6aDt0aGlzLm1vZGVsTmFtZT1yLHRoaXMuc3ViQXR0cnM9bi5zdWJBdHRycyx0aGlzLm5hbWU9aSx0aGlzLmlzUGFja2VkT3A9bCx0aGlzLmJ1ZmZlclR5cGU9Zix0aGlzLmRhdGFMYXlvdXQ9dC5kYXRhTGF5b3V0fHxcIlwiLHRoaXMuaUxheWVyPWUsdGhpcy5pc0ZpbmFsT3A9byx0aGlzLnVuaWZvcm09cCx0aGlzLmluaXRFeHRlbmRlZEF0dHJzKHUpLHRoaXMuY29uc3RydWN0VGVuc29yRGF0YShzLGEsdC52YXJzKSx0aGlzLmJ1aWxkVGVuc29yKCk7dmFyIGQ9dGhpcy5idWlsZFNoYWRlclBhcmFtcygpO3RoaXMuYnVpbGRQcm9ncmFtKGQpfXJldHVybiBuLnByb3RvdHlwZS5pbml0RXh0ZW5kZWRBdHRycz1mdW5jdGlvbihuKXtmb3IodmFyIGUgaW4gbilpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixlKSl7dmFyIHQ9bltlXTt0aGlzLnByb2Nlc3NlZEF0dHJzW2VdPXR9fSxuLnByb3RvdHlwZS5jb25zdHJ1Y3RUZW5zb3JEYXRhPWZ1bmN0aW9uKG4sZSx0KXt2YXIgbz10aGlzO09iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKG4pe2Vbbl0uZm9yRWFjaCgoZnVuY3Rpb24ocixpKXtlW25dW2ldPW8uZ2V0VGVuc29yVmFyKHIsdCl9KSl9KSksT2JqZWN0LmtleXMobikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7bltlXT1bby5nZXRUZW5zb3JWYXIobltlXVswXSx0KV19KSk7dmFyIHI9ZnVuY3Rpb24obil7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbikpdHJ5e3ZhciB0PWVbbl18fFt7fV0scj1pLmdldEV4YWN0VGVuc29yTmFtZShuLFwib3V0cHV0XCIpO3ImJnQuZm9yRWFjaCgoZnVuY3Rpb24obixlKXtuLnRlbnNvck5hbWU9cixvLnRlbnNvckRhdGFNYXBbcitcIl9cIitlXT1hbihhbih7fSxuKSx7dGVuc29yTmFtZTpyLHJ1bnRpbWU6ZX0pfSkpfWNhdGNoKG4pe2NvbnNvbGUuZXJyb3Iobil9fSxpPXRoaXM7Zm9yKHZhciBzIGluIGUpcihzKTtmb3IodmFyIHMgaW4gbilpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixzKSl7dmFyIGE9bltzXS5sZW5ndGg+MD9uW3NdOlt7fV0sdT10aGlzLmdldEV4YWN0VGVuc29yTmFtZShzLFwiaW5wdXRcIik7aWYodSl7dmFyIGw9YVswXTtsLnRlbnNvck5hbWU9dSx0aGlzLnRlbnNvckRhdGFNYXBbdV09YW4oYW4oe30sbCkse3RlbnNvck5hbWU6dX0pfX19LG4ucHJvdG90eXBlLmdldEV4YWN0VGVuc29yTmFtZT1mdW5jdGlvbihuLGUpe3JldHVyblwiaW5wdXRcIj09PWU/e2lucHV0Olwib3JpZ2luXCIseDpcIm9yaWdpblwiLHk6XCJjb3VudGVyXCIsdzpcIndlaWdodFwifVtuLnRvTG93ZXJDYXNlKCldfHxuLnRvTG93ZXJDYXNlKCk6e291dHB1dDpcIm91dFwiLHk6XCJvdXRcIixvdXQ6XCJvdXRcIixzY2FsZTpcInNjYWxlXCIsYmlhczpcImJpYXNcIixtZWFuOlwibWVhblwiLHZhcmlhbmNlOlwidmFyaWFuY2VcIixtYXNrOlwib3V0XCIsYm94ZXM6XCJvdXRcIix2YXJpYW5jZXM6XCJvdXRcIn1bbi50b0xvd2VyQ2FzZSgpXX0sbi5wcm90b3R5cGUuZ2V0VGVuc29yVmFyPWZ1bmN0aW9uKG4sZSl7dmFyIHQ9YShlLG4ucmVwbGFjZSgvX3BhY2tlZCQvLFwiXCIpKTtyZXR1cm4gdCYmbi5lbmRzV2l0aChcIl9wYWNrZWRcIik/ZnVuY3Rpb24obixlKXt2YXIgdD0zPT09bi5zaGFwZS5sZW5ndGg/TihbMV0sbi5zaGFwZSk6bi5zaGFwZSxvPXRbMF0scj10WzFdLGk9dFsyXSxzPXRbM10sYT1PYmplY3QuYXNzaWduKHt9LG4pO2lmKGEubmFtZT1lLGEucGFja2VkPSExLHIlND09MCl7dmFyIHU9ci80O2EucGFja2VkPSEwLGEuc2hhcGU9W28sdSxpLHNdfXJldHVybiBhfSh0LG4pOnR9LG4ucHJvdG90eXBlLmJ1aWxkUHJvZ3JhbT1mdW5jdGlvbihuKXt2YXIgZT10aGlzLHQ9dGhpcy5uYW1lLG89UC5iYWNrZW5kK1wiX1wiK3Qscj1QLm9wUmVnaXN0cnkub3BzW29dO3RyeXtpZighciYmXCJ3YXNtXCIhPT1mLmdldChcImJhY2tlbmRcIikpdGhyb3cgbmV3IEVycm9yKFwiW3VucmVnaXN0ZXJlZCBvcF0gXCIrdCk7dmFyIGk9dGhpcy5pbnB1dFRlbnNvcnM7dGhpcy5wcm9ncmFtPXRoaXMub3V0cHV0VGVuc29ycy5tYXAoKGZ1bmN0aW9uKHQsbyl7cmV0dXJuIFAuYmFja2VuZEluc3RhbmNlLmNyZWF0ZVByb2dyYW0oe29wOnIsb3V0VGVuc29yOnQsaW5wdXRUZW5zb3JzOmksc2hhZGVyUGFyYW1zOm5bb10scnVudGltZTpvLGlzRmluYWxPcDplLmlzRmluYWxPcH0pfSkpfWNhdGNoKG4pe2NvbnNvbGUuZXJyb3Iobil9fSxuLnByb3RvdHlwZS5wcm9jZXNzVGVuc29yRGF0YUFuZEF0dHJzPWZ1bmN0aW9uKCl7dmFyIG49dGhpczt0cnl7dGhpcy5uYW1lLmluZGV4T2YoXCJjb252MmQtZWxlbWVudHdpc2VfYWRkXCIpPi0xP3RoaXMubmFtZT1cImNvbnYyZF9lbGVtZW50d2lzZV9hZGRcIjp0aGlzLm5hbWUuaW5kZXhPZihcIm1heF9wb29sMmRfd2l0aF9pbmRleFwiKT4tMSYmKHRoaXMubmFtZT1cInBvb2wyZF9tYXhcIik7dmFyIGU9UC5iYWNrZW5kK1wiX1wiK3RoaXMubmFtZTsoUC5vcFJlZ2lzdHJ5Lm9wc1tlXSYmUC5vcFJlZ2lzdHJ5Lm9wc1tlXS5iZWhhdmlvcnN8fFtdKS5mb3JFYWNoKChmdW5jdGlvbihlKXt0cnl7c25bZV0uY2FsbChuKX1jYXRjaChuKXtjb25zb2xlLmVycm9yKG4pfX0pKX1jYXRjaChuKXtjb25zb2xlLmVycm9yKG4pfX0sbi5wcm90b3R5cGUuYnVpbGRUZW5zb3I9ZnVuY3Rpb24oKXt2YXIgbj10aGlzO3RoaXMucHJvY2Vzc1RlbnNvckRhdGFBbmRBdHRycygpO3ZhciBlPU9iamVjdC52YWx1ZXModGhpcy50ZW5zb3JEYXRhTWFwKTtlLmZvckVhY2goKGZ1bmN0aW9uKGUsdCl7dmFyIG8scj1lLnRlbnNvck5hbWUsaT1uZXcgcm4oe3R5cGU6bi5tb2RlbE5hbWUrXCJfXCIrZS5uYW1lLG5hbWU6cixzaGFwZTplLnNoYXBlLGRhdGE6ZS5kYXRhfHxudWxsLHBlcnNpc3RhYmxlOmUucGVyc2lzdGFibGV8fCExLGludGVycFR5cGU6ZS5pbnRlcnBUeXBlfHxcIk5FQVJFU1RcIixpc1BhY2tlZDpuLmlzUGFja2VkT3B8fGUucGFja2VkfHwhMSxiaW5kaW5nOnQsbm9MYXlvdXQ6bnVsbD09PShvPVAuYmFja2VuZEluc3RhbmNlKXx8dm9pZCAwPT09bz92b2lkIDA6by5ub0xheW91dCxkYXRhTGF5b3V0Om4uZGF0YUxheW91dCxydW50aW1lOmUucnVudGltZXx8MH0pO1wib3V0XCI9PT1yP24ub3V0cHV0VGVuc29ycy5wdXNoKGkpOm4uaW5wdXRUZW5zb3JzLnB1c2goaSksZS5zaGFwZT1pLnNoYXBlLGUudG90YWw9aS50b3RhbH0pKSx0aGlzLnRlbnNvckRhdGFNYXA9bnVsbCx0aGlzLnRlbnNvckRhdGE9ZX0sbi5wcm90b3R5cGUuYnVpbGRTaGFkZXJQYXJhbXM9ZnVuY3Rpb24oKXt2YXIgbj10aGlzLGU9W107cmV0dXJuIHRoaXMub3V0cHV0VGVuc29ycy5mb3JFYWNoKChmdW5jdGlvbigpe3ZhciB0PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobi5wcm9jZXNzZWRBdHRycykpO2UucHVzaCh0KX0pKSxlfSxufSgpO3ZhciBsbj1mdW5jdGlvbigpe3JldHVybihsbj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihuKXtmb3IodmFyIGUsdD0xLG89YXJndW1lbnRzLmxlbmd0aDt0PG87dCsrKWZvcih2YXIgciBpbiBlPWFyZ3VtZW50c1t0XSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKG5bcl09ZVtyXSk7cmV0dXJuIG59KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2NvbnN0IGNuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbigpe3RoaXMudGFyZ2V0Q29udGV4dD17fSx0aGlzLmdhcEZpbGxXaXRoPVwiI2ZmZlwiLHRoaXMubWVhbj1bMCwwLDBdLHRoaXMuc3RkPVsxLDEsMV0sdGhpcy5iZ3I9ITEsdGhpcy5waXhlbFdpZHRoPTEsdGhpcy5waXhlbEhlaWdodD0xLHRoaXMuaW5wdXRGZWVkPVtdLHRoaXMudGFyZ2V0Q2FudmFzPWYuZ2V0KFwiY2FudmFzMmRcIil8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksdGhpcy50YXJnZXRDb250ZXh0PXRoaXMudGFyZ2V0Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKX1yZXR1cm4gbi5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbihuLGUsdCl7dmFyIG89ZS5maWxsLHI9ZS5tZWFuLGk9ZS5zdGQscz1lLmJncixhPWUua2VlcFJhdGlvLHU9dm9pZCAwPT09YXx8YSxsPWUuc2NhbGUsYz12b2lkIDA9PT1sPzA6bCxmPXQuZmMsaD12b2lkIDA9PT1mPzM6ZixwPXQuZmgsZD10LmZ3LGc9bixfPXtnYXBGaWxsV2l0aDpvfHx0aGlzLmdhcEZpbGxXaXRoLG1lYW46cnx8dGhpcy5tZWFuLHN0ZDppfHx0aGlzLnN0ZCxiZ3I6c3x8dGhpcy5iZ3Isa2VlcFJhdGlvOnUsc2NhbGU6Yyx0YXJnZXRTaXplOnt3aWR0aDpkLGhlaWdodDpwfSx0YXJnZXRTaGFwZTpbMSxoLHAsZF19O3JldHVybiB0aGlzLmZyb21QaXhlbHMoZyxfKXx8W119LG4ucHJvdG90eXBlLmZyb21QaXhlbHM9ZnVuY3Rpb24obixlKXt2YXIgdD1bXSxvPXtnYXBGaWxsV2l0aDplLmdhcEZpbGxXaXRoLGR4OjAsZHk6MCxkV2lkdGg6ZS50YXJnZXRTaXplLndpZHRoLGRIZWlnaHQ6ZS50YXJnZXRTaXplLmhlaWdodH0scj1uLGk9bi5wYXRoJiZuLndpZHRoJiZuLmhlaWdodDtpZighaSYmIShuIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXB8fG4gaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50fHxuIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8biBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSlyZXR1cm5be2RhdGE6dCxzaGFwZTplLnNoYXBlfHxlLnRhcmdldFNoYXBlLG5hbWU6XCJpbWFnZVwiLHBlcnNpc3RhYmxlOiEwfV07dGhpcy5waXhlbFdpZHRoPW4ubmF0dXJhbFdpZHRofHxuLndpZHRoLHRoaXMucGl4ZWxIZWlnaHQ9bi5uYXR1cmFsSGVpZ2h0fHxuLmhlaWdodDt2YXIgcz1mLmdldChcIndlYmdsX2dwdV9waXBlbGluZVwiKXx8ZS53ZWJnbEZlZWRQcm9jZXNzO3JldHVybiB0aGlzLmZpdFRvVGFyZ2V0U2l6ZShpP3IucGF0aDpyLG8sbG4obG4oe30sZSkse2luR1BVOnN9KSksdD10aGlzLmdldEltYWdlRGF0YShvKSxzP1t7ZGF0YTp0PUZsb2F0MzJBcnJheS5mcm9tKHQuZGF0YSksc2hhcGU6WzEsMSxvLmRIZWlnaHQsby5kV2lkdGhdLG5hbWU6XCJpbWFnZVwiLHBlcnNpc3RhYmxlOiEwfV06W3tkYXRhOnQ9dGhpcy5hbGxSZXNoYXBlVG9SR0IodCxlKSxzaGFwZTplLnRhcmdldFNoYXBlfHxlLnNoYXBlLG5hbWU6XCJpbWFnZVwiLHBlcnNpc3RhYmxlOiEwfV19LG4ucHJvdG90eXBlLmFsbFJlc2hhcGVUb1JHQj1mdW5jdGlvbihuLGUpe2Zvcih2YXIgdD1lLm1lYW4sbz1lLnN0ZCxyPWUudGFyZ2V0U2hhcGUsaT1lLmJncixzPWUubm9ybWFsaXplVHlwZSxhPXZvaWQgMD09PXM/MDpzLHU9clsxXSxsPXJbMl0sYz1yWzNdLGY9bi5kYXRhfHxuLGg9bmV3IEZsb2F0MzJBcnJheShsKmMqdSkscD0wLGQ9MDtkPGw7KytkKWZvcih2YXIgZz1kKmMsXz0wO188YzsrK18pZm9yKHZhciBtPWcrXyx2PTA7djx1Oysrdil7dmFyIFA9aT80Km0rKDItdik6NCptK3Y7aFtwXT0wPT09YT9mW1BdLzI1NTooZltQXS0xMjgpLzEyOCxoW3BdLT10W3ZdLGhbcF0vPW9bdl0scCsrfXJldHVybiBXKGgsWzEsbCxjLHVdKX0sbi5wcm90b3R5cGUuZml0VG9UYXJnZXRTaXplPWZ1bmN0aW9uKG4sZSx0KXt2YXIgbz10fHx7fSxyPW8ua2VlcFJhdGlvLGk9dm9pZCAwPT09cnx8cixzPW8uaW5HUFUsYT12b2lkIDAhPT1zJiZzLHU9by5zY2FsZSxsPXZvaWQgMD09PXU/MDp1LGM9ZS5kV2lkdGgsZj1lLmRIZWlnaHQsaD1hP3RoaXMucGl4ZWxXaWR0aDpjLHA9YT90aGlzLnBpeGVsSGVpZ2h0OmYsZD1hP3RoaXMucGl4ZWxXaWR0aDpjLGc9YT90aGlzLnBpeGVsSGVpZ2h0OmYsXz0wLG09MDtpZihsKXtpZihkLWM8MHx8Zy1mPDApdGhyb3cgbmV3IEVycm9yKFwic2NhbGUgc2l6ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHNpemVcIik7dGhpcy5waXhlbFdpZHRoPnRoaXMucGl4ZWxIZWlnaHQ/KGc9bCxkPU1hdGgucm91bmQoZyp0aGlzLnBpeGVsV2lkdGgvdGhpcy5waXhlbEhlaWdodCkpOihkPWwsZz1NYXRoLnJvdW5kKGQqdGhpcy5waXhlbEhlaWdodC90aGlzLnBpeGVsV2lkdGgpKSx0aGlzLnRhcmdldENhbnZhcy53aWR0aD1oPWQsdGhpcy50YXJnZXRDYW52YXMuaGVpZ2h0PXA9ZyxlLmR4PShkLWMpLzIsZS5keT0oZy1mKS8yfWVsc2UgaSYmKGMvZip0aGlzLnBpeGVsSGVpZ2h0L3RoaXMucGl4ZWxXaWR0aD49MT9hPyhoPU1hdGgucm91bmQoZypjL2YpLF89TWF0aC5mbG9vcigoaC1kKS8yKSk6KGQ9TWF0aC5yb3VuZChnKnRoaXMucGl4ZWxXaWR0aC90aGlzLnBpeGVsSGVpZ2h0KSxfPU1hdGguZmxvb3IoKGMtZCkvMikpOmE/KHA9TWF0aC5yb3VuZChkKmYvYyksbT1NYXRoLmZsb29yKChwLWcpLzIpKTooZz1NYXRoLnJvdW5kKGQqdGhpcy5waXhlbEhlaWdodC90aGlzLnBpeGVsV2lkdGgpLG09TWF0aC5mbG9vcigoZi1nKS8yKSkpLHRoaXMudGFyZ2V0Q2FudmFzLndpZHRoPWUuZFdpZHRoPWgsdGhpcy50YXJnZXRDYW52YXMuaGVpZ2h0PWUuZEhlaWdodD1wO3RoaXMudGFyZ2V0Q29udGV4dC5maWxsU3R5bGU9ZS5nYXBGaWxsV2l0aCx0aGlzLnRhcmdldENvbnRleHQuZmlsbFJlY3QoMCwwLHRoaXMudGFyZ2V0Q2FudmFzLndpZHRoLHRoaXMudGFyZ2V0Q2FudmFzLmhlaWdodCksdGhpcy50YXJnZXRDb250ZXh0LmRyYXdJbWFnZShuLF8sbSxkLGcpfSxuLnByb3RvdHlwZS5nZXRJbWFnZURhdGE9ZnVuY3Rpb24obil7dmFyIGU9bi5keCx0PW4uZHksbz1uLmRXaWR0aCxyPW4uZEhlaWdodDtyZXR1cm4gdGhpcy50YXJnZXRDb250ZXh0LmdldEltYWdlRGF0YShlLHQsbyxyKX0sbi5wcm90b3R5cGUuY292ZXI9ZnVuY3Rpb24obixlLHQsbyl7dmFyIHI9dCxpPW87cmV0dXJuIHQvbyplL24+PTE/cj1NYXRoLnJvdW5kKGkqbi9lKTppPU1hdGgucm91bmQociplL24pLFtyL3QsaS9vXX0sbn0oKTt2YXIgZm49ZnVuY3Rpb24oKXtyZXR1cm4oZm49T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24obil7Zm9yKHZhciBlLHQ9MSxvPWFyZ3VtZW50cy5sZW5ndGg7dDxvO3QrKylmb3IodmFyIHIgaW4gZT1hcmd1bWVudHNbdF0pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJihuW3JdPWVbcl0pO3JldHVybiBufSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtmdW5jdGlvbiBobihuLGUsdCl7Zm9yKHZhciBvPVtdLHI9MCxpPW4ubGVuZ3RoO3I8aTtyKyspe3ZhciBzPW5bcl07cz5lJiZvLnB1c2goe3Njb3JlOnMsaTpyfSl9cmV0dXJuIG8uc29ydCgoZnVuY3Rpb24obixlKXtyZXR1cm4gZS5zY29yZS1uLnNjb3JlfSkpLnNsaWNlKDAsdCl9ZnVuY3Rpb24gcG4obil7dmFyIGU9blswXSx0PW5bMV0sbz1uWzJdLHI9blszXTtyZXR1cm4gbzxlfHxyPHQ/MDooby1lKSooci10KX1mdW5jdGlvbiBkbihuLGUpe2lmKGVbMF0+blsyXXx8ZVsyXTxuWzBdfHxlWzFdPm5bM118fGVbM108blsxXSlyZXR1cm4gMDt2YXIgdD1wbihuKSxvPXBuKGUpLHI9ZnVuY3Rpb24obixlKXt2YXIgdD1uWzBdLG89blsxXSxyPW5bMl0saT1uWzNdLHM9ZVswXSxhPWVbMV0sdT1lWzJdLGw9ZVszXSxjPU1hdGgubWF4KHQscyksZj1NYXRoLm1heChvLGEpO3JldHVybihNYXRoLm1pbihyLHUpLWMpKihNYXRoLm1pbihpLGwpLWYpfShuLGUpO3JldHVybiByLyh0K28tcil9Y29uc3QgZ249e211bHRpY2xhc3Nfbm1zOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9blswXSxvPXZvaWQgMD09PXQ/W106dCxyPW5bMV0saT12b2lkIDA9PT1yP1tdOnIscz1IKG8pLGE9SChpKTtpZighc3x8IWEpcmV0dXJuW107aWYocz1zWzBdLGE9YVswXSwhKHMmJnMubGVuZ3RoJiZhJiZhLmxlbmd0aCkpcmV0dXJuW107Zm9yKHZhciB1PWUubm1zX3RvcF9rLGw9dm9pZCAwPT09dT8xMDA6dSxjPWUubm1zX2V0YSxmPXZvaWQgMD09PWM/MTpjLGg9ZS5rZWVwX3RvcF9rLHA9dm9pZCAwPT09aD8xMDA6aCxkPWUuYmFja2dyb3VuZF9sYWJlbCxnPXZvaWQgMD09PWQ/MDpkLF89ZS5ubXNfdGhyZXNob2xkLG09dm9pZCAwPT09Xz8uMzpfLHY9ZS5zY29yZV90aHJlc2hvbGQsUD12b2lkIDA9PT12PzA6dix4PVtdLGI9MCxUPWEubGVuZ3RoO2I8VDtiKyspe3ZhciB5PVtdO2lmKGIhPT1nKXt2YXIgRj1obihhW2JdLFAsbCk7aWYoIUZ8fCFGLmxlbmd0aClyZXR1cm5bXTt2YXIgdz1GLnNoaWZ0KCksRT1zW3cuaV07Zm9yKHkucHVzaChmbihmbih7fSx3KSx7Ym94OkUsbGFiZWw6Yn0pKTtGLmxlbmd0aDspe3ZhciBBPUYuc2hpZnQoKTtFPXNbQS5pXTtmb3IodmFyIE89ITAsVj0wLEM9eTtWPEMubGVuZ3RoO1YrKylpZihkbihFLENbVl0uYm94KT5tKXtPPSExO2JyZWFrfU8mJnkucHVzaChmbihmbih7fSxBKSx7Ym94OkUsbGFiZWw6Yn0pKSxPJiZmPDEmJm0+LjUmJihtKj1mKX14PXguY29uY2F0KHkpfX12YXIgUz14LnNvcnQoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIGUuc2NvcmUtbi5zY29yZX0pKS5zbGljZSgwLHApLnNvcnQoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4ubGFiZWwtZS5sYWJlbH0pKS5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgbj0wLGU9MCx0PWFyZ3VtZW50cy5sZW5ndGg7ZTx0O2UrKyluKz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciBvPUFycmF5KG4pLHI9MDtmb3IoZT0wO2U8dDtlKyspZm9yKHZhciBpPWFyZ3VtZW50c1tlXSxzPTAsYT1pLmxlbmd0aDtzPGE7cysrLHIrKylvW3JdPWlbc107cmV0dXJuIG99KFtuLmxhYmVsLG4uc2NvcmVdLG4uYm94KX0pKTtyZXR1cm4gUyYmUy5sZW5ndGg/UzpbXX19O3ZhciBfbj1mdW5jdGlvbihuLGUsdCxvKXtyZXR1cm4gbmV3KHR8fCh0PVByb21pc2UpKSgoZnVuY3Rpb24ocixpKXtmdW5jdGlvbiBzKG4pe3RyeXt1KG8ubmV4dChuKSl9Y2F0Y2gobil7aShuKX19ZnVuY3Rpb24gYShuKXt0cnl7dShvLnRocm93KG4pKX1jYXRjaChuKXtpKG4pfX1mdW5jdGlvbiB1KG4pe3ZhciBlO24uZG9uZT9yKG4udmFsdWUpOihlPW4udmFsdWUsZSBpbnN0YW5jZW9mIHQ/ZTpuZXcgdCgoZnVuY3Rpb24obil7bihlKX0pKSkudGhlbihzLGEpfXUoKG89by5hcHBseShuLGV8fFtdKSkubmV4dCgpKX0pKX0sbW49ZnVuY3Rpb24obixlKXt2YXIgdCxvLHIsaSxzPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJnJbMF0pdGhyb3cgclsxXTtyZXR1cm4gclsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBpPXtuZXh0OmEoMCksdGhyb3c6YSgxKSxyZXR1cm46YSgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoaVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxpO2Z1bmN0aW9uIGEoaSl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihpKXtpZih0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7czspdHJ5e2lmKHQ9MSxvJiYocj0yJmlbMF0/by5yZXR1cm46aVswXT9vLnRocm93fHwoKHI9by5yZXR1cm4pJiZyLmNhbGwobyksMCk6by5uZXh0KSYmIShyPXIuY2FsbChvLGlbMV0pKS5kb25lKXJldHVybiByO3N3aXRjaChvPTAsciYmKGk9WzImaVswXSxyLnZhbHVlXSksaVswXSl7Y2FzZSAwOmNhc2UgMTpyPWk7YnJlYWs7Y2FzZSA0OnJldHVybiBzLmxhYmVsKysse3ZhbHVlOmlbMV0sZG9uZTohMX07Y2FzZSA1OnMubGFiZWwrKyxvPWlbMV0saT1bMF07Y29udGludWU7Y2FzZSA3Omk9cy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoISgocj0ocj1zLnRyeXMpLmxlbmd0aD4wJiZyW3IubGVuZ3RoLTFdKXx8NiE9PWlbMF0mJjIhPT1pWzBdKSl7cz0wO2NvbnRpbnVlfWlmKDM9PT1pWzBdJiYoIXJ8fGlbMV0+clswXSYmaVsxXTxyWzNdKSl7cy5sYWJlbD1pWzFdO2JyZWFrfWlmKDY9PT1pWzBdJiZzLmxhYmVsPHJbMV0pe3MubGFiZWw9clsxXSxyPWk7YnJlYWt9aWYociYmcy5sYWJlbDxyWzJdKXtzLmxhYmVsPXJbMl0scy5vcHMucHVzaChpKTticmVha31yWzJdJiZzLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWV9aT1lLmNhbGwobixzKX1jYXRjaChuKXtpPVs2LG5dLG89MH1maW5hbGx5e3Q9cj0wfWlmKDUmaVswXSl0aHJvdyBpWzFdO3JldHVybnt2YWx1ZTppWzBdP2lbMV06dm9pZCAwLGRvbmU6ITB9fShbaSxhXSl9fX07Y29uc3Qgdm49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKG4pe3RoaXMucnVubmVyQ29uZmlnPXt9LHRoaXMuaXNQYXVzZWQ9ITEsdGhpcy5tb2RlbD17fSx0aGlzLndlaWdodE1hcD1bXSx0aGlzLmlzRXhlY3V0ZWQ9ITEsdGhpcy50ZXN0PSExLHRoaXMuZ3JhcGhHZW5lcmF0b3I9e30sdGhpcy5tZWRpYVByb2Nlc3Nvcj1udWxsLHRoaXMubmVlZFByZWhlYXQ9ITAsdGhpcy5mZWVkU2hhcGU9e30sdGhpcy5ydW5uZXJDb25maWc9T2JqZWN0LmFzc2lnbih7fSxuKSx0aGlzLm5lZWRQcmVoZWF0PXZvaWQgMD09PW4ubmVlZFByZWhlYXR8fG4ubmVlZFByZWhlYXQsdGhpcy5tb2RlbE5hbWU9bi5tb2RlbE5hbWV8fERhdGUubm93KCkudG9TdHJpbmcoKSx0aGlzLndlaWdodE1hcD1bXSxmLnNldChcIm5zXCIsaSgpKSxcIm5vZGVcIiE9PWYuZ2V0KFwicGxhdGZvcm1cIikmJih0aGlzLm1lZGlhUHJvY2Vzc29yPW5ldyBjbil9cmV0dXJuIG4ucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXtyZXR1cm4gX24odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuO3JldHVybiBtbih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiBQLmJhY2tlbmRJbnN0YW5jZT8odGhpcy5pc0V4ZWN1dGVkPSExLFwid2FzbVwiIT09Zi5nZXQoXCJiYWNrZW5kXCIpP1szLDJdOls0LFByb21pc2UuYWxsKFt0aGlzLmxvYWQoKSxQLmJhY2tlbmRJbnN0YW5jZS5pbml0KCldKV0pOihjb25zb2xlLmVycm9yKFwiRVJST1I6IEhhdmVuJ3QgcmVnaXN0ZXIgYmFja2VuZFwiKSxbMl0pO2Nhc2UgMTpyZXR1cm4gZS5zZW50KCksWzMsNF07Y2FzZSAyOnJldHVybiBQLmJhY2tlbmRJbnN0YW5jZS5pbml0KCksdGhpcy5pc0V4ZWN1dGVkPSExLFs0LHRoaXMubG9hZCgpXTtjYXNlIDM6ZS5zZW50KCksZS5sYWJlbD00O2Nhc2UgNDpyZXR1cm4gdGhpcy5nZW5GZWVkRGF0YSgpLHRoaXMuZ2VuR3JhcGgoKSx0aGlzLmdlbk9wRGF0YSgpLFwid2FzbVwiIT09Zi5nZXQoXCJiYWNrZW5kXCIpP1szLDZdOih0aGlzLm1vZGVsPU9iamVjdC5hc3NpZ24odGhpcy5tb2RlbCx0aGlzLnJ1bm5lckNvbmZpZyksbj10aGlzLm1vZGVsLFs0LFAuYmFja2VuZEluc3RhbmNlLmluaXRXYXNtKHRoaXMubW9kZWwsdGhpcy53ZWlnaHRNYXApXSk7Y2FzZSA1OnJldHVybiBuLmluZGV4PWUuc2VudCgpLFsyLFtdXTtjYXNlIDY6cmV0dXJuIHRoaXMubmVlZFByZWhlYXQ/WzQsdGhpcy5wcmVoZWF0KCldOlszLDhdO2Nhc2UgNzpyZXR1cm5bMixlLnNlbnQoKV07Y2FzZSA4OnJldHVyblsyXX19KSl9KSl9LG4ucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gX24odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGUsdCxvLHIsaSxzLGE7cmV0dXJuIG1uKHRoaXMsKGZ1bmN0aW9uKHUpe3N3aXRjaCh1LmxhYmVsKXtjYXNlIDA6cmV0dXJuIG49dGhpcy5ydW5uZXJDb25maWcsZT1uLm1vZGVsUGF0aCx0PW4ubW9kZWxPYmosbz12b2lkIDA9PT10P251bGw6dCxlPyhyPW5ldyBkKGUpLGk9dGhpcyxbNCxyLmxvYWQoKV0pOlszLDJdO2Nhc2UgMTpyZXR1cm4gaS5tb2RlbD11LnNlbnQoKSxbMywzXTtjYXNlIDI6KG51bGw9PW8/dm9pZCAwOm8ubW9kZWwpJiYobnVsbD09bz92b2lkIDA6by5wYXJhbXMpJiYocz1vLm1vZGVsLGE9by5wYXJhbXMsZC5hbGxvY2F0ZVBhcmFtc1ZhcihzLnZhcnMsYSksdGhpcy5tb2RlbD1zKSx1LmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXX19KSl9KSl9LG4ucHJvdG90eXBlLmdlbkdyYXBoPWZ1bmN0aW9uKCl7dGhpcy5ncmFwaEdlbmVyYXRvcj1uZXcgb24odGhpcy5tb2RlbCx0aGlzLnJ1bm5lckNvbmZpZyksdGhpcy53ZWlnaHRNYXA9dGhpcy5ncmFwaEdlbmVyYXRvci5jcmVhdGVHcmFwaCgpfSxuLnByb3RvdHlwZS5nZW5PcERhdGE9ZnVuY3Rpb24oKXt2YXIgbj10aGlzLGU9MDt0aGlzLndlaWdodE1hcC5mb3JFYWNoKChmdW5jdGlvbih0LG8pe3ZhciByPXQudHlwZTtpZihcImZlZWRcIiE9PXImJlwiZmV0Y2hcIiE9PXIpe2UrKzt2YXIgaT1vPT09bi53ZWlnaHRNYXAubGVuZ3RoLTIscz1uZXcgdW4odCxlLG4ubW9kZWwsaSxuLm1vZGVsTmFtZSk7dC5vcERhdGE9c319KSksYyh0aGlzLm1vZGVsKX0sbi5wcm90b3R5cGUucHJlaGVhdD1mdW5jdGlvbigpe3JldHVybiBfbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG1uKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5jaGVja01vZGVsTG9hZGVkKCldO2Nhc2UgMTpyZXR1cm4gZS5zZW50KCksWzQsdGhpcy5leGVjdXRlKCldO2Nhc2UgMjpyZXR1cm4gbj1lLnNlbnQoKSx0aGlzLmlzRXhlY3V0ZWQ9ITAsWzIsbl19fSkpfSkpfSxuLnByb3RvdHlwZS5jaGVja01vZGVsTG9hZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIF9uKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gbW4odGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gMCE9PXRoaXMud2VpZ2h0TWFwLmxlbmd0aD9bMywyXTooY29uc29sZS5pbmZvKFwiSXQncyBiZXR0ZXIgdG8gcHJlaGVhdCB0aGUgbW9kZWwgYmVmb3JlIHJ1bm5pbmcuXCIpLFs0LHRoaXMubG9hZCgpXSk7Y2FzZSAxOm4uc2VudCgpLHRoaXMuZ2VuRmVlZERhdGEoKSx0aGlzLmdlbkdyYXBoKCksdGhpcy5nZW5PcERhdGEoKSx0aGlzLmlzRXhlY3V0ZWQ9ITEsbi5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMl19fSkpfSkpfSxuLnByb3RvdHlwZS5wcmVkaWN0PWZ1bmN0aW9uKG4sZSl7cmV0dXJuIF9uKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxvLHI7cmV0dXJuIG1uKHRoaXMsKGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuaXNQYXVzZWR8fCF0aGlzLm1lZGlhUHJvY2Vzc29yP1syXToodD1bXSx0PXRoaXMucnVubmVyQ29uZmlnLndlYmdsRmVlZFByb2Nlc3M/W25dOnRoaXMubWVkaWFQcm9jZXNzb3IucHJvY2VzcyhuLHRoaXMucnVubmVyQ29uZmlnLHRoaXMuZmVlZFNoYXBlKSxvPVtdLFwid2FzbVwiIT09Zi5nZXQoXCJiYWNrZW5kXCIpP1szLDNdOls0LFAuYmFja2VuZEluc3RhbmNlLnByZWRpY3QodFswXS5kYXRhLHRoaXMubW9kZWwuaW5kZXgpXSk7Y2FzZSAxOnJldHVybiBpLnNlbnQoKSxbNCx0aGlzLnJlYWQoKV07Y2FzZSAyOnJldHVybiByPWkuc2VudCgpLG89dGhpcy5wb3N0UHJvY2VzcyhyKSxbMyw1XTtjYXNlIDM6cmV0dXJuIHRoaXMudXBkYXRlRmVlZERhdGEodCksWzQsdGhpcy5leGVjdXRlKCldO2Nhc2UgNDpvPWkuc2VudCgpLGkubGFiZWw9NTtjYXNlIDU6cmV0dXJuIHRoaXMuaXNFeGVjdXRlZD0hMCxbMixlP2Uobyk6b119fSkpfSkpfSxuLnByb3RvdHlwZS5wcmVkaWN0V2l0aEZlZWQ9ZnVuY3Rpb24obixlLHQpe3ZhciBvO3JldHVybiBfbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHIsaSxzLGEsdSxsLGMsaCxwLGQsZyxfO3JldHVybiBtbih0aGlzLChmdW5jdGlvbihtKXtzd2l0Y2gobS5sYWJlbCl7Y2FzZSAwOnJldHVybiByPXRoaXMuZmVlZFNoYXBlLGk9ci5mYyxzPXZvaWQgMD09PWk/MzppLGE9ci5mdyx1PXIuZmgsQXJyYXkuaXNBcnJheShuKT8obnVsbD09PShvPW5bMF0pfHx2b2lkIDA9PT1vP3ZvaWQgMDpvLmRhdGEpPygoZD1uWzBdLmRhdGEpaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fChuWzBdLmRhdGE9bmV3IEZsb2F0MzJBcnJheShkKSksbD1uKTpsPVt7ZGF0YTpuZXcgRmxvYXQzMkFycmF5KG4pLHNoYXBlOnR8fFsxLHMsdSxhXSxuYW1lOlwiaW1hZ2VcIixwZXJzaXN0YWJsZTohMH1dOihoPShjPW4pLndpZHRoLHA9Yy5oZWlnaHQsZD1jLmRhdGEsbD1be2RhdGE6bmV3IEZsb2F0MzJBcnJheShkKSxzaGFwZTp0fHxbMSxzLHB8fHUsaHx8YV0sbmFtZTpcImltYWdlXCIscGVyc2lzdGFibGU6ITB9XSksZz1bXSxcIndhc21cIiE9PWYuZ2V0KFwiYmFja2VuZFwiKT9bMywzXTpbNCxQLmJhY2tlbmRJbnN0YW5jZS5wcmVkaWN0KGxbMF0uZGF0YSx0aGlzLm1vZGVsLmluZGV4KV07Y2FzZSAxOnJldHVybiBtLnNlbnQoKSxbNCx0aGlzLnJlYWQoKV07Y2FzZSAyOnJldHVybiBfPW0uc2VudCgpLGc9dGhpcy5wb3N0UHJvY2VzcyhfKSxbMyw1XTtjYXNlIDM6cmV0dXJuIHRoaXMudXBkYXRlRmVlZERhdGEobCksWzQsdGhpcy5leGVjdXRlKCldO2Nhc2UgNDpnPW0uc2VudCgpLG0ubGFiZWw9NTtjYXNlIDU6cmV0dXJuIHRoaXMuaXNFeGVjdXRlZD0hMCxbMixlP2UoZyk6Z119fSkpfSkpfSxuLnByb3RvdHlwZS5nZW5GZWVkRGF0YT1mdW5jdGlvbigpe3ZhciBuLGU9dGhpcy5ydW5uZXJDb25maWcsdD1lLnR5cGUsbz1lLmZlZWRTaGFwZSxyPWUud2ViZ2xGZWVkUHJvY2Vzczt0aGlzLmZlZWRTaGFwZT10aGlzLm1vZGVsLmZlZWRTaGFwZXx8bzt2YXIgaSxzPXRoaXMuZmVlZFNoYXBlLGw9cy5mYyxjPXZvaWQgMD09PWw/MzpsLGg9cy5maCxwPXMuZncsZD10aGlzLm1vZGVsLnZhcnM7aWYodD09PXYuTXVsdGlwbGVJbnB1dCl7dmFyIGc9dGhpcy5tb2RlbC5vcHMmJnRoaXMubW9kZWwub3BzWzBdJiYobnVsbD09PShuPXRoaXMubW9kZWwub3BzWzBdLmlucHV0cyl8fHZvaWQgMD09PW4/dm9pZCAwOm4uWCk7Zy5sZW5ndGg+MSYmKGk9Zy5tYXAoKGZ1bmN0aW9uKG4pe3ZhciBlPWEoZCxuKSx0PWUuc2hhcGUucmV2ZXJzZSgpLG89dFswXSxyPXRbMV0saT10WzJdLHM9dFszXSx1PXZvaWQgMD09PXM/MTpzO3JldHVybiBlLmRhdGE9bmV3IEZsb2F0MzJBcnJheSh1KmkqcipvKSxlfSkpKX1lbHNle3ZhciBfPVwid2FzbVwiIT09Zi5nZXQoXCJiYWNrZW5kXCIpJiZyPzQ6YztpPWEoZCxcImltYWdlXCIpO3ZhciBtPXtuYW1lOlwiaW1hZ2VcIixzaGFwZTpbMSxfLGgscF19O2k9T2JqZWN0LmFzc2lnbihtLGkse2RhdGE6bmV3IEZsb2F0MzJBcnJheShfKmgqcCkuZmlsbCgxKSxwZXJzaXN0YWJsZTohMH0pfXUoZCxpKX0sbi5wcm90b3R5cGUudXBkYXRlRmVlZERhdGE9ZnVuY3Rpb24obil7dmFyIGU9blswXSx0PXRoaXMud2VpZ2h0TWFwLmZpbmQoKGZ1bmN0aW9uKG4pe3JldHVybiBuLm9wRGF0YT9uLm9wRGF0YS5pbnB1dFRlbnNvcnMuZmluZCgoZnVuY3Rpb24obil7cmV0dXJuIG4udGVuc29ySWQuZW5kc1dpdGgoXCJfaW1hZ2VcIil9KSk6bnVsbH0pKSxvPXQub3BEYXRhLmlucHV0VGVuc29ycy5maW5kKChmdW5jdGlvbihuKXtyZXR1cm4gbi50ZW5zb3JJZC5lbmRzV2l0aChcIl9pbWFnZVwiKX0pKTtpZihvLmRhdGE9ZS5kYXRhLHRoaXMucnVubmVyQ29uZmlnLndlYmdsRmVlZFByb2Nlc3N8fGYuZ2V0KFwid2ViZ2xfZ3B1X3BpcGVsaW5lXCIpKXt2YXIgcj1lLnNoYXBlfHxbMSwxLGUuaGVpZ2h0LGUud2lkdGhdLGk9bmV3IFVpbnQ4QXJyYXkoZS5kYXRhfHxbXSk7aWYoZS53aWR0aCYmZS5oZWlnaHQmJiFlLmRhdGEpe3ZhciBzPWUubmF0dXJhbFdpZHRofHxlLndpZHRoO3I9WzEsMSxlLm5hdHVyYWxIZWlnaHR8fGUuaGVpZ2h0LHNdLGk9ZX12YXIgYT1vLm9wdHM7YS5zaGFwZT1yO3ZhciB1PXQub3BEYXRhLGw9bmV3IHJuKGEpO2wuZGF0YT1pLHUuaW5wdXRUZW5zb3JzPVtsXTt2YXIgYz1yLnNsaWNlKC0yKSxoPWNbMF0scD1jWzFdLGQ9dS5vdXRwdXRUZW5zb3JzWzBdLnNoYXBlLnNsaWNlKC0yKSxnPWRbMF0sXz1kWzFdLG09dGhpcy5tZWRpYVByb2Nlc3Nvci5jb3ZlcihwLGgsXyxnKTt0LnVuaWZvcm0udV9zY2FsZS52YWx1ZT1tfX0sbi5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3JldHVybiBfbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sZTtyZXR1cm4gbW4odGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj10aGlzLmdyYXBoR2VuZXJhdG9yLmdldEZlZWRFeGVjdXRvcigpLHRoaXMuZXhlY3V0ZU9wKG4pLFs0LHRoaXMucmVhZCgpXTtjYXNlIDE6cmV0dXJuIGU9dC5zZW50KCksWzIsdGhpcy5wb3N0UHJvY2VzcyhlKV19fSkpfSkpfSxuLnByb3RvdHlwZS5wb3N0UHJvY2Vzcz1mdW5jdGlvbihuKXt2YXIgZT1cIndhc21cIj09PWYuZ2V0KFwiYmFja2VuZFwiKTtpZihmLmdldChcImRlYnVnXCIpKXJldHVybiBuO3ZhciB0PW4sbz10aGlzLm1vZGVsLHI9by5tdWx0aU91dHB1dHMsaT1vLnBvc3RPcHM7aWYocilpZihlKXQ9ci5tYXAoKGZ1bmN0aW9uKGUsdCl7dmFyIG87cmV0dXJuKG89e30pW2UubmFtZV09blt0XSxvfSkpO2Vsc2V7dmFyIHM9MDt0PXIubWFwKChmdW5jdGlvbihlKXt2YXIgdCxvPWUuc2hhcGUucmVkdWNlKChmdW5jdGlvbihuLGUpe3JldHVybiBuKmV9KSkscj1uLnNsaWNlKHMsbytzKTtyZXR1cm4gcys9bywodD17fSlbZS5uYW1lXT1yLHR9KSl9aWYociYmaSYmaS5sZW5ndGgpZm9yKHZhciBhPWZ1bmN0aW9uKG4sZSl7dmFyIG89aVtuXSxyPW8udHlwZSxzPW8uYXR0cnMsYT1vLmlucHV0cyx1PWduW3JdO2lmKCF1KXJldHVybnt2YWx1ZTp2b2lkIDB9O3ZhciBsPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPTAsZT0wLHQ9YXJndW1lbnRzLmxlbmd0aDtlPHQ7ZSsrKW4rPWFyZ3VtZW50c1tlXS5sZW5ndGg7dmFyIG89QXJyYXkobikscj0wO2ZvcihlPTA7ZTx0O2UrKylmb3IodmFyIGk9YXJndW1lbnRzW2VdLHM9MCxhPWkubGVuZ3RoO3M8YTtzKysscisrKW9bcl09aVtzXTtyZXR1cm4gb30odCksYz1PYmplY3Qua2V5cyhhKS5tYXAoKGZ1bmN0aW9uKG4pe3ZhciBlPWFbbl0sdD1lLm5hbWUsbz1lLnNoYXBlLHI9bC5maWx0ZXIoKGZ1bmN0aW9uKG4pe3JldHVybiBuW3RdfSkpO3JldHVybiByJiZyWzBdJiZyWzBdW3RdP3tuYW1lOm4sdGVuc29ySWQ6dCxkYXRhOnJbMF1bdF0sc2hhcGU6b306KGNvbnNvbGUuZXJyb3IoXCLmnKrojrflj5bliLBcIit0K1wi55qE5pWw5o2uXCIpLG51bGwpfSkpO3Q9dShjLHMpfSx1PTAsbD1pLmxlbmd0aDt1PGw7dSsrKXt2YXIgYz1hKHUpO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjKXJldHVybiBjLnZhbHVlfXJldHVybiB0fSxuLnByb3RvdHlwZS5leGVjdXRlT3A9ZnVuY3Rpb24obil7dmFyIGU7aWYoXCJmZXRjaFwiIT09bi50eXBlKWlmKFwiZmVlZFwiIT09bi50eXBlJiZuLmV4ZWN1dGUodGhpcy5pc0V4ZWN1dGVkKSxmLmdldChcImRlYnVnXCIpJiYobnVsbD09PShlPW4ub3BEYXRhKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5vdXRwdXRUZW5zb3JzKSYmbi5vcERhdGEub3V0cHV0VGVuc29yc1tuLm9wRGF0YS5vdXRwdXRUZW5zb3JzLmxlbmd0aC0xXSYmbi5vcERhdGEub3V0cHV0VGVuc29yc1tuLm9wRGF0YS5vdXRwdXRUZW5zb3JzLmxlbmd0aC0xXS50ZW5zb3JJZD09PXRoaXMubW9kZWxOYW1lK1wiX1wiKyhmLmdldChcIm5zXCIpLmxheWVyTmFtZXx8Zi5nZXQoXCJsYXllck5hbWVcIikpKWNvbnNvbGUuaW5mbyhuLm9wRGF0YS5uYW1lK1wiX1wiK24ub3BEYXRhLmlMYXllcixcInJ1bm5lciBvcFwiKTtlbHNlIGlmKG4ubmV4dCl7dmFyIHQ9bi5uZXh0LG89dGhpcy5ncmFwaEdlbmVyYXRvci5nZXRFeGVjdXRvckJ5SWQodCk7dGhpcy5leGVjdXRlT3Aobyl9fSxuLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKCl7cmV0dXJuIF9uKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixlLHQ7cmV0dXJuIG1uKHRoaXMsKGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG49dGhpcy5ncmFwaEdlbmVyYXRvci5nZXRGZXRjaEV4ZWN1dG9yKCksZT1hKHRoaXMubW9kZWwudmFycyxuLmlucHV0cy5YWzBdKSx0PXtuYW1lOmUubmFtZSxzaGFwZTpuLmF0dHJzLm9yaWdpbl9zaGFwZXx8ZS5zaGFwZSxpbmRleDp0aGlzLm1vZGVsLmluZGV4fSxbNCxQLmJhY2tlbmRJbnN0YW5jZS5yZWFkKHQpXTtjYXNlIDE6cmV0dXJuWzIsby5zZW50KCldfX0pKX0pKX0sbi5wcm90b3R5cGUuc3RvcFByZWRpY3Q9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPSEwfSxufSgpLFBuPWZ1bmN0aW9uKCl7fX0sOTkzOigpPT57fX0sZT17fTtmdW5jdGlvbiB0KG8pe2lmKGVbb10pcmV0dXJuIGVbb10uZXhwb3J0czt2YXIgcj1lW29dPXtleHBvcnRzOnt9fTtyZXR1cm4gbltvXShyLHIuZXhwb3J0cyx0KSxyLmV4cG9ydHN9cmV0dXJuIHQuZD0obixlKT0+e2Zvcih2YXIgbyBpbiBlKXQubyhlLG8pJiYhdC5vKG4sbykmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLG8se2VudW1lcmFibGU6ITAsZ2V0OmVbb119KX0sdC5nPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMpcmV0dXJuIGdsb2JhbFRoaXM7dHJ5e3JldHVybiB0aGlzfHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKG4pe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cpcmV0dXJuIHdpbmRvd319KCksdC5vPShuLGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixlKSx0LnI9bj0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHQoOTk0KX0pKCl9LGZ1bmN0aW9uKG4sZSx0KXtuLmV4cG9ydHM9dCgyKX0sZnVuY3Rpb24obixlLHQpe1widXNlIHN0cmljdFwiO3QucihlKSx0LmQoZSxcIkZhY2VEZXRlY3RvclwiLChmdW5jdGlvbigpe3JldHVybiB1fSkpLHQuZChlLFwiY3JlYXRlSW1hZ2VcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbH0pKTt2YXIgbz10KDApLHI9KHQoMyksZnVuY3Rpb24obixlLHQsbyl7cmV0dXJuIG5ldyh0fHwodD1Qcm9taXNlKSkoKGZ1bmN0aW9uKHIsaSl7ZnVuY3Rpb24gcyhuKXt0cnl7dShvLm5leHQobikpfWNhdGNoKG4pe2kobil9fWZ1bmN0aW9uIGEobil7dHJ5e3Uoby50aHJvdyhuKSl9Y2F0Y2gobil7aShuKX19ZnVuY3Rpb24gdShuKXt2YXIgZTtuLmRvbmU/cihuLnZhbHVlKTooZT1uLnZhbHVlLGUgaW5zdGFuY2VvZiB0P2U6bmV3IHQoKGZ1bmN0aW9uKG4pe24oZSl9KSkpLnRoZW4ocyxhKX11KChvPW8uYXBwbHkobixlfHxbXSkpLm5leHQoKSl9KSl9KSxpPWZ1bmN0aW9uKG4sZSl7dmFyIHQsbyxyLGkscz17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZyWzBdKXRocm93IHJbMV07cmV0dXJuIHJbMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gaT17bmV4dDphKDApLHRocm93OmEoMSkscmV0dXJuOmEoMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKGlbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksaTtmdW5jdGlvbiBhKGkpe3JldHVybiBmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oaSl7aWYodCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO3M7KXRyeXtpZih0PTEsbyYmKHI9MiZpWzBdP28ucmV0dXJuOmlbMF0/by50aHJvd3x8KChyPW8ucmV0dXJuKSYmci5jYWxsKG8pLDApOm8ubmV4dCkmJiEocj1yLmNhbGwobyxpWzFdKSkuZG9uZSlyZXR1cm4gcjtzd2l0Y2gobz0wLHImJihpPVsyJmlbMF0sci52YWx1ZV0pLGlbMF0pe2Nhc2UgMDpjYXNlIDE6cj1pO2JyZWFrO2Nhc2UgNDpyZXR1cm4gcy5sYWJlbCsrLHt2YWx1ZTppWzFdLGRvbmU6ITF9O2Nhc2UgNTpzLmxhYmVsKyssbz1pWzFdLGk9WzBdO2NvbnRpbnVlO2Nhc2UgNzppPXMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEocj1zLnRyeXMsKHI9ci5sZW5ndGg+MCYmcltyLmxlbmd0aC0xXSl8fDYhPT1pWzBdJiYyIT09aVswXSkpe3M9MDtjb250aW51ZX1pZigzPT09aVswXSYmKCFyfHxpWzFdPnJbMF0mJmlbMV08clszXSkpe3MubGFiZWw9aVsxXTticmVha31pZig2PT09aVswXSYmcy5sYWJlbDxyWzFdKXtzLmxhYmVsPXJbMV0scj1pO2JyZWFrfWlmKHImJnMubGFiZWw8clsyXSl7cy5sYWJlbD1yWzJdLHMub3BzLnB1c2goaSk7YnJlYWt9clsyXSYmcy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlfWk9ZS5jYWxsKG4scyl9Y2F0Y2gobil7aT1bNixuXSxvPTB9ZmluYWxseXt0PXI9MH1pZig1JmlbMF0pdGhyb3cgaVsxXTtyZXR1cm57dmFsdWU6aVswXT9pWzFdOnZvaWQgMCxkb25lOiEwfX0oW2ksYV0pfX19LHM9e2Z3OjEwMjQsZmg6MTAyNH0sYT17bW9kZWxQYXRoOlwiaHR0cHM6Ly9wYWRkbGVqcy5jZG4uYmNlYm9zLmNvbS9tb2RlbHMvZnVzZS9mYWNlZGV0ZWN0X29wdC9tb2RlbC5qc29uXCIsbWVhbjpbLjQwNzg0MzEzNywuNDU4ODIzNTI5LC40ODIzNTI5NDFdLHN0ZDpbLjUsLjUsLjVdfSx1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuKXt0aGlzLm1vZGVsQ29uZmlnPWEsdGhpcy5mZWVkU2hhcGU9cyx0aGlzLnJ1bm5lcj1udWxsLHRoaXMuaW5wdXRTaXplPXt9LHRoaXMubW9kZWxDb25maWc9T2JqZWN0LmFzc2lnbih0aGlzLm1vZGVsQ29uZmlnLG4pLHRoaXMuZmVlZFNoYXBlPU9iamVjdC5hc3NpZ24odGhpcy5mZWVkU2hhcGUsbnVsbD09bj92b2lkIDA6bi5mZWVkU2hhcGUpfXJldHVybiBuLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiBpKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMucnVubmVyPW5ldyBvLlJ1bm5lcih0aGlzLm1vZGVsQ29uZmlnKSxbNCx0aGlzLnJ1bm5lci5pbml0KCldO2Nhc2UgMTpyZXR1cm4gbi5zZW50KCksWzJdfX0pKX0pKX0sbi5wcm90b3R5cGUuZGV0ZWN0PWZ1bmN0aW9uKG4sZSl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LG8scixzLGEsdSxsO3JldHVybiBpKHRoaXMsKGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuaW5wdXRTaXplLm5hdHVyYWxXaWR0aD1uLm5hdHVyYWxXaWR0aCx0aGlzLmlucHV0U2l6ZS5uYXR1cmFsSGVpZ2h0PW4ubmF0dXJhbEhlaWdodCx0PU9iamVjdC5hc3NpZ24oe30sZSksbz10LnNocmluayxyPXZvaWQgMD09PW8/LjQ6byxzPXQudGhyZXNob2xkLGE9dm9pZCAwPT09cz8uNjpzLHU9dGhpcy5wcmVwcm9jZXNzKG4sciksWzQsdGhpcy5ydW5uZXIucHJlZGljdFdpdGhGZWVkKHUpXTtjYXNlIDE6cmV0dXJuIGw9aS5zZW50KCksWzIsdGhpcy5wb3N0cHJvY2Vzc29yKGwsYSldfX0pKX0pKX0sbi5wcm90b3R5cGUucHJlcHJvY2Vzcz1mdW5jdGlvbihuLGUpe3ZhciB0PXRoaXMuc2NhbGU9TWF0aC5taW4odGhpcy5pbnB1dFNpemUubmF0dXJhbFdpZHRoLHRoaXMuaW5wdXRTaXplLm5hdHVyYWxIZWlnaHQpKmU7cmV0dXJuIHRoaXMucnVubmVyLm1lZGlhUHJvY2Vzc29yLnByb2Nlc3MobixPYmplY3QuYXNzaWduKHt9LHRoaXMubW9kZWxDb25maWcse3NjYWxlOnR9KSx0aGlzLmZlZWRTaGFwZSl9LG4ucHJvdG90eXBlLnBvc3Rwcm9jZXNzb3I9ZnVuY3Rpb24obixlKXt2YXIgdD10aGlzO3JldHVybiBuLmZpbHRlcigoZnVuY3Rpb24obil7cmV0dXJuIG5bMV0mJm5bMV0+ZX0pKS5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybiB0LnRyYW5zZm9ybURhdGEobil9KSl9LG4ucHJvdG90eXBlLnRyYW5zZm9ybURhdGE9ZnVuY3Rpb24obil7dmFyIGUsdCxvPXt9LHI9dGhpcy5mZWVkU2hhcGUsaT1yLmZ3LHM9ci5maCxhPXRoaXMuaW5wdXRTaXplLHU9YS5uYXR1cmFsV2lkdGgsbD1hLm5hdHVyYWxIZWlnaHQ7dT5sP2U9KHQ9dGhpcy5zY2FsZSkqdS9sOnQ9KGU9dGhpcy5zY2FsZSkqbC91O3ZhciBjPShpLWUpLzIsZj0ocy10KS8yO3JldHVybiBvLmNvbmZpZGVuY2U9blsxXSxvLmxlZnQ9KG5bMl0qaS1jKS9lLG8ud2lkdGg9KG5bNF0tblsyXSkqaS9lLG8udG9wPShuWzNdKnMtZikvdCxvLmhlaWdodD0obls1XS1uWzNdKSpzL3Qsb30sbn0oKTtmdW5jdGlvbiBsKG4pe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEltYWdlO3QuY3Jvc3NPcmlnaW49XCJhbm9ueW1vdXNcIix0Lm9ubG9hZD1mdW5jdGlvbigpe2UodCl9LHQuc3JjPW59KSl9fSxmdW5jdGlvbihuLGUsdCl7bi5leHBvcnRzPSgoKT0+e1widXNlIHN0cmljdFwiO3ZhciBuPXs2NDY6KG4sZSx0KT0+e3QucihlKSx0LmQoZSx7R0xIZWxwZXI6KCk9PmIsZ2xJbnN0YW5jZTooKT0+Ym4sb3BzOigpPT54bix3ZWJnbF90eXBlczooKT0+b30pO3ZhciBvPXt9O3QucihvKSx0LmQobyx7VW5pZm9ybVR5cGU6KCk9PmZ9KTt2YXIgcj17fTt0LnIociksdC5kKHIse2hhcmRTaWdtb2lkOigpPT5NLGxlYWt5UmVsdTooKT0+Uyxwb3dfZnVuYzooKT0+aixwcmVsdTooKT0+VixyZWx1NjooKT0+QyxzY2FsZTooKT0+ayxzY2FsZVdpZHRoQmlhczooKT0+UixzaWdtb2lkOigpPT5JLHNxcnQ6KCk9PkwsdGFuaF9mdW5jOigpPT5ELHRyYW5zZmVyRnJvbU5IV0N0b05DSFc6KCk9Pk99KTt2YXIgaT17fTtmdW5jdGlvbiBzKCl7dmFyIG47aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyluPXdpbmRvdztlbHNlIGlmKHZvaWQgMCE9PXQuZyluPXQuZztlbHNle2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgZ2xvYmFsIG9iamVjdFwiKTtuPXNlbGZ9cmV0dXJuIG59ZnVuY3Rpb24gYShuLGUpe3ZhciB0PXMoKTtyZXR1cm4gdFtuXXx8KHRbbl09ZSksdFtuXX10LnIoaSksdC5kKGkse2dldFBpeGVsc0Zyb21UZXh0dXJlUG9zOigpPT5HLGdldFNhbXBsZXJDb2RlOigpPT5ILGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4OigpPT5VLGdldFZhbHVlRnJvbVRlbnNvclBvczooKT0+TixnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nOigpPT5CLG1vdmVUZXh0dXJlMlBvc1RvUmVhbDooKT0+V30pO3ZhciB1PXtvcFJlZ2lzdHJ5OntvcHM6e319LGJhY2tlbmQ6XCJcIixiYWNrZW5kSW5zdGFuY2U6bnVsbH07dT1hKFwiR0xPQkFMU1wiLHUpO3ZhciBsPXMoKTtsLkltYWdlQml0bWFwfHwobC5JbWFnZUJpdG1hcD1mdW5jdGlvbigpe30pO2NvbnN0IGM9YShcImVudlwiLG5ldyhmdW5jdGlvbigpe2Z1bmN0aW9uIG4oKXt0aGlzLkVOVj17fX1yZXR1cm4gbi5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKG4sZSl7dGhpcy5FTlZbbl09ZX0sbi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLkVOVltuXX0sbn0oKSkpO3ZhciBmLGgscDtmdW5jdGlvbiBkKG4pe2Zvcih2YXIgZT1uLmxlbmd0aCx0PWZ1bmN0aW9uKCl7Zm9yKHZhciBuPTAsZT0wLHQ9YXJndW1lbnRzLmxlbmd0aDtlPHQ7ZSsrKW4rPWFyZ3VtZW50c1tlXS5sZW5ndGg7dmFyIG89QXJyYXkobikscj0wO2ZvcihlPTA7ZTx0O2UrKylmb3IodmFyIGk9YXJndW1lbnRzW2VdLHM9MCxhPWkubGVuZ3RoO3M8YTtzKysscisrKW9bcl09aVtzXTtyZXR1cm4gb30obiksbz1bXTtlPjE7KXQuc3BsaWNlKDAsMSksby5wdXNoKHQucmVkdWNlKChmdW5jdGlvbihuLGUpe3JldHVybiBuKmV9KSkpLGUtLTtyZXR1cm4gb31mdW5jdGlvbiBnKG4pe3JldHVybiBuLnJlZHVjZSgoZnVuY3Rpb24obixlKXtyZXR1cm4gbiplfSksMSl9ZnVuY3Rpb24gXyhuLGUpe3JldHVybiAwPT09bi5sZW5ndGg/XCJcIjpuLnJlZHVjZSgoZnVuY3Rpb24oZSx0LG8pe3JldHVybiBlK1wiZmxvYXQoXCIrdCtcIilcIisobz09PW4ubGVuZ3RoLTE/XCIpO1wiOlwiLFwiKX0pLFwiZmxvYXQgXCIrZStcIltcIituLmxlbmd0aCtcIl0gPSBmbG9hdFtdKFwiKX1mdW5jdGlvbiBtKG4sZSl7aWYoMT09PW4ubGVuZ3RoKXJldHVyblwiZmxvYXQgXCIrZStcIiA9IGZsb2F0KFwiK25bMF0rXCIpO1wiO2Zvcih2YXIgdD1uLmxlbmd0aCxvPVwiXFxuICAgICAgICB2ZWNcIit0K1wiIFwiK2UrXCIgPSB2ZWNcIit0K1wiKFxcbiAgICBcIixyPTA7cjx0O3IrKylvKz1cImZsb2F0KFwiK25bcl0rXCIpLFwiO3JldHVybiBvLnNsaWNlKDAsLTEpK1wiKTtcIn0hZnVuY3Rpb24obil7bi51bmlmb3JtMWY9XCIxZlwiLG4udW5pZm9ybTFmdj1cIjFmdlwiLG4udW5pZm9ybTFpPVwiMWlcIixuLnVuaWZvcm0xaXY9XCIxaXZcIixuLnVuaWZvcm0yZj1cIjJmXCIsbi51bmlmb3JtMmZ2PVwiMmZ2XCIsbi51bmlmb3JtMmk9XCIyaVwiLG4udW5pZm9ybTJpdj1cIjJpdlwiLG4udW5pZm9ybTNmPVwiM2ZcIixuLnVuaWZvcm0zZnY9XCIzZnZcIixuLnVuaWZvcm0zaT1cIjNpXCIsbi51bmlmb3JtM2l2PVwiM2l2XCIsbi51bmlmb3JtNGY9XCI0ZlwiLG4udW5pZm9ybTRmdj1cIjRmdlwiLG4udW5pZm9ybTRpPVwiNGlcIixuLnVuaWZvcm00aXY9XCI0aXZcIn0oZnx8KGY9e30pKSxmdW5jdGlvbihuKXtuW24uVlNfU0hBREVSPTBdPVwiVlNfU0hBREVSXCIsbltuLkZTX1NIQURFUj0xXT1cIkZTX1NIQURFUlwifShofHwoaD17fSkpLGZ1bmN0aW9uKG4pe25bbi5GTE9BVF9WRUMyPTM1NjY0XT1cIkZMT0FUX1ZFQzJcIixuW24uRkxPQVRfVkVDMz0zNTY2NV09XCJGTE9BVF9WRUMzXCIsbltuLkZMT0FUX1ZFQzQ9MzU2NjZdPVwiRkxPQVRfVkVDNFwiLG5bbi5JTlRfVkVDMj0zNTY2N109XCJJTlRfVkVDMlwiLG5bbi5JTlRfVkVDMz0zNTY2OF09XCJJTlRfVkVDM1wiLG5bbi5JTlRfVkVDND0zNTY2OV09XCJJTlRfVkVDNFwiLG5bbi5CT09MPTM1NjcwXT1cIkJPT0xcIixuW24uQk9PTF9WRUMyPTM1NjcxXT1cIkJPT0xfVkVDMlwiLG5bbi5CT09MX1ZFQzM9MzU2NzJdPVwiQk9PTF9WRUMzXCIsbltuLkJPT0xfVkVDND0zNTY3M109XCJCT09MX1ZFQzRcIixuW24uRkxPQVRfTUFUMj0zNTY3NF09XCJGTE9BVF9NQVQyXCIsbltuLkZMT0FUX01BVDM9MzU2NzVdPVwiRkxPQVRfTUFUM1wiLG5bbi5GTE9BVF9NQVQ0PTM1Njc2XT1cIkZMT0FUX01BVDRcIixuW24uU0FNUExFUl8yRD0zNTY3N109XCJTQU1QTEVSXzJEXCIsbltuLlNBTVBMRVJfQ1VCRT0zNTY3OF09XCJTQU1QTEVSX0NVQkVcIixuW24uRkxPQVQ9NTEyNl09XCJGTE9BVFwiLG5bbi5JTlQ9NTEyNF09XCJJTlRcIn0ocHx8KHA9e30pKTt2YXIgdixQPWZ1bmN0aW9uKG4sZSx0KXt0aGlzLnNpemU9bix0aGlzLnR5cGU9ZSx0aGlzLmxvY2F0aW9uPXR9LHg9ZnVuY3Rpb24obixlLHQpe3RoaXMuc2l6ZT1uLHRoaXMudHlwZT1lLHRoaXMubG9jYXRpb249dH0sYj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4oKXt9cmV0dXJuIG4uZ2V0V2ViZ2xWZXJzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGMuZ2V0KFwid2ViZ2xWZXJzaW9uXCIpfSxuLmNyZWF0ZUNhbnZhcz1mdW5jdGlvbigpe3JldHVybiBjLmdldChcImNhbnZhc1wiKXx8ZG9jdW1lbnQmJmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIil9LG4uc2V0V2ViZ2xWZXJzaW9uPWZ1bmN0aW9uKG4pe2Muc2V0KFwid2ViZ2xWZXJzaW9uXCIsbil9LG4uc2V0V2ViR0xSZW5kZXJpbmdDb250ZXh0PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmdsPW4sbn0sbi5nZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nbD90aGlzLmdsOnRoaXMuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0KCl9LG4uY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5nbClyZXR1cm4gdGhpcy5nbDt2YXIgbj10aGlzLmNyZWF0ZUNhbnZhcygpO2lmKCFuKXJldHVybiBudWxsO24uYWRkRXZlbnRMaXN0ZW5lciYmbi5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLChmdW5jdGlvbihuKXt0aHJvdyBuLnByZXZlbnREZWZhdWx0KCksRXJyb3IoXCJ3ZWJnbCBjb250ZXh0IGlzIGxvc3R+XCIpfSksITEpO3ZhciBlPW4uZ2V0Q29udGV4dChcIndlYmdsMlwiLHRoaXMuV0VCR0xfQVRUUklCVVRFUyk7cmV0dXJuIGU/Yy5zZXQoXCJ3ZWJnbFZlcnNpb25cIiwyKTooYy5zZXQoXCJ3ZWJnbFZlcnNpb25cIiwxKSxlPW4uZ2V0Q29udGV4dChcIndlYmdsXCIsdGhpcy5XRUJHTF9BVFRSSUJVVEVTKXx8bi5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsdGhpcy5XRUJHTF9BVFRSSUJVVEVTKSksZX0sbi5wcmludFN0YXRlcz1mdW5jdGlvbihuKXtjb25zb2xlLmxvZyhcIjEuIGlzQmxlbmRFbmFibGUgPSBcIituLmlzRW5hYmxlZChuLkJMRU5EKSksY29uc29sZS5sb2coXCIyLiBpc0N1bGxGYWNlRW5hYmxlID0gXCIrbi5pc0VuYWJsZWQobi5DVUxMX0ZBQ0UpKSxjb25zb2xlLmxvZyhcIjMuIGlzRGVwdGhUZXN0RW5hYmxlID0gXCIrbi5pc0VuYWJsZWQobi5ERVBUSF9URVNUKSksY29uc29sZS5sb2coXCI0LiBpc0RpdGhlckVuYWJsZSA9IFwiK24uaXNFbmFibGVkKG4uRElUSEVSKSksY29uc29sZS5sb2coXCI1LiBpc1BvbHlnb25PZmZzZXRGaWxsRW5hYmxlID0gXCIrbi5pc0VuYWJsZWQobi5QT0xZR09OX09GRlNFVF9GSUxMKSksY29uc29sZS5sb2coXCI2LiBpc1NhbXBsZUFscGh0VG9Db3ZlcmFnZUVuYWJsZSA9IFwiK24uaXNFbmFibGVkKG4uU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFKSksY29uc29sZS5sb2coXCI3LiBpc1NhbXBsZUNvdmVyYWdlRW5hYmxlID0gXCIrbi5pc0VuYWJsZWQobi5TQU1QTEVfQ09WRVJBR0UpKSxjb25zb2xlLmxvZyhcIjguIGlzU2Npc3NvclRlc3RFbmFibGUgPSBcIituLmlzRW5hYmxlZChuLlNDSVNTT1JfVEVTVCkpLGNvbnNvbGUubG9nKFwiOS4gaXNTdGVuY2lsVGVzdEVuYWJsZSA9IFwiK24uaXNFbmFibGVkKG4uU1RFTkNJTF9URVNUKSl9LG4ucHJpbnRXZWJHTEluZm89ZnVuY3Rpb24obil7Y29uc29sZS5sb2coXCJyZW5kZXJlciA9IFwiK24uZ2V0UGFyYW1ldGVyKG4uUkVOREVSRVIpKSxjb25zb2xlLmxvZyhcInZlcnNpb24gPSBcIituLmdldFBhcmFtZXRlcihuLlZFUlNJT04pKSxjb25zb2xlLmxvZyhcInZlbmRvciA9IFwiK24uZ2V0UGFyYW1ldGVyKG4uVkVORE9SKSksY29uc29sZS5sb2coXCJnbHNsIHZlcnNpb24gPSBcIituLmdldFBhcmFtZXRlcihuLlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTikpfSxuLnByaW50V2ViR0xUZXh0dXJlSW5mbz1mdW5jdGlvbihuKXtjb25zb2xlLmxvZyhcIk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTID0gXCIsbi5nZXRQYXJhbWV0ZXIobi5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUykpLGNvbnNvbGUubG9nKFwiTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgPSBcIixuLmdldFBhcmFtZXRlcihuLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSksY29uc29sZS5sb2coXCJNQVhfVEVYVFVSRV9TSVpFID0gXCIsbi5nZXRQYXJhbWV0ZXIobi5NQVhfVEVYVFVSRV9TSVpFKSksY29uc29sZS5sb2coXCJNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFID0gXCIsbi5nZXRQYXJhbWV0ZXIobi5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFKSl9LG4udHJpZ2dlckNvbnRleHRMb3N0RXZlbnQ9ZnVuY3Rpb24obil7dmFyIGU9bi5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIik7bnVsbCE9PWUmJmUubG9zZUNvbnRleHQoKX0sbi5jaGVja0dMRXJyb3I9ZnVuY3Rpb24obil7dmFyIGU9bi5nZXRFcnJvcigpO3JldHVybiAwIT09ZSYmKGNvbnNvbGUubG9nKFwiV2ViR0wgRXJyb3IgTk86IFwiLGUpLCEwKX0sbi5zZXREZWZhdWx0U3RhdGU9ZnVuY3Rpb24obil7bi5jbGVhckNvbG9yKDAsMCwwLDApLG4uY2xlYXJEZXB0aCgxKSxuLmVuYWJsZShuLkRFUFRIX1RFU1QpLG4uZW5hYmxlKG4uQ1VMTF9GQUNFKSxuLmVuYWJsZShuLlNDSVNTT1JfVEVTVCl9LG4uc2V0Vmlld3BvcnQ9ZnVuY3Rpb24obixlKXtuLnZpZXdwb3J0KGVbMF0sZVsxXSxlWzJdLGVbM10pfSxuLmluaXRTaGFkZXI9ZnVuY3Rpb24obixlLHQpe3ZhciBvPXRoaXMuY3JlYXRlU2hhZGVyKG4sZSk7cmV0dXJuIHRoaXMuY29tcGlsZVNoYWRlcihuLHQsbyksb30sbi5jcmVhdGVTaGFkZXI9ZnVuY3Rpb24obixlKXt2YXIgdDtpZihudWxsPT09KHQ9ZT09PWguVlNfU0hBREVSP24uY3JlYXRlU2hhZGVyKG4uVkVSVEVYX1NIQURFUik6bi5jcmVhdGVTaGFkZXIobi5GUkFHTUVOVF9TSEFERVIpKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTFNoYWRlcuWIm+W7uuWksei0pe+8gVwiKTtyZXR1cm4gdH0sbi5jb21waWxlU2hhZGVyPWZ1bmN0aW9uKG4sZSx0KXtyZXR1cm4gbi5zaGFkZXJTb3VyY2UodCxlKSxuLmNvbXBpbGVTaGFkZXIodCksITEhPT1uLmdldFNoYWRlclBhcmFtZXRlcih0LG4uQ09NUElMRV9TVEFUVVMpfHwoY29uc29sZS5lcnJvcihuLmdldFNoYWRlckluZm9Mb2codCkpLG4uZGVsZXRlU2hhZGVyKHQpLCExKX0sbi5jcmVhdGVQcm9ncmFtPWZ1bmN0aW9uKG4pe3ZhciBlPW4uY3JlYXRlUHJvZ3JhbSgpO2lmKG51bGw9PT1lKXRocm93IG5ldyBFcnJvcihcIldlYkdMUHJvZ3JhbeWIm+W7uuWksei0pe+8gVwiKTtyZXR1cm4gZX0sbi5saW5rUHJvZ3JhbT1mdW5jdGlvbihuLGUsdCxvLHIsaSl7cmV0dXJuIHZvaWQgMD09PXImJihyPW51bGwpLHZvaWQgMD09PWkmJihpPW51bGwpLG4uYXR0YWNoU2hhZGVyKGUsdCksbi5hdHRhY2hTaGFkZXIoZSxvKSxudWxsIT09ciYmcihuLGUpLG4ubGlua1Byb2dyYW0oZSksITE9PT1uLmdldFByb2dyYW1QYXJhbWV0ZXIoZSxuLkxJTktfU1RBVFVTKT8oY29uc29sZS5lcnJvcihuLmdldFByb2dyYW1JbmZvTG9nKGUpKSxuLmRlbGV0ZVNoYWRlcih0KSxuLmRlbGV0ZVNoYWRlcihvKSxuLmRlbGV0ZVByb2dyYW0oZSksITEpOihuLnZhbGlkYXRlUHJvZ3JhbShlKSwhMT09PW4uZ2V0UHJvZ3JhbVBhcmFtZXRlcihlLG4uVkFMSURBVEVfU1RBVFVTKT8oY29uc29sZS5lcnJvcihuLmdldFByb2dyYW1JbmZvTG9nKGUpKSxuLmRlbGV0ZVNoYWRlcih0KSxuLmRlbGV0ZVNoYWRlcihvKSxuLmRlbGV0ZVByb2dyYW0oZSksITEpOihudWxsIT09aSYmaShuLGUpLCEwKSl9LG4uZ2V0UHJvZ3JhbUFjdGl2ZUF0dHJpYnM9ZnVuY3Rpb24obixlLHQpe2Zvcih2YXIgbz1uLmdldFByb2dyYW1QYXJhbWV0ZXIoZSxuLkFDVElWRV9BVFRSSUJVVEVTKSxyPTA7cjxvO3IrKyl7dmFyIGk9bi5nZXRBY3RpdmVBdHRyaWIoZSxyKTtpJiYodFtpLm5hbWVdPW5ldyB4KGkuc2l6ZSxpLnR5cGUsbi5nZXRBdHRyaWJMb2NhdGlvbihlLGkubmFtZSkpKX19LG4uZ2V0UHJvZ3JhbUF0Y2l2ZVVuaWZvcm1zPWZ1bmN0aW9uKG4sZSx0KXtmb3IodmFyIG89bi5nZXRQcm9ncmFtUGFyYW1ldGVyKGUsbi5BQ1RJVkVfVU5JRk9STVMpLHI9MDtyPG87cisrKXt2YXIgaT1uLmdldEFjdGl2ZVVuaWZvcm0oZSxyKTtpZihpKXt2YXIgcz1uLmdldFVuaWZvcm1Mb2NhdGlvbihlLGkubmFtZSk7bnVsbCE9PXMmJih0W2kubmFtZV09bmV3IFAoaS5zaXplLGkudHlwZSxzKSl9fX0sbi5jcmVhdGVCdWZmZXI9ZnVuY3Rpb24obil7dmFyIGU9bi5jcmVhdGVCdWZmZXIoKTtpZihudWxsPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTEJ1ZmZlcuWIm+W7uuWksei0pe+8gVwiKTtyZXR1cm4gZX0sbi5nZXRDb2xvckJ1ZmZlckRhdGE9ZnVuY3Rpb24obil7dmFyIGU9bmV3IFVpbnQ4QXJyYXkobi5kcmF3aW5nQnVmZmVyV2lkdGgqbi5kcmF3aW5nQnVmZmVySGVpZ2h0KjQpO3JldHVybiBuLnJlYWRQaXhlbHMoMCwwLG4uZHJhd2luZ0J1ZmZlcldpZHRoLG4uZHJhd2luZ0J1ZmZlckhlaWdodCxuLlJHQkEsbi5VTlNJR05FRF9CWVRFLGUpLGV9LG4uc2V0VW5pZm9ybVBhcmFtPWZ1bmN0aW9uKG4sZSx0LG8pe3N3aXRjaCh0KXtjYXNlIGYudW5pZm9ybTFmOm4udW5pZm9ybTFmKGUsbyk7YnJlYWs7Y2FzZSBmLnVuaWZvcm0xZnY6bi51bmlmb3JtMWZ2KGUsbyk7YnJlYWs7Y2FzZSBmLnVuaWZvcm0xaTpuLnVuaWZvcm0xaShlLG8pO2JyZWFrO2Nhc2UgZi51bmlmb3JtMWl2Om4udW5pZm9ybTFpdihlLG8pO2JyZWFrO2Nhc2UgZi51bmlmb3JtMmY6bi51bmlmb3JtMmYoZSxvWzBdLG9bMV0pO2JyZWFrO2Nhc2UgZi51bmlmb3JtMmZ2Om4udW5pZm9ybTJmdihlLG8pO2JyZWFrO2Nhc2UgZi51bmlmb3JtMmk6bi51bmlmb3JtMmkoZSxvWzBdLG9bMV0pO2JyZWFrO2Nhc2UgZi51bmlmb3JtMml2Om4udW5pZm9ybTJpdihlLG8pO2JyZWFrO2Nhc2UgZi51bmlmb3JtM2Y6bi51bmlmb3JtM2YoZSxvWzBdLG9bMV0sb1syXSk7YnJlYWs7Y2FzZSBmLnVuaWZvcm0zZnY6bi51bmlmb3JtM2Z2KGUsbyk7YnJlYWs7Y2FzZSBmLnVuaWZvcm0zaTpuLnVuaWZvcm0zaShlLG9bMF0sb1sxXSxvWzJdKTticmVhaztjYXNlIGYudW5pZm9ybTNpdjpuLnVuaWZvcm0zaXYoZSxvKTticmVhaztjYXNlIGYudW5pZm9ybTRmOm4udW5pZm9ybTRmKGUsb1swXSxvWzFdLG9bMl0sb1szXSk7YnJlYWs7Y2FzZSBmLnVuaWZvcm00ZnY6bi51bmlmb3JtNGZ2KGUsbyk7YnJlYWs7Y2FzZSBmLnVuaWZvcm00aTpuLnVuaWZvcm00aShlLG9bMF0sb1sxXSxvWzJdLG9bM10pO2JyZWFrO2Nhc2UgZi51bmlmb3JtNGl2Om4udW5pZm9ybTRpdihlLG8pO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS5lcnJvcihcIltcIit0K1wiXTogdW5rbm93biB1bmlmb3JtIHR5cGVcIil9fSxuLmdlblRleHR1cmVJbmZvRnJvbVRlbnNvclNoYXBlPWZ1bmN0aW9uKG4sZSl7dmFyIHQ9bnx8NDA5NixvPWUuc2hhcGUscj12b2lkIDA9PT1vP1tdOm8saT1mdW5jdGlvbigpe2Zvcih2YXIgbj0wLGU9MCx0PWFyZ3VtZW50cy5sZW5ndGg7ZTx0O2UrKyluKz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciBvPUFycmF5KG4pLHI9MDtmb3IoZT0wO2U8dDtlKyspZm9yKHZhciBpPWFyZ3VtZW50c1tlXSxzPTAsYT1pLmxlbmd0aDtzPGE7cysrLHIrKylvW3JdPWlbc107cmV0dXJuIG99KHIpLnNvcnQoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4tZX0pKSxzPWlbMF0sYT1pWzFdLHU9aVsyXSxsPXMqaVszXSxmPWEqdTtpZihsPnR8fGY+dCl7dmFyIGg9W2wsZl0uc29ydCgoZnVuY3Rpb24obixlKXtyZXR1cm4gbi1lfSkpLHA9aFswXSxkPWhbMV0sZz1mdW5jdGlvbihuLGUpe3ZhciB0PWU7aWYobiV0PT0wKXJldHVybiB0O2Zvcig7dDxuJiZuJXQhPTA7KXQrKztyZXR1cm4gdH0oZCxNYXRoLmNlaWwoZC90KSk7aWYobD1wKmcsZj1NYXRoLmNlaWwoZC9nKSxjLmdldChcImRlYnVnXCIpJiZjb25zb2xlLmVycm9yKFwi5aSn5bCP6LaF6ZmQXCIscixbZixsXSksbD50fHxmPnQpdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSBbXCIrbCtcInhcIitmK1wiXSBncmVhdGVyIHRoYW4gV2ViR0wgbWF4aW11bSBvbiB0aGlzIGJyb3dzZXIgLyBHUFUgW1wiK3QrXCJ4XCIrdCtcIl0uXCIpfWUuc2hhcGVfdGV4dHVyZT1bZixsXX0sbi5XRUJHTF9BVFRSSUJVVEVTPXthbHBoYTohMSxhbnRpYWxpYXM6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohMSxkZXB0aDohMSxzdGVuY2lsOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITAscG93ZXJQcmVmZXJlbmNlOlwiaGlnaC1wZXJmb3JtYW5jZVwifSxuLmdsPW51bGwsbn0oKTshZnVuY3Rpb24obil7bltuLkdMX1JFUEVBVD0wXT1cIkdMX1JFUEVBVFwiLG5bbi5HTF9NSVJST1JFRF9SRVBFQVQ9MV09XCJHTF9NSVJST1JFRF9SRVBFQVRcIixuW24uR0xfQ0xBTVBfVE9fRURHRT0yXT1cIkdMX0NMQU1QX1RPX0VER0VcIn0odnx8KHY9e30pKTt2YXIgVD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4oKXt9cmV0dXJuIG4uZ2V0VGV4dHVyZUNvbmZpZz1mdW5jdGlvbihuKXt2YXIgZSx0LG8scixpLHMsYSx1LGw9bixmPSEwLGg9ITA7cmV0dXJuIDI9PT1jLmdldChcIndlYmdsVmVyc2lvblwiKT8oZT1sLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIiksbz1sLkhBTEZfRkxPQVQscj1sLlIzMkYsaT1sLlJHQkEzMkYscz1sLlIxNkYsYT1sLlJHQkExNkYsdD1sLlJFRCx1PWwuUkdCQTMyRik6KHI9bC5SR0JBLHM9bC5SR0JBLGE9bC5SR0JBLGk9bC5SR0JBLHQ9bC5SR0JBLHU9bC5SR0JBLGU9bC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSxvPWwuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKS5IQUxGX0ZMT0FUX09FUyxmPXRoaXMuaXNEb3dubG9hZEZsb2F0VGV4dHVyZUVuYWJsZWQobCx1KSxoPXRoaXMuaXNGbG9hdFRleHR1cmVSZWFkUGl4ZWxzRW5hYmxlZE1ldGhvZChsLDEsZikpLHt0ZXh0dXJlRmxvYXQ6ZSx0ZXh0dXJlSGFsZkZsb2F0Om8saW50ZXJuYWxGb3JtYXQ6cixpbnRlcm5hbEZvcm1hdFBhY2tlZDppLGludGVybmFsRm9ybWF0SGFsZkZsb2F0OnMsaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQ6YSx0ZXh0dXJlRm9ybWF0OnQsZG93bmxvYWRJbnRlcm5hbEZvcm1hdDp1LGZyYW1lQnVmZmVyU3VwcG9ydEZsb2F0OmYsaXNGbG9hdFRleHR1cmVSZWFkUGl4ZWxzRW5hYmxlZDpofX0sbi5pc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkTWV0aG9kPWZ1bmN0aW9uKG4sZSx0KXt2YXIgbz1uO2lmKDA9PT1lKXJldHVybiExO2lmKDE9PT1lKXtpZihudWxsPT1vLmdldEV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0XCIpKXJldHVybiExfWVsc2UgaWYobnVsbD09by5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpfHxudWxsPT1vLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKSlyZXR1cm4hMTt2YXIgcj1vLmNyZWF0ZUZyYW1lYnVmZmVyKCksaT1vLmNyZWF0ZVRleHR1cmUoKTtvLmJpbmRUZXh0dXJlKG8uVEVYVFVSRV8yRCxpKTt2YXIgcz0yPT09ZT9vLlJHQkEzMkY6by5SR0JBO28udGV4SW1hZ2UyRChvLlRFWFRVUkVfMkQsMCxzLDEsMSwwLG8uUkdCQSx0P28uRkxPQVQ6by5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpLkhBTEZfRkxPQVRfT0VTLG51bGwpLG8uYmluZEZyYW1lYnVmZmVyKG8uRlJBTUVCVUZGRVIsciksby5mcmFtZWJ1ZmZlclRleHR1cmUyRChvLkZSQU1FQlVGRkVSLG8uQ09MT1JfQVRUQUNITUVOVDAsby5URVhUVVJFXzJELGksMCk7dmFyIGE9by5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKG8uRlJBTUVCVUZGRVIpPT09by5GUkFNRUJVRkZFUl9DT01QTEVURTtvLnJlYWRQaXhlbHMoMCwwLDEsMSxvLlJHQkEsby5GTE9BVCxuZXcgRmxvYXQzMkFycmF5KDQpKTt2YXIgdT1vLmdldEVycm9yKCk9PT1vLk5PX0VSUk9SO3JldHVybiBhJiZ1fSxuLmlzRG93bmxvYWRGbG9hdFRleHR1cmVFbmFibGVkPWZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5jcmVhdGVUZXh0dXJlKCk7bi5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsdCksbi50ZXhJbWFnZTJEKG4uVEVYVFVSRV8yRCwwLGUsMSwxLDAsbi5SR0JBLG4uRkxPQVQsbnVsbCk7dmFyIG89bi5jcmVhdGVGcmFtZWJ1ZmZlcigpO24uYmluZEZyYW1lYnVmZmVyKG4uRlJBTUVCVUZGRVIsbyksbi5mcmFtZWJ1ZmZlclRleHR1cmUyRChuLkZSQU1FQlVGRkVSLG4uQ09MT1JfQVRUQUNITUVOVDAsbi5URVhUVVJFXzJELHQsMCk7dmFyIHI9bi5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKG4uRlJBTUVCVUZGRVIpPT09bi5GUkFNRUJVRkZFUl9DT01QTEVURTtyZXR1cm4gbi5iaW5kVGV4dHVyZShuLlRFWFRVUkVfMkQsbnVsbCksbi5iaW5kRnJhbWVidWZmZXIobi5GUkFNRUJVRkZFUixudWxsKSxuLmRlbGV0ZVRleHR1cmUodCksbi5kZWxldGVGcmFtZWJ1ZmZlcihvKSxyfSxuLnVwbG9hZERhdGFUb1RleHR1cmU9ZnVuY3Rpb24obixlLHQsbyl7bi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfTUFHX0ZJTFRFUixuLk5FQVJFU1QpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX01JTl9GSUxURVIsbi5ORUFSRVNUKSxuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9XUkFQX1Msbi5DTEFNUF9UT19FREdFKSxuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9XUkFQX1Qsbi5DTEFNUF9UT19FREdFKTt2YXIgcj10LndpZHRoX3RleHR1cmUsaT10LmhlaWdodF90ZXh0dXJlLHM9dC5kYXRhLGE9bi5SR0JBLHU9bi5SR0JBLGw9bi5GTE9BVCxmPXM7aWYocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fHMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8IShzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHxzIGluc3RhbmNlb2YgQXJyYXkpKWw9bi5VTlNJR05FRF9CWVRFO2Vsc2UgaWYoMj09PWMuZ2V0KFwid2ViZ2xWZXJzaW9uXCIpKXt2YXIgaD1jLmdldChcIndlYmdsX2ZvcmNlX2hhbGZfZmxvYXRfdGV4dHVyZVwiKTthPW8/aD9lLmludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0OmUuaW50ZXJuYWxGb3JtYXRQYWNrZWQ6aD9lLmludGVybmFsRm9ybWF0SGFsZkZsb2F0OmUuaW50ZXJuYWxGb3JtYXQsdT1vP24uUkdCQTplLnRleHR1cmVGb3JtYXR9ZWxzZXtmb3IodmFyIHA9bmV3IEZsb2F0MzJBcnJheShyKmkqNCksZD0wO2Q8cy5sZW5ndGg7ZCsrKW8/cFtkXT1zW2RdOihwWzQqZF09c1tkXSxwWzQqZCsxXT0wLHBbNCpkKzJdPTAscFs0KmQrM109MCk7Zj1wfW4udGV4SW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxhLHIsaSwwLHUsbCxmKX0sbi5nZW5PdXRwdXRUZXh0dXJlPWZ1bmN0aW9uKG4sZSx0LG8pe3ZhciByPXQuaW50ZXJwVHlwZSxpPXQud2lkdGhfdGV4dHVyZSxzPXQuaGVpZ2h0X3RleHR1cmUsYT1uLmNyZWF0ZVRleHR1cmUoKTtuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCxhKSxuLnRleFBhcmFtZXRlcmkobi5URVhUVVJFXzJELG4uVEVYVFVSRV9NQUdfRklMVEVSLFwiTElORUFSXCI9PT1yP24uTElORUFSOm4uTkVBUkVTVCksbi50ZXhQYXJhbWV0ZXJpKG4uVEVYVFVSRV8yRCxuLlRFWFRVUkVfTUlOX0ZJTFRFUixcIkxJTkVBUlwiPT09cj9uLkxJTkVBUjpuLk5FQVJFU1QpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfUyxuLkNMQU1QX1RPX0VER0UpLG4udGV4UGFyYW1ldGVyaShuLlRFWFRVUkVfMkQsbi5URVhUVVJFX1dSQVBfVCxuLkNMQU1QX1RPX0VER0UpO3ZhciB1PWMuZ2V0KFwid2ViZ2xfZm9yY2VfaGFsZl9mbG9hdF90ZXh0dXJlXCIpLGw9dT9lLmludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0OmUuaW50ZXJuYWxGb3JtYXRQYWNrZWQsZj0yPT09Yy5nZXQoXCJ3ZWJnbFZlcnNpb25cIik/dT9uLkhBTEZfRkxPQVQ6bi5GTE9BVDplLmZyYW1lQnVmZmVyU3VwcG9ydEZsb2F0P24uRkxPQVQ6ZS50ZXh0dXJlSGFsZkZsb2F0LGg9bz9lLmlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQ/ZjpuLlVOU0lHTkVEX0JZVEU6bnVsbDtyZXR1cm4gbi50ZXhJbWFnZTJEKG4uVEVYVFVSRV8yRCwwLGwsaSxzLDAsbi5SR0JBLG8/aDpmLG51bGwpLG4uYmluZFRleHR1cmUobi5URVhUVVJFXzJELG51bGwpLGF9LG59KCkseT1bXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xcblxcbiAgICBhdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG4gICAgdmFyeWluZyB2ZWMyIHZDb29yZDtcXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdkNvb3JkLnggPSAocG9zaXRpb24ueCArIDEuMCkgLyAyLjA7XFxuICAgICAgICB2Q29vcmQueSA9IChwb3NpdGlvbi55ICsgMS4wKSAvIDIuMDtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuICAgIH1cXG4gICAgXCIsXCIjdmVyc2lvbiAzMDAgZXNcXG4gICAgaW4gdmVjNCBwb3NpdGlvbjtcXG4gICAgb3V0IHZlYzIgdkNvb3JkO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2Q29vcmQueCA9IChwb3NpdGlvbi54ICsgMS4wKSAvIDIuMDtcXG4gICAgICAgIHZDb29yZC55ID0gKHBvc2l0aW9uLnkgKyAxLjApIC8gMi4wO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgfVxcbiAgICBcIl0sRj1uZXcgRmxvYXQzMkFycmF5KFstMSwxLC0xLC0xLDEsMSwxLC0xXSksdz1bXCJsZW5ndGhfc2hhcGVcIixcImxlbmd0aF91bmZvcm1hdHRlZF9zaGFwZVwiLFwid2lkdGhfc2hhcGVcIixcImhlaWdodF9zaGFwZVwiLFwid2lkdGhfdGV4dHVyZVwiLFwiaGVpZ2h0X3RleHR1cmVcIixcIm9mZnNldF94XCIsXCJvZmZzZXRfeVwiLFwiY2hhbm5lbFwiLFwidG90YWxfc2hhcGVcIixcIm51bWJlcnNfc2hhcGVcIl0sRT17ZmxvYXQ6W1wibXVsdGlfdmFsdWVcIixcImJpYXNfdmFsdWVcIl0sYm9vbDpbXCJmdXNlX3JlbHVcIl19O2Z1bmN0aW9uIEEoKXtyZXR1cm5cIlxcbiAgICBcIisoYy5nZXQoXCJ1c2VNb2RBZGFwdG9yXCIpP1wiXFxuICAgICAgICAgICAgaW50IGNhbE1vZChpbnQgYSwgaW50IGIpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgbW9kViA9IG1vZChmbG9hdChhKSwgZmxvYXQoYikpO1xcbiAgICAgICAgICAgICAgICBpZiAobW9kViA9PSBmbG9hdChiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgbW9kViA9IDAuMDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50KG1vZFYpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgICAgaW50IGNhbE1vZChpbnQgYSwgaW50IGIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBhIC8gYiAqIGI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCIpK1wiXFxuICAgIFwiKyhjLmdldChcInVzZURpdmlzaW9uQWRhcHRvclwiKT9cIlxcbiAgICAgICAgICAgIGludCBjYWxEaXZpc2lvbihpbnQgYSwgaW50IGIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludChmbG9hdChhKSAvIChmbG9hdChiKSAtIDAuMDAwMSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgICAgaW50IGNhbERpdmlzaW9uKGludCBhLCBpbnQgYikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gYSAvIGI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCIpK1wiXFxuICAgIFxcbiAgICBmbG9hdCB0YW5oX2NhbGMoZmxvYXQgbnVtKSB7XFxuICAgICAgICBmbG9hdCByZXMgPSAoZXhwKDIuMCAqIG51bSkgLSAxLjApIC8gKGV4cCgyLjAgKiBudW0pICsgMS4wKTtcXG4gICAgICAgIHJldHVybiByZXM7XFxuICAgIH1cXG4gICAgXFxuICAgIFwifWNvbnN0IE89XCJcXG5pdmVjNCB0cmFuc2ZlckZyb21OSFdDdG9OQ0hXKFxcbiAgICBpbnQgc3VtVmFsLFxcbiAgICBjb25zdCBpbnQgY2hhbm5lbCxcXG4gICAgY29uc3QgaW50IHdpZHRoX3NoYXBlLFxcbiAgICBjb25zdCBpbnQgaGVpZ2h0X3NoYXBlLFxcbiAgICBjb25zdCBpbnQgdG90YWxfc2hhcGUpIHtcXG5cXG4gICAgaW50IG5fb3JpZ2luID0gaW50KHRvdGFsX3NoYXBlLyhjaGFubmVsICogd2lkdGhfc2hhcGUgKiBoZWlnaHRfc2hhcGUpKTtcXG4gICAgaW50IG5ld19hID0gY2FsTW9kKHN1bVZhbCwgd2lkdGhfc2hhcGUpO1xcbiAgICBzdW1WYWwgPSBpbnQoKHN1bVZhbCAtIG5ld19hKSAvIHdpZHRoX3NoYXBlKTtcXG4gICAgaW50IG5ld19iID0gY2FsTW9kKHN1bVZhbCwgaGVpZ2h0X3NoYXBlKTtcXG4gICAgc3VtVmFsID0gaW50KChzdW1WYWwgLSBuZXdfYikgLyBoZWlnaHRfc2hhcGUpO1xcbiAgICBpbnQgbmV3X2cgPSBjYWxNb2Qoc3VtVmFsLCBjaGFubmVsKTtcXG4gICAgc3VtVmFsID0gaW50KChzdW1WYWwgLSBuZXdfZykgLyBjaGFubmVsKTtcXG4gICAgaW50IG5ld19yID0gY2FsTW9kKHN1bVZhbCwgbl9vcmlnaW4pO1xcbiAgICByZXR1cm4gaXZlYzQobmV3X3IsbmV3X2csbmV3X2IsbmV3X2EpO1xcbn1cXG5cIjt2YXIgVj1cIlxcbmZsb2F0IHByZWx1KGZsb2F0IHgsIGZsb2F0IHAsIGZsb2F0IGIpIHtcXG4gICAgZmxvYXQgcmVzdWx0ID0geDtcXG4gICAgaWYgKHggPCAwLjApIHtcXG4gICAgICAgIHJlc3VsdCA9IHggKiBwO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXN1bHQ7XFxufVwiLEM9XCJcXG5mbG9hdCByZWx1NihmbG9hdCB4LCBmbG9hdCB0aHJlc2hvbGQsIGZsb2F0IGIpIHtcXG4gICAgZmxvYXQgcmVzdWx0ID0gbWluKG1heCgwLjAsIHgpLCB0aHJlc2hvbGQpO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cIixTPVwiXFxuZmxvYXQgbGVha3lSZWx1KGZsb2F0IHgsIGZsb2F0IHAsIGZsb2F0IGIpIHtcXG4gICAgZmxvYXQgcmVzdWx0ID0gbWF4KHgsIHggKiBwKTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XCIsaz1cIlxcbmZsb2F0IHNjYWxlKGZsb2F0IHgsIGZsb2F0IHAsIGZsb2F0IGIpIHtcXG4gICAgZmxvYXQgcmVzdWx0ID0gcCAqIHggKyBiO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cIixSPVwiXFxuZmxvYXQgc2NhbGVXaWR0aEJpYXMoZmxvYXQgeCwgZmxvYXQgcCwgZmxvYXQgYikge1xcbiAgICBmbG9hdCByZXN1bHQgPSBwICogKHggKyBiKTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG59XCIsST1cIlxcbmZsb2F0IHNpZ21vaWQoZmxvYXQgeCwgZmxvYXQgeSwgZmxvYXQgeikge1xcbiAgICBmbG9hdCByZXN1bHQgPSAxLjAgLyAoMS4wICsgZXhwKC14KSk7XFxuICAgIHJldHVybiByZXN1bHQ7XFxufVwiLE09XCJcXG4gICAgZmxvYXQgaGFyZFNpZ21vaWQoZmxvYXQgeCwgZmxvYXQgc2xvcGUsIGZsb2F0IG9mZnNldCkge1xcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gbWF4KDAuMCwgbWluKDEuMCwgc2xvcGUgKiB4ICsgb2Zmc2V0KSk7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXCIsTD1cIlxcbiAgICBmbG9hdCBzcXJ0KGZsb2F0IHgsIGZsb2F0IHNsb3BlLCBmbG9hdCBvZmZzZXQpIHtcXG4gICAgICAgIHJldHVybiBzcXJ0KHgpO1xcbiAgICB9XFxuXCIsaj1cIlxcbiAgICBmbG9hdCBwb3dfZnVuYyhmbG9hdCB4LCBmbG9hdCBmYWN0b3IsIGZsb2F0IG9mZnNldCkge1xcbiAgICAgICAgcmV0dXJuIHBvdyh4LCBmYWN0b3IpO1xcbiAgICB9XFxuXCIsRD1cIlxcbmZsb2F0IHRhbmhfZnVuYyhmbG9hdCB4LCBmbG9hdCB5LCBmbG9hdCB6KSB7XFxuICAgIHJldHVybiB0YW5oX2NhbGMoeCk7XFxufVwiO2Z1bmN0aW9uIE4obixlKXt2YXIgdD1lLndpZHRoX3NoYXBlLG89ZS5oZWlnaHRfc2hhcGUscj1lLmNoYW5uZWwsaT1lLndpZHRoX3RleHR1cmU7cmV0dXJuXCJcXG4gICAgLy8g5qC55o2udGVuc29y5Z2Q5qCH6I635Y+W6L+Z5LiqdGVuc29y5L2N572u55qE5YC8XFxuICAgIGZsb2F0IGdldFZhbHVlRnJvbVRlbnNvclBvc19cIituK1wiKGludCBuLCBpbnQgYywgaW50IGgsIGludCB3KSB7XFxuICAgICAgICBpbnQgaW5kZXggPSBuICogXCIrdCpvKnIrXCIgKyBjICogXCIrdCpvK1wiICsgaCAqIFwiK3QrXCIgKyB3O1xcbiAgICAgICAgaW50IHBvc193ID0gaW50KG1vZChmbG9hdChpbmRleCksIGZsb2F0KFwiK2krXCIpKSk7XFxuICAgICAgICBpbnQgcG9zX2ggPSBpbmRleCAvIGludChcIitpK1wiKTtcXG4gICAgICAgIHZlYzQgcGl4ZWxzID0gVEVYVFVSRTJEKHRleHR1cmVfXCIrbitcIixcXG4gICAgICAgICAgICB2ZWMyKFxcbiAgICAgICAgICAgICAgICAoZmxvYXQocG9zX3cpICArIDAuNSkgLyBmbG9hdChcIitpK1wiKSxcXG4gICAgICAgICAgICAgICAgKGZsb2F0KHBvc19oKSArIDAuNSkgLyBmbG9hdChcIitlLmhlaWdodF90ZXh0dXJlK1wiKVxcbiAgICAgICAgICAgIClcXG4gICAgICAgICk7XFxuICAgICAgICAvLyDlj6rnlKjkuoZy6YCa6YGTXFxuICAgICAgICByZXR1cm4gcGl4ZWxzLnI7XFxuICAgIH1cIn1mdW5jdGlvbiBCKG4sZSl7dmFyIHQ9ZS5jaGFubmVsLG89ZS5oZWlnaHRfc2hhcGUscj1lLndpZHRoX3RleHR1cmUsaT1lLmhlaWdodF90ZXh0dXJlLHM9ZS53aWR0aF9zaGFwZTtyZXR1cm5cIlxcbiAgICAvLyDmoLnmja50ZW5zb3LlnZDmoIfojrflj5bov5nkuKp0ZW5zb3LkvY3nva7nmoTlgLxcXG4gICAgdmVjNCBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nX1wiK24rXCIoaW50IG4sIGludCBjLCBpbnQgaCwgaW50IHcpIHtcXG4gICAgICAgIGludCBpbmRleCA9IG4gKiBcIitzKm8qdCtcIiArIGMgKiBcIitzKm8rXCIgKyBoICogXCIrcytcIiArIHc7XFxuICAgICAgICBpbnQgcG9zX3cgPSBpbnQobW9kKGZsb2F0KGluZGV4KSwgZmxvYXQoXCIrcitcIikpKTtcXG4gICAgICAgIGludCBwb3NfaCA9IGluZGV4IC8gaW50KFwiK3IrXCIpO1xcbiAgICAgICAgdmVjNCBwaXhlbHMgPSBURVhUVVJFMkQodGV4dHVyZV9cIituK1wiLFxcbiAgICAgICAgICAgIHZlYzIoXFxuICAgICAgICAgICAgICAgIChmbG9hdChwb3NfdykgICsgMC41KSAvIGZsb2F0KFwiK3IrXCIpLFxcbiAgICAgICAgICAgICAgICAoZmxvYXQocG9zX2gpICsgMC41KSAvIGZsb2F0KFwiK2krXCIpXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgKTtcXG4gICAgICAgIC8vIOWPqueUqOS6hnLpgJrpgZNcXG4gICAgICAgIHJldHVybiBwaXhlbHM7XFxuICAgIH1cIn1mdW5jdGlvbiBVKG4sZSl7dmFyIHQ9ZS5udW1iZXJzX3NoYXBlLG89ZS5sZW5ndGhfc2hhcGU7aWYoMT09PW8pcmV0dXJuXCJcXG4gICAgICAgICAgICBpbnQgZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfXCIrbitcIihpbnQgbikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsTW9kKG4sIFwiK3RbMF0rXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIFwiO2Zvcih2YXIgcj1cIml2ZWNcIitvK1wiKFwiK3Quam9pbihcIiwgXCIpK1wiKVwiLGk9XCJwb3NbMF0gPSBuIC8gXCIrdFswXStcIjtcIixzPTE7czxvO3MrKylpKz1cIlxcbiAgICAgICAgICAgIG4gPSBjYWxNb2QobiwgXCIrdFtzLTFdK1wiKTtcXG4gICAgICAgICAgICBwb3NbXCIrcytcIl0gPSBjYWxEaXZpc2lvbihuLCBcIit0W3NdK1wiKTtcXG4gICAgICAgIFwiO3JldHVyblwiXFxuICAgIGl2ZWNcIitvK1wiIHNoYXBlVmVjX1wiK24rXCIgPSBcIityK1wiO1xcbiAgICBpdmVjXCIrbytcIiBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9cIituK1wiKGludCBuKSB7XFxuICAgICAgICBpdmVjXCIrbytcIiBwb3M7XFxuICAgICAgICBcIitpK1wiXFxuICAgICAgICByZXR1cm4gcG9zO1xcbiAgICB9XFxuICAgIFwifWZ1bmN0aW9uIEcobil7cmV0dXJuXCJcXG4gICAgI2RlZmluZSBnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc19cIituK1wiKHBvcykgVEVYVFVSRTJEKHRleHR1cmVfXCIrbitcIiwgcG9zKVxcbiAgICBcIn1mdW5jdGlvbiBXKG4sZSl7cmV0dXJuXCJcXG4gICAgdmVjMiBtb3ZlVGV4dHVyZTJQb3NUb1JlYWxfXCIrbitcIih2ZWMyIHYpIHtcXG4gICAgICAgIHZlYzIgdjI7XFxuICAgICAgICB2Mi54ID0gdi54ICogZmxvYXQoXCIrZS53aWR0aF90ZXh0dXJlK1wiKTtcXG4gICAgICAgIHYyLnkgPSB2LnkgKiBmbG9hdChcIitlLmhlaWdodF90ZXh0dXJlK1wiKTtcXG4gICAgICAgIHJldHVybiB2MjtcXG4gICAgfVxcbiAgICBcIn1mdW5jdGlvbiBIKG4pe3JldHVyblwidW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZV9cIituK1wiO1wifWZ1bmN0aW9uIFgobixlLHQsbyxzKXt2YXIgYSx1LGw9XCJcIixmPWUubmFtZSxoPWUubWFpbkZ1bmMscD1lLnRleHR1cmVGdW5jQ29uZixkPXZvaWQgMD09PXA/e306cCxnPWUuY29tbW9uRnVuY0NvbmY7dHJ5e3ZhciBfPWZ1bmN0aW9uKG4sZSx0KXtmb3IodmFyIG89e30scj1PYmplY3QuYXNzaWduKHt9LGUpLGk9W10scz0wLGE9bjtzPGEubGVuZ3RoO3MrKyl7Zm9yKHZhciB1PWFbc10sbD11Lm5hbWUsYz17fSxmPTAsaD13O2Y8aC5sZW5ndGg7ZisrKXZvaWQgMCE9PXVbdj1oW2ZdXSYmKGNbdl09dVt2XSk7b1tsXT1jLGkucHVzaChsKX1mb3IodmFyIHA9MCxkPU9iamVjdC5rZXlzKEUpO3A8ZC5sZW5ndGg7cCsrKWZvcih2YXIgZz1kW3BdLF89MCxtPUVbZ107XzxtLmxlbmd0aDtfKyspe3ZhciB2O3ZvaWQgMCE9PWVbdj1tW19dXSYmKHJbdl09ZytcIihcIitlW3ZdK1wiKVwiKX1yZXR1cm4gZS5hY3RpdmVfZnVuY3Rpb24mJihyLmFjdGl2ZV9mdW5jdGlvbj1lLmFjdGl2ZV9mdW5jdGlvbiksci5ydW50aW1lPXQse3RleHR1cmVQYXJhbXM6byxvcFBhcmFtczpyLGFjdGl2ZV9mdW5jdGlvbjplLmFjdGl2ZV9mdW5jdGlvbn19KHQsbyxzKSxtPV8udGV4dHVyZVBhcmFtcyx2PV8ub3BQYXJhbXMsUD1fLmFjdGl2ZV9mdW5jdGlvbix4PTI9PT1jLmdldChcIndlYmdsVmVyc2lvblwiKT9cIiAjdmVyc2lvbiAzMDAgZXNcXG4gICAgICAgICAgICAjaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG4gICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcXG4gICAgICAgICNlbHNlXFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgaW50O1xcbiAgICAgICAgI2VuZGlmICAgICAgXFxuICAgICAgICBcIjpcIiAjaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG4gICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcXG4gICAgICAgICNlbHNlXFxuICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICAgICAgICAjZW5kaWZcXG4gICAgICAgIFwiLGI9ZnVuY3Rpb24obil7dmFyIGU9bi5mcmFtZUJ1ZmZlclN1cHBvcnRGbG9hdCx0PW4uaXNGaW5hbE9wLG89bi5pc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkO3JldHVybiAyPT09Yy5nZXQoXCJ3ZWJnbFZlcnNpb25cIik/XCJcXG4gICAgICAgIC8vIOmhtueCuXNoYWRlcumAj+S8oOeahOadkOi0qOWdkOagh1xcbiAgICAgICAgaW4gdmVjMiB2Q29vcmQ7XFxuICAgICAgICBvdXQgdmVjNCBvdXRDb2xvcjtcXG4gICAgICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHJlc3VsdCkge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1c2Vfb3AocmVzdWx0KTtcXG4gICAgICAgICAgICBvdXRDb2xvci5yID0gcmVzdWx0O1xcbiAgICAgICAgfVxcbiAgICAgICAgdm9pZCBzZXRQYWNrZWRPdXRwdXQodmVjNCByZXN1bHQpIHtcXG4gICAgICAgICAgICBvdXRDb2xvciA9IHJlc3VsdDtcXG4gICAgICAgIH1cXG4gICAgICAgIGludCBjYWxDZWlsKGludCBhLCBpbnQgYikge1xcbiAgICAgICAgICAgIHJldHVybiBpbnQoY2VpbChmbG9hdChhKSAvIGZsb2F0KGIpKSk7XFxuICAgICAgICB9XFxuICAgICAgICBcIitBKCkrXCJcXG4gICAgXCI6ZT9cIlxcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2Q29vcmQ7XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWM0IG91dENvbG9yO1xcbiAgICAgICAgICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHJlc3VsdCkge1xcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdXNlX29wKHJlc3VsdCk7XFxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvci5yID0gcmVzdWx0O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2b2lkIHNldFBhY2tlZE91dHB1dCh2ZWM0IHJlc3VsdCkge1xcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSByZXN1bHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBjYWxDZWlsKGludCBhLCBpbnQgYikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50KGNlaWwoZmxvYXQoYSkgLyBmbG9hdChiKSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcIitBKCkrXCJcXG4gICAgXCI6dCYmIW8/XCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2Q29vcmQ7XFxuICAgICAgICB2YXJ5aW5nIHZlYzQgb3V0Q29sb3I7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xcbiAgICAgICAgY29uc3QgZmxvYXQgRkxPQVRfTUlOID0gMS4xNzU0OTQzNWUtMzg7XFxuXFxuICAgICAgICAjZGVmaW5lIGlzbmFuKHZhbHVlKSBpc25hbl9jdXN0b20odmFsdWUpXFxuICAgICAgICBib29sIGlzbmFuX2N1c3RvbShmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgICByZXR1cm4gKHZhbCA+IDAuIHx8IHZhbCA8IDEuIHx8IHZhbCA9PSAwLikgPyBmYWxzZSA6IHRydWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIitBKCkrXCJcXG5cXG4gICAgICAgIGludCBjYWxDZWlsKGludCBhLCBpbnQgYikge1xcbiAgICAgICAgICAgIHJldHVybiBpbnQoY2VpbChmbG9hdChhKSAvIGZsb2F0KGIpKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBsb3dwIHZlYzQgZW5jb2RlX2Zsb2F0KGhpZ2hwIGZsb2F0IHYpIHtcXG4gICAgICAgICAgICBpZiAoaXNuYW4odikpIHtcXG4gICAgICAgICAgICByZXR1cm4gdmVjNCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBoaWdocCBmbG9hdCBhdiA9IGFicyh2KTtcXG5cXG4gICAgICAgICAgICBpZihhdiA8IEZMT0FUX01JTikge1xcbiAgICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmKHYgPiBGTE9BVF9NQVgpIHtcXG4gICAgICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xcbiAgICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAgMTI4LjAsIDI1NS4wKSAvIDI1NS4wO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBoaWdocCB2ZWM0IGMgPSB2ZWM0KDAsMCwwLDApO1xcblxcbiAgICAgICAgICAgIGhpZ2hwIGZsb2F0IGUgPSBmbG9vcihsb2cyKGF2KSk7XFxuICAgICAgICAgICAgaGlnaHAgZmxvYXQgbSA9IGV4cDIoZnJhY3QobG9nMihhdikpKSAtIDEuMDtcXG5cXG4gICAgICAgICAgICBjWzJdID0gZmxvb3IoMTI4LjAgKiBtKTtcXG4gICAgICAgICAgICBtIC09IGNbMl0gLyAxMjguMDtcXG4gICAgICAgICAgICBjWzFdID0gZmxvb3IoMzI3NjguMCAqIG0pO1xcbiAgICAgICAgICAgIG0gLT0gY1sxXSAvIDMyNzY4LjA7XFxuICAgICAgICAgICAgY1swXSA9IGZsb29yKDgzODg2MDguMCAqIG0pO1xcblxcbiAgICAgICAgICAgIGhpZ2hwIGZsb2F0IGViaWFzID0gZSArIDEyNy4wO1xcbiAgICAgICAgICAgIGNbM10gPSBmbG9vcihlYmlhcyAvIDIuMCk7XFxuICAgICAgICAgICAgZWJpYXMgLT0gY1szXSAqIDIuMDtcXG4gICAgICAgICAgICBjWzJdICs9IGZsb29yKGViaWFzKSAqIDEyOC4wO1xcblxcbiAgICAgICAgICAgIGNbM10gKz0gMTI4LjAgKiBzdGVwKDAuMCwgLXYpO1xcblxcbiAgICAgICAgICAgIHJldHVybiBjIC8gMjU1LjA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2b2lkIHNldE91dHB1dChmbG9hdCByZXN1bHQpIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVzZV9vcChyZXN1bHQpO1xcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBlbmNvZGVfZmxvYXQocmVzdWx0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgICAgI2RlZmluZSBpc25hbih2YWx1ZSkgaXNuYW5fY3VzdG9tKHZhbHVlKVxcbiAgICAgICAgICAgIGJvb2wgaXNuYW5fY3VzdG9tKGZsb2F0IHZhbCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbCA+IDAuIHx8IHZhbCA8IDEuIHx8IHZhbCA9PSAwLikgPyBmYWxzZSA6IHRydWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2Q29vcmQ7XFxuICAgICAgICAgICAgdmFyeWluZyB2ZWM0IG91dENvbG9yO1xcbiAgICAgICAgICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHJlc3VsdCkge1xcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdXNlX29wKHJlc3VsdCk7XFxuICAgICAgICAgICAgICAgIGlmKGlzbmFuKHJlc3VsdCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvci5yID0gMC4wO1xcbiAgICAgICAgICAgICAgICB9ZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IuciA9IHJlc3VsdDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB2b2lkIHNldFBhY2tlZE91dHB1dCh2ZWM0IHJlc3VsdCkge1xcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSByZXN1bHQ7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIFwiK0EoKStcIlxcblxcbiAgICAgICAgICAgIGludCBjYWxDZWlsKGludCBhLCBpbnQgYikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50KGNlaWwoZmxvYXQoYSkgLyBmbG9hdChiKSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIFwifShuKSxUPWZ1bmN0aW9uKG4pe3ZhciBlPVwiXCIsdD1cIlwiO2lmKG4uZnVzZV9vcHQpZm9yKHZhciBvIGluIG4uZnVzZV9vcHQpe3ZhciBpPW8scz0wLGE9MDtzd2l0Y2gobyl7Y2FzZVwic2NhbGVcIjp2YXIgdT1uLmZ1c2Vfb3B0LnNjYWxlLmJpYXNfYWZ0ZXJfc2NhbGUsbD1uLmZ1c2Vfb3B0LnNjYWxlLnNjYWxlO3M9dm9pZCAwIT09bD9sOjEsYT1uLmZ1c2Vfb3B0LnNjYWxlLmJpYXN8fDAsITE9PT11JiZ2b2lkIDAhPT11JiYoaT1cInNjYWxlV2lkdGhCaWFzXCIpO2JyZWFrO2Nhc2VcInJlbHVcIjppPVwicHJlbHVcIjticmVhaztjYXNlXCJyZWx1NlwiOnM9bi5mdXNlX29wdFtvXS50aHJlc2hvbGQ7YnJlYWs7Y2FzZVwiaGFyZF9zaWdtb2lkXCI6aT1cImhhcmRTaWdtb2lkXCIscz1uLmZ1c2Vfb3B0W29dLnNsb3BlfHwuMixhPW4uZnVzZV9vcHRbb10ub2Zmc2V0fHwuNTticmVhaztjYXNlXCJsZWFreVJlbHVcIjpzPW4uZnVzZV9vcHRbb10uYWxwaGE7YnJlYWs7Y2FzZVwicG93XCI6aT1cInBvd19mdW5jXCIscz1uLmZ1c2Vfb3B0W29dLmZhY3Rvcnx8MjticmVhaztjYXNlXCJ0YW5oXCI6aT1cInRhbmhfZnVuY1wifWUrPXJbaV0sdCs9XCJyZXMgPSBcIitpK1wiKHgsIGZsb2F0KFwiK3MrXCIpLCBmbG9hdChcIithK1wiKSk7XCJ9cmV0dXJuXCJcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICAgIFxcbiAgICAgICAgZmxvYXQgZnVzZV9vcChmbG9hdCB4KSB7XFxuICAgICAgICAgICAgZmxvYXQgcmVzID0geDtcXG4gICAgICAgICAgICBcIit0K1wiXFxuICAgICAgICAgICAgcmV0dXJuIHJlcztcXG4gICAgICAgIH1cXG4gICAgXCJ9KHYpLHk9ZnVuY3Rpb24obixlLHQsbyl7aWYoIW4pcmV0dXJuXCJcIjt2YXIgcj1PYmplY3QuYXNzaWduKHt9LG4pO3JbXCJAYWxsXCJdJiZmdW5jdGlvbihuLGUpe3ZhciB0PWUuZmlsdGVyKChmdW5jdGlvbihuKXtyZXR1cm5cIm91dFwiIT09bi5uYW1lfSkpLG89bltcIkBhbGxcIl07dC5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1lLm5hbWU7blt0XT9uW3RdLmNvbmNhdChvKTpuW3RdPW99KSksZGVsZXRlIG5bXCJAYWxsXCJdfShyLG8pO2Zvcih2YXIgcz1cIlwiLGE9XCJcIix1PTAsbD1PYmplY3Qua2V5cyhyKTt1PGwubGVuZ3RoO3UrKyl7dmFyIGM9bFt1XTtpZihlW2NdKXthKz1IKGMpO2Zvcih2YXIgZj0wLGg9cltjXTtmPGgubGVuZ3RoO2YrKyl7dmFyIHA9aFtmXTtpZihpW3BdKXRyeXtzKz1pW3BdKGMsZVtjXSx0KX1jYXRjaChuKXtjb25zb2xlLmVycm9yKG4pfX19fXJldHVyblwiXFxuICAgIFwiK2ErXCJcXG4gICAgXCIrcytcIlxcbiAgICBcIn0oZCxtLHYsdCksRj1mdW5jdGlvbihuKXtyZXR1cm4gdm9pZCAwPT09bj9cIlwiOlwiXFxuICAgICAgICBpbnQgbGF5ZXJfcnVuX3RpbWUgPSBcIituK1wiO1xcbiAgICBcIn0ocyksTz1mdW5jdGlvbihuKXt2YXIgZSx0LG8scixpO3JldHVyblwiXFxuICAgICAgICBcXG4gICAgdmVjMiBfMmRfc2hhcGVfdGV4dHVyZV9vdXQgPSB2ZWMyKGZsb2F0KFwiK24ud2lkdGhfdGV4dHVyZStcIiksIGZsb2F0KFwiK24uaGVpZ2h0X3RleHR1cmUrXCIpKTtcXG4gICAgXFxuICAgICAgICBcIisodD0oZT1uKS5oZWlnaHRfc2hhcGUsbz1lLndpZHRoX3NoYXBlLFwiXFxuICAgIGl2ZWM0IGdldE91dHB1dFRlbnNvclBvcygpIHtcXG4gICAgICAgIHZlYzIgb3V0Q29vcmQgPSB2Q29vcmQueHkgKiAoXzJkX3NoYXBlX3RleHR1cmVfb3V0KTtcXG4gICAgICAgIGludCBpbmRleCA9IGludChvdXRDb29yZC54KSArIGludChvdXRDb29yZC55KSAqIGludChcIitlLndpZHRoX3RleHR1cmUrXCIpO1xcblxcbiAgICAgICAgaW50IG4xID0gaW50KGluZGV4IC8gXCIrKHI9byp0KmUuY2hhbm5lbCkrXCIpO1xcbiAgICAgICAgaW50IGMxID0gaW50KGNhbE1vZChpbmRleCwgXCIrcitcIikgLyBcIisoaT1vKnQpK1wiKTtcXG4gICAgICAgIGludCBoMSA9IGludChjYWxNb2QoaW5kZXgsIFwiK2krXCIpIC8gXCIrbytcIik7XFxuICAgICAgICBpbnQgdzEgPSBjYWxNb2QoaW5kZXgsIFwiK28rXCIpO1xcbiAgICAgICAgcmV0dXJuIGl2ZWM0KG4xLCBjMSwgaDEsIHcxKTtcXG4gICAgfVxcbiAgICBcXG4gICAgXCIpfShtLm91dCk7YT1sPVwiIFwiK3grXCJcXG4gICAgICAgICAgICBcIitUK1wiXFxuICAgICAgICAgICAgXCIrYitcIlxcbiAgICAgICAgICAgIFwiK2Z1bmN0aW9uKG4pe2lmKCFuKXJldHVyblwiXCI7Zm9yKHZhciBlPVwiXCIsdD0wLG89bjt0PG8ubGVuZ3RoO3QrKyl7dmFyIGk9b1t0XTtyW2ldJiYoZSs9cltpXSl9cmV0dXJuIGV9KGcpK1wiXFxuICAgICAgICAgICAgXCIrKFA/cltQXTpcIlwiKStcIlxcbiAgICAgICAgICAgIFwiK3krXCJcXG4gICAgICAgICAgICBcIitGK1wiXFxuICAgICAgICAgICAgXCIrTytcIlxcbiAgICAgICAgICAgIFwiK2gobSx2KStcIlxcbiAgICAgICAgXCIsdT0xPT09Yy5nZXQoXCJ3ZWJnbFZlcnNpb25cIik/XCJ0ZXh0dXJlMkRcIjpcInRleHR1cmVcIixsPWEucmVwbGFjZSgvXFxiVEVYVFVSRTJEXFxiL2csdSl9Y2F0Y2gobil7Y29uc29sZS5lcnJvcihcIltcIitmK1wiXTogXCIrbil9cmV0dXJuIGx9Y29uc3Qgej1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixlLHQsbyl7dmFyIHI9bjt0aGlzLnZTaGFkZXI9ZTt0cnl7dGhpcy5mU2hhZGVyPXRoaXMuaW5pdFNoYWRlcihyLHQsXCJmcmFnbWVudFwiKSx0aGlzLnNoYXBlPW8mJm8uc2hhcGU7dmFyIGk9dGhpcy5wcm9ncmFtPXIuY3JlYXRlUHJvZ3JhbSgpO3IuYXR0YWNoU2hhZGVyKGksdGhpcy52U2hhZGVyKSxyLmF0dGFjaFNoYWRlcihpLHRoaXMuZlNoYWRlciksci5saW5rUHJvZ3JhbShpKX1jYXRjaChuKXt0aHJvdyBuZXcgRXJyb3Iobil9fXJldHVybiBuLnByb3RvdHlwZS5pbml0U2hhZGVyPWZ1bmN0aW9uKG4sZSx0KXt2b2lkIDA9PT10JiYodD1cInZlcnRleFwiKTt2YXIgbyxyPVwidmVydGV4XCI9PT10P24uVkVSVEVYX1NIQURFUjpuLkZSQUdNRU5UX1NIQURFUjtpZihcInZlcnRleFwiPT09dCYmdGhpcy52U2hhZGVyKW89dGhpcy52U2hhZGVyO2Vsc2UgaWYobz1uLmNyZWF0ZVNoYWRlcihyKSxcInZlcnRleFwiPT09dCYmKHRoaXMudlNoYWRlcj1vKSxuLnNoYWRlclNvdXJjZShvLGUpLG4uY29tcGlsZVNoYWRlcihvKSwhbi5nZXRTaGFkZXJQYXJhbWV0ZXIobyxuLkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBuZXcgRXJyb3IoXCJjb21waWxlOiBcIituLmdldFNoYWRlckluZm9Mb2cobykpO3JldHVybiBvfSxuLnByb3RvdHlwZS5zZXRQcm9ncmFtPWZ1bmN0aW9uKG4sZSx0KXtuLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKSx0fHx0aGlzLnJ1blZlcnRleFNoYWRlcihuLGUpfSxuLnByb3RvdHlwZS5ydW5WZXJ0ZXhTaGFkZXI9ZnVuY3Rpb24obixlKXt2YXIgdD1uLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSxcInBvc2l0aW9uXCIpO24uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodCksbi5iaW5kQnVmZmVyKG4uQVJSQVlfQlVGRkVSLGUpLG4udmVydGV4QXR0cmliUG9pbnRlcih0LDIsbi5GTE9BVCwhMSwwLDApfSxuLlNhbXBsZXI9XCJ1U2FtcGxlclwiLG59KCk7dmFyIHEsWT0ocT1mdW5jdGlvbihuLGUpe3JldHVybihxPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLGUpe24uX19wcm90b19fPWV9fHxmdW5jdGlvbihuLGUpe2Zvcih2YXIgdCBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpJiYoblt0XT1lW3RdKX0pKG4sZSl9LGZ1bmN0aW9uKG4sZSl7ZnVuY3Rpb24gdCgpe3RoaXMuY29uc3RydWN0b3I9bn1xKG4sZSksbi5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToodC5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IHQpfSksSz1mdW5jdGlvbihuLGUsdCxvKXtyZXR1cm4gbmV3KHR8fCh0PVByb21pc2UpKSgoZnVuY3Rpb24ocixpKXtmdW5jdGlvbiBzKG4pe3RyeXt1KG8ubmV4dChuKSl9Y2F0Y2gobil7aShuKX19ZnVuY3Rpb24gYShuKXt0cnl7dShvLnRocm93KG4pKX1jYXRjaChuKXtpKG4pfX1mdW5jdGlvbiB1KG4pe3ZhciBlO24uZG9uZT9yKG4udmFsdWUpOihlPW4udmFsdWUsZSBpbnN0YW5jZW9mIHQ/ZTpuZXcgdCgoZnVuY3Rpb24obil7bihlKX0pKSkudGhlbihzLGEpfXUoKG89by5hcHBseShuLGV8fFtdKSkubmV4dCgpKX0pKX0sWj1mdW5jdGlvbihuLGUpe3ZhciB0LG8scixpLHM9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmclswXSl0aHJvdyByWzFdO3JldHVybiByWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIGk9e25leHQ6YSgwKSx0aHJvdzphKDEpLHJldHVybjphKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihpW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGk7ZnVuY3Rpb24gYShpKXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGkpe2lmKHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtzOyl0cnl7aWYodD0xLG8mJihyPTImaVswXT9vLnJldHVybjppWzBdP28udGhyb3d8fCgocj1vLnJldHVybikmJnIuY2FsbChvKSwwKTpvLm5leHQpJiYhKHI9ci5jYWxsKG8saVsxXSkpLmRvbmUpcmV0dXJuIHI7c3dpdGNoKG89MCxyJiYoaT1bMiZpWzBdLHIudmFsdWVdKSxpWzBdKXtjYXNlIDA6Y2FzZSAxOnI9aTticmVhaztjYXNlIDQ6cmV0dXJuIHMubGFiZWwrKyx7dmFsdWU6aVsxXSxkb25lOiExfTtjYXNlIDU6cy5sYWJlbCsrLG89aVsxXSxpPVswXTtjb250aW51ZTtjYXNlIDc6aT1zLm9wcy5wb3AoKSxzLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKChyPShyPXMudHJ5cykubGVuZ3RoPjAmJnJbci5sZW5ndGgtMV0pfHw2IT09aVswXSYmMiE9PWlbMF0pKXtzPTA7Y29udGludWV9aWYoMz09PWlbMF0mJighcnx8aVsxXT5yWzBdJiZpWzFdPHJbM10pKXtzLmxhYmVsPWlbMV07YnJlYWt9aWYoNj09PWlbMF0mJnMubGFiZWw8clsxXSl7cy5sYWJlbD1yWzFdLHI9aTticmVha31pZihyJiZzLmxhYmVsPHJbMl0pe3MubGFiZWw9clsyXSxzLm9wcy5wdXNoKGkpO2JyZWFrfXJbMl0mJnMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZX1pPWUuY2FsbChuLHMpfWNhdGNoKG4pe2k9WzYsbl0sbz0wfWZpbmFsbHl7dD1yPTB9aWYoNSZpWzBdKXRocm93IGlbMV07cmV0dXJue3ZhbHVlOmlbMF0/aVsxXTp2b2lkIDAsZG9uZTohMH19KFtpLGFdKX19fTtjb25zdCBKPWZ1bmN0aW9uKG4pe2Z1bmN0aW9uIGUoKXt2YXIgZT1uLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGUuY2FjaGVUZXh0dXJlcz17fSxlLnVuaWZvcm1Mb2NhdGlvbnM9e30sZS50ZXh0dXJlc01hcD17fSxlLnF1ZXJ5TGlzdD1bXSxlLmN1cnJlbnRUZXh0dXJlPW51bGwsZS53aWR0aF9zaGFwZV9vdXQ9MSxlLmhlaWdodF9zaGFwZV9vdXQ9MSxlLndpZHRoX3RleHR1cmVfb3V0PTEsZS5oZWlnaHRfdGV4dHVyZV9vdXQ9MSxlLmNoYW5uZWw9MCxlLnRvdGFsX3NoYXBlPTAsZX1yZXR1cm4gWShlLG4pLGUucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oKXtyZXR1cm4gSyh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIFoodGhpcywoZnVuY3Rpb24oZSl7cmV0dXJuIG49dGhpcy5nbD1iLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dCgpLHRoaXMuZ2w/KHRoaXMuZ2xWZXJzaW9uPWIuZ2V0V2ViZ2xWZXJzaW9uKCksdGhpcy50ZXh0dXJlQ29uZj1ULmdldFRleHR1cmVDb25maWcobiksdGhpcy5NQVhfVEVYVFVSRV9TSVpFPWMuZ2V0KFwiTUFYX1RFWFRVUkVfU0laRVwiKXx8bi5nZXRQYXJhbWV0ZXIobi5NQVhfVEVYVFVSRV9TSVpFKSxuLmRpc2FibGUobi5ERVBUSF9URVNUKSxuLmRpc2FibGUobi5TVEVOQ0lMX1RFU1QpLG4uZGlzYWJsZShuLkJMRU5EKSxuLmRpc2FibGUobi5ESVRIRVIpLG4uZGlzYWJsZShuLlBPTFlHT05fT0ZGU0VUX0ZJTEwpLG4uZGlzYWJsZShuLlNBTVBMRV9DT1ZFUkFHRSksbi5lbmFibGUobi5TQ0lTU09SX1RFU1QpLG4uZW5hYmxlKG4uQ1VMTF9GQUNFKSxuLmN1bGxGYWNlKG4uQkFDSyksdGhpcy52ZXJ0ZXhCdWZmZXI9bi5jcmVhdGVCdWZmZXIoKSxuLmJpbmRCdWZmZXIobi5BUlJBWV9CVUZGRVIsdGhpcy52ZXJ0ZXhCdWZmZXIpLG4uYnVmZmVyRGF0YShuLkFSUkFZX0JVRkZFUixGLG4uU1RBVElDX0RSQVcpLHRoaXMudlNoYWRlcj1iLmluaXRTaGFkZXIobixoLlZTX1NIQURFUix5W3RoaXMuZ2xWZXJzaW9uLTFdKSx0aGlzLmZyYW1lQnVmZmVyPW4uY3JlYXRlRnJhbWVidWZmZXIoKSxuLmJpbmRGcmFtZWJ1ZmZlcihuLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVCdWZmZXIpLHRoaXMucGJvPW4uY3JlYXRlQnVmZmVyKCksWzJdKTpbMl19KSl9KSl9LGUucHJvdG90eXBlLmNyZWF0ZVByb2dyYW09ZnVuY3Rpb24obil7dmFyIGU9dGhpcyx0PW4ub3Asbz1uLm91dFRlbnNvcixyPW4uaW5wdXRUZW5zb3JzLGk9bi5zaGFkZXJQYXJhbXMscz1uLnJ1bnRpbWUsYT1uLmlzRmluYWxPcCx1PW51bGw7dHJ5e3ZhciBsPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPTAsZT0wLHQ9YXJndW1lbnRzLmxlbmd0aDtlPHQ7ZSsrKW4rPWFyZ3VtZW50c1tlXS5sZW5ndGg7dmFyIG89QXJyYXkobikscj0wO2ZvcihlPTA7ZTx0O2UrKylmb3IodmFyIGk9YXJndW1lbnRzW2VdLHM9MCxhPWkubGVuZ3RoO3M8YTtzKysscisrKW9bcl09aVtzXTtyZXR1cm4gb30oW29dLHIpO2wuZm9yRWFjaCgoZnVuY3Rpb24obil7cmV0dXJuIGIuZ2VuVGV4dHVyZUluZm9Gcm9tVGVuc29yU2hhcGUoZS5NQVhfVEVYVFVSRV9TSVpFLG4pfSkpO3ZhciBjPVgodGhpcy50ZXh0dXJlQ29uZix0LGwsaSxzKTsodT1uZXcgeih0aGlzLmdsLHRoaXMudlNoYWRlcixjLG8pKS5mc0NvZGU9Yzt2YXIgZj1ULmdlbk91dHB1dFRleHR1cmUodGhpcy5nbCx0aGlzLnRleHR1cmVDb25mLG8sYSk7dGhpcy50ZXh0dXJlc01hcFtvLnRlbnNvcklkXT1mLHRoaXMucHJvZ3JhbT11fWNhdGNoKG4pe2NvbnNvbGUuZXJyb3IoXCJ3ZWJnbCBjcmVhdGVQcm9ncmFtOiBcIit0Lm5hbWUrXCIgLS0gXCIrbil9cmV0dXJuIHV9LGUucHJvdG90eXBlLnJ1blByb2dyYW09ZnVuY3Rpb24obixlKXt2YXIgdD10aGlzLG89ZnVuY3Rpb24obixlKXtpZigyPT09ZSYmYy5nZXQoXCJwZXJmb3JtYW5jZVwiKSl7dmFyIHQ9bi5nZXRFeHRlbnNpb24oXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXCIpO2lmKCF0KXJldHVybjt2YXIgbz1uLmNyZWF0ZVF1ZXJ5KCk7cmV0dXJuIG4uYmVnaW5RdWVyeSh0LlRJTUVfRUxBUFNFRF9FWFQsbyksb31yZXR1cm4gbnVsbH0odGhpcy5nbCx0aGlzLmdsVmVyc2lvbikscj1uLmlzUGFja2VkT3A7bi5wcm9ncmFtLmZvckVhY2goKGZ1bmN0aW9uKG8saSl7dmFyIHM9bi5vdXRwdXRUZW5zb3JzW2ldLGE9cy50ZW5zb3JJZDt0LnNldE91dFByb3BzKHMpLFwiZnJhbWVCdWZmZXJcIj09PW4uYnVmZmVyVHlwZT90LmF0dGFjaEZyYW1lQnVmZmVyKGEpOnQuYXR0YWNoQ29sb3JCdWZmZXIoKSxvLnNldFByb2dyYW0odC5nbCx0LnZlcnRleEJ1ZmZlcixlKSx0LnByb2dyYW09byx0LnJlbmRlcihuLGUsaSxyKX0pKSxuLnRlbnNvckRhdGE9bnVsbCxvJiYodGhpcy5xdWVyeUxpc3QucHVzaCh7bmFtZTpuLm5hbWUscXVlcnk6byxjb3VudDoxfSksbz1mdW5jdGlvbihuLGUsdCl7aWYoMj09PWUmJmMuZ2V0KFwicGVyZm9ybWFuY2VcIikpe3ZhciBvPW4uZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKTtpZighbylyZXR1cm47bi5lbmRRdWVyeShvLlRJTUVfRUxBUFNFRF9FWFQpfXJldHVybiB0fSh0aGlzLmdsLHRoaXMuZ2xWZXJzaW9uLG8pKX0sZS5wcm90b3R5cGUucmVhZD1mdW5jdGlvbihuKXtyZXR1cm4gSyh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsdCxvLHI7cmV0dXJuIFoodGhpcywoZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpyZXR1cm4gYy5nZXQoXCJ3ZWJnbF9ncHVfcGlwZWxpbmVcIik/KGU9dGhpcy5nbCx0aGlzLmZyYW1lQnVmZmVyPWUuY3JlYXRlRnJhbWVidWZmZXIoKSxlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVCdWZmZXIpLFsyLFtdXSk6KHQ9dGhpcy5jcmVhdGVQQk8oKSxbNCx0aGlzLmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpXSk7Y2FzZSAxOnJldHVybiBpLnNlbnQoKSxvPXRoaXMuZG93bmxvYWRGbG9hdDMyVGVuc29yRnJvbUJ1ZmZlcih0KSxyPW4/bi5zaGFwZTpbXSxjLmdldChcIndlYmdsX3BhY2tfb3V0cHV0XCIpP1syLG8uc2xpY2UoMCxnKHIpKV06WzIsb119fSkpfSkpfSxlLnByb3RvdHlwZS5jcmVhdGVQQk89ZnVuY3Rpb24oKXt2YXIgbixlPXRoaXMudGV4dHVyZUNvbmY7aWYoMj09PXRoaXMuZ2xWZXJzaW9uKXt2YXIgdD10aGlzLmdsLG89dGhpcy5wYm87dC5iaW5kQnVmZmVyKHQuUElYRUxfUEFDS19CVUZGRVIsbyk7dmFyIHI9MTYqdGhpcy53aWR0aF90ZXh0dXJlX291dCp0aGlzLmhlaWdodF90ZXh0dXJlX291dDtyZXR1cm4gdC5idWZmZXJEYXRhKHQuUElYRUxfUEFDS19CVUZGRVIscix0LlNUUkVBTV9SRUFEKSx0LnJlYWRQaXhlbHMoMCwwLHRoaXMud2lkdGhfdGV4dHVyZV9vdXQsdGhpcy5oZWlnaHRfdGV4dHVyZV9vdXQsdC5SR0JBLHQuRkxPQVQsMCksdC5iaW5kQnVmZmVyKHQuUElYRUxfUEFDS19CVUZGRVIsbnVsbCksb312YXIgaT10aGlzLmdsLHM9aS5GTE9BVDtyZXR1cm4gZS5pc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkP249bmV3IEZsb2F0MzJBcnJheSh0aGlzLndpZHRoX3RleHR1cmVfb3V0KnRoaXMuaGVpZ2h0X3RleHR1cmVfb3V0KjQpOihuPW5ldyBVaW50OEFycmF5KHRoaXMud2lkdGhfdGV4dHVyZV9vdXQqdGhpcy5oZWlnaHRfdGV4dHVyZV9vdXQqNCkscz1pLlVOU0lHTkVEX0JZVEUpLGkucmVhZFBpeGVscygwLDAsdGhpcy53aWR0aF90ZXh0dXJlX291dCx0aGlzLmhlaWdodF90ZXh0dXJlX291dCxpLlJHQkEscyxuKSxlLmlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQ/bjpuZXcgRmxvYXQzMkFycmF5KG4uYnVmZmVyKX0sZS5wcm90b3R5cGUuY3JlYXRlQW5kV2FpdEZvckZlbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIEsodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGUsdCxvLHI9dGhpcztyZXR1cm4gWih0aGlzLChmdW5jdGlvbihpKXtyZXR1cm4gbj10aGlzLmdsLGU9bnVsbCE9bi5mZW5jZVN5bmMsdD1mdW5jdGlvbigpe3JldHVybiEwfSxlJiYobz1uLmZlbmNlU3luYyhuLlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFLDApLG4uZmx1c2goKSx0PWZ1bmN0aW9uKCl7dmFyIGU9bi5jbGllbnRXYWl0U3luYyhvLDAsMCk7cmV0dXJuIGU9PT1uLkFMUkVBRFlfU0lHTkFMRUR8fGU9PT1uLkNPTkRJVElPTl9TQVRJU0ZJRUR9KSxbMixuZXcgUHJvbWlzZSgoZnVuY3Rpb24obil7ci5wb2xsSXRlbSh0LG4pfSkpXX0pKX0pKX0sZS5wcm90b3R5cGUucG9sbEl0ZW09ZnVuY3Rpb24obixlKXt2YXIgdD1mdW5jdGlvbigpe24oKT9lKCk6c2V0VGltZW91dCh0LDEpfTt0KCl9LGUucHJvdG90eXBlLmRvd25sb2FkRmxvYXQzMlRlbnNvckZyb21CdWZmZXI9ZnVuY3Rpb24obil7dmFyIGU9NCp0aGlzLndpZHRoX3RleHR1cmVfb3V0KnRoaXMuaGVpZ2h0X3RleHR1cmVfb3V0O2lmKDI9PT10aGlzLmdsVmVyc2lvbil7dmFyIHQ9dGhpcy5nbCxvPW5ldyBGbG9hdDMyQXJyYXkoZSk7dC5iaW5kQnVmZmVyKHQuUElYRUxfUEFDS19CVUZGRVIsbiksdC5nZXRCdWZmZXJTdWJEYXRhKHQuUElYRUxfUEFDS19CVUZGRVIsMCxvKSx0LmJpbmRCdWZmZXIodC5QSVhFTF9QQUNLX0JVRkZFUixudWxsKTt2YXIgcj1bXTtpZihjLmdldChcIndlYmdsX3BhY2tfb3V0cHV0XCIpKXJldHVybiBBcnJheS5mcm9tKG8pO2Zvcih2YXIgaT0wO2k8dGhpcy53aWR0aF90ZXh0dXJlX291dCp0aGlzLmhlaWdodF90ZXh0dXJlX291dDtpKyspci5wdXNoKG9bNCppXSk7cmV0dXJuIHJ9dmFyIHM9bixhPVtdO2ZvcihpPTA7aTx0aGlzLndpZHRoX3RleHR1cmVfb3V0KnRoaXMuaGVpZ2h0X3RleHR1cmVfb3V0O2krKyl7dmFyIHU9dGhpcy50ZXh0dXJlQ29uZi5pc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkPzQqaTppO2EucHVzaChzW3VdKX1yZXR1cm4gYX0sZS5wcm90b3R5cGUuc2V0T3V0UHJvcHM9ZnVuY3Rpb24obil7dmFyIGU9bi53aWR0aF9zaGFwZSx0PXZvaWQgMD09PWU/MTplLG89bi5oZWlnaHRfc2hhcGUscj12b2lkIDA9PT1vPzE6byxpPW4ud2lkdGhfdGV4dHVyZSxzPXZvaWQgMD09PWk/MTppLGE9bi5oZWlnaHRfdGV4dHVyZSx1PXZvaWQgMD09PWE/MTphLGw9bi5jaGFubmVsLGM9dm9pZCAwPT09bD8wOmwsZj1uLnRvdGFsX3NoYXBlLGg9dm9pZCAwPT09Zj8wOmY7dGhpcy53aWR0aF9zaGFwZV9vdXQ9dCx0aGlzLmhlaWdodF9zaGFwZV9vdXQ9cix0aGlzLndpZHRoX3RleHR1cmVfb3V0PXMsdGhpcy5oZWlnaHRfdGV4dHVyZV9vdXQ9dSx0aGlzLmNoYW5uZWw9Yyx0aGlzLnRvdGFsX3NoYXBlPWh9LGUucHJvdG90eXBlLmF0dGFjaENvbG9yQnVmZmVyPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5nbDtuLmJpbmRGcmFtZWJ1ZmZlcihuLkZSQU1FQlVGRkVSLG51bGwpLG4uY2FudmFzLndpZHRoPXRoaXMud2lkdGhfc2hhcGVfb3V0LG4uY2FudmFzLmhlaWdodD10aGlzLmhlaWdodF9zaGFwZV9vdXQsbi52aWV3cG9ydCgwLDAsbi5jYW52YXMud2lkdGgsbi5jYW52YXMuaGVpZ2h0KSxuLnNjaXNzb3IoMCwwLG4uY2FudmFzLndpZHRoLG4uY2FudmFzLmhlaWdodCl9LGUucHJvdG90eXBlLmF0dGFjaEZyYW1lQnVmZmVyPWZ1bmN0aW9uKG4pe3RoaXMuY3VycmVudFRleHR1cmU9dGhpcy50ZXh0dXJlc01hcFtuXTt2YXIgZT10aGlzLmdsO2UuZnJhbWVidWZmZXJUZXh0dXJlMkQoZS5GUkFNRUJVRkZFUixlLkNPTE9SX0FUVEFDSE1FTlQwLGUuVEVYVFVSRV8yRCx0aGlzLmN1cnJlbnRUZXh0dXJlLDApLGUudmlld3BvcnQoMCwwLHRoaXMud2lkdGhfdGV4dHVyZV9vdXQsdGhpcy5oZWlnaHRfdGV4dHVyZV9vdXQpLGUuc2Npc3NvcigwLDAsdGhpcy53aWR0aF90ZXh0dXJlX291dCx0aGlzLmhlaWdodF90ZXh0dXJlX291dCl9LGUucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihuLGUsdCxvKXt2YXIgcj10aGlzO3ZvaWQgMD09PWUmJihlPSExKSx2b2lkIDA9PT1vJiYobz0hMSk7dmFyIGk9bi5pbnB1dFRlbnNvcnMscz12b2lkIDA9PT1pP1tdOmksYT1uLnVuaWZvcm0sdT12b2lkIDA9PT1hP251bGw6YSxsPW4uaUxheWVyLGM9dm9pZCAwPT09bD8wOmwsZj1uLm1vZGVsTmFtZSxoPXRoaXMuZ2wscD0wO3MuZm9yRWFjaCgoZnVuY3Rpb24obil7ci5pbml0VGV4dHVyZShwLG4sbyk7dmFyIGk9ci5nZXRVbmlmb3JtTG9jKFwidGV4dHVyZV9cIituLm5hbWUsYyxlLHQsZik7aSYmaC51bmlmb3JtMWkoaSxwKyspfSkpLHUmJnRoaXMuc2V0VW5pZm9ybSh1LGMsZSx0LGYpLGguZHJhd0FycmF5cyhoLlRSSUFOR0xFX1NUUklQLDAsNCl9LGUucHJvdG90eXBlLmluaXRUZXh0dXJlPWZ1bmN0aW9uKG4sZSx0KXt2YXIgbyxyPXRoaXMuZ2wsaT10aGlzLnRleHR1cmVDb25mLHM9ZS50ZW5zb3JJZCxhPXR8fGUuaXNQYWNrZWQsdT1lLmRhdGE7aWYoZS5wZXJzaXN0YWJsZSl7dGhpcy5jYWNoZVRleHR1cmVzPXRoaXMuY2FjaGVUZXh0dXJlc3x8e307dmFyIGw9dGhpcy5jYWNoZVRleHR1cmVzW3NdO2w/KG89bCx1JiZiLmdlblRleHR1cmVJbmZvRnJvbVRlbnNvclNoYXBlKHRoaXMuTUFYX1RFWFRVUkVfU0laRSxlKSk6KG89ci5jcmVhdGVUZXh0dXJlKCksdGhpcy5jYWNoZVRleHR1cmVzW3NdPW8pfWVsc2Ugbz10aGlzLnRleHR1cmVzTWFwW3NdO3IuYWN0aXZlVGV4dHVyZShyW1wiVEVYVFVSRVwiK25dKSxyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCxvKSx1JiYoVC51cGxvYWREYXRhVG9UZXh0dXJlKHIsaSxlLGEpLGUuZGF0YT1udWxsKX0sZS5wcm90b3R5cGUuc2V0VW5pZm9ybT1mdW5jdGlvbihuLGUsdCxvLHIpe3ZhciBpPXRoaXMscz1PYmplY3Qua2V5cyhuKSxhPXRoaXMuZ2w7cy5mb3JFYWNoKChmdW5jdGlvbihzKXt2YXIgdT1uW3NdLnR5cGUsbD1uW3NdLnZhbHVlLGM9aS5nZXRVbmlmb3JtTG9jKHMsZSx0LG8scik7Yi5zZXRVbmlmb3JtUGFyYW0oYSxjLHUsbCl9KSl9LGUucHJvdG90eXBlLmdldFVuaWZvcm1Mb2M9ZnVuY3Rpb24obixlLHQsbyxyKXt2YXIgaT1yK1wiX1wiO2lmKHQpcmV0dXJuIHRoaXMudW5pZm9ybUxvY2F0aW9uc1tpK2VdW24rb107dmFyIHM9dGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLnByb2dyYW0sbik7cmV0dXJuIHRoaXMudW5pZm9ybUxvY2F0aW9uc1tpK2VdPXRoaXMudW5pZm9ybUxvY2F0aW9uc1tpK2VdfHx7fSx0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbaStlXVtuK29dPXMsc30sZS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe30sZX0oKGZ1bmN0aW9uKCl7fSkpLFE9e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5vcmlnaW4sbz1uLmZpbHRlcixyPW4ub3V0LGk9bi5iaWFzLHM9ZS5ncm91cHMsYT12b2lkIDA9PT1zPzE6cyx1PWUuc3RyaWRlcyxsPXZvaWQgMD09PXU/W106dSxjPWUucGFkZGluZ3MsZj12b2lkIDA9PT1jP1tdOmMsaD1lLmRpbGF0aW9ucyxwPXZvaWQgMD09PWg/W106aCxkPWUuZnVzZV9yZWx1LGc9ZS5maWx0ZXJfbmVhcmVzdF92ZWM0LF89ZS5maWx0ZXJfcmVtYWluZGVyX3ZlYzQsbT1lLmFjdF90eXBlLHY9bFswXSxQPXZvaWQgMD09PXY/MTp2LHg9bFsxXSxiPXZvaWQgMD09PXg/MTp4LFQ9ZlswXSx5PXZvaWQgMD09PVQ/MDpULEY9ZlsxXSx3PXZvaWQgMD09PUY/MDpGLEU9cFswXSxBPXZvaWQgMD09PUU/MTpFLE89cFsxXSxWPXZvaWQgMD09PU8/MTpPO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBpbnQgeCA9IG9Qb3MuYTtcXG4gICAgICAgIGludCBjID0gb1Bvcy5nO1xcbiAgICAgICAgaW50IHkgPSBvUG9zLmI7XFxuICAgICAgICBpbnQgYiA9IG9Qb3MucjtcXG4gICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG5cXG4gICAgICAgIC8vIOiOt+WPlm91dHB1dOeahOWdkOagh1xcbiAgICAgICAgaW50IG9UZW5zb3JDaGFubmVsID0gKGMgLyAoXCIrci5jaGFubmVsK1wiIC8gXCIrYStcIikpICogXCIrby5jaGFubmVsK1wiO1xcbiAgICAgICAgaW50IG95ID0geSAqIFwiK1ArXCIgLSBcIit5K1wiO1xcbiAgICAgICAgZm9yIChpbnQgZnkgPSAwOyBmeSA8IFwiK28uaGVpZ2h0X3NoYXBlK1wiOyBmeSsrKSB7XFxuICAgICAgICAgICAgaWYgKG95ID49IFwiK3QuaGVpZ2h0X3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAob3kgPCAwKSB7XFxuICAgICAgICAgICAgICAgIG95ICs9IFwiK0ErXCI7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgb3ggPSB4ICogXCIrYitcIiAtIFwiK3crXCI7XFxuICAgICAgICAgICAgZm9yIChpbnQgZnggPSAwOyBmeCA8IFwiK28ud2lkdGhfc2hhcGUrXCI7IGZ4KyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKG94ID49IFwiK3Qud2lkdGhfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChveCA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIG94ICs9IFwiK1YrXCI7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBjaGFubmVs6K6h566XXFxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrZytcIjsgaiArPSA0KSB7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGZWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19maWx0ZXIoYywgaiwgZnksIGZ4KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfZmlsdGVyKGMsIGogKyAxLCBmeSwgZngpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19maWx0ZXIoYywgaiArIDIsIGZ5LCBmeCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2ZpbHRlcihjLCBqICsgMywgZnksIGZ4KVxcbiAgICAgICAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgb1ZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihiLCBvVGVuc29yQ2hhbm5lbCArIGosIG95LCBveCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihiLCBvVGVuc29yQ2hhbm5lbCArIGogKyAxLCBveSwgb3gpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oYiwgb1RlbnNvckNoYW5uZWwgKyBqICsgMiwgb3ksIG94KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGIsIG9UZW5zb3JDaGFubmVsICsgaiArIDMsIG95LCBveClcXG4gICAgICAgICAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBkb3QoZlZhbHVlcywgb1ZhbHVlcyk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYgKFwiK18rXCIgPT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGRvdChcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfZmlsdGVyKGMsIFwiK2crXCIsIGZ5LCBmeCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihiLCBvVGVuc29yQ2hhbm5lbCArIFwiK2crXCIsIG95LCBveCkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiK18rXCIgPT0gMikge1xcbiAgICAgICAgICAgICAgICAgICAgdmVjMiBmVmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfZmlsdGVyKGMsIFwiK2crXCIsIGZ5LCBmeCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2ZpbHRlcihjLCBcIitnK1wiICsgMSwgZnksIGZ4KVxcbiAgICAgICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgICAgIHZlYzIgb1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihiLCBvVGVuc29yQ2hhbm5lbCArIFwiK2crXCIsIG95LCBveCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihiLCBvVGVuc29yQ2hhbm5lbCArIFwiK2crXCIgKyAxLCBveSwgb3gpXFxuICAgICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gZG90KGZWYWx1ZXMsIG9WYWx1ZXMpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiK18rXCIgPT0gMykge1xcbiAgICAgICAgICAgICAgICAgICAgdmVjMyBmVmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfZmlsdGVyKGMsIFwiK2crXCIsIGZ5LCBmeCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2ZpbHRlcihjLCBcIitnK1wiICsgMSwgZnksIGZ4KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfZmlsdGVyKGMsIFwiK2crXCIgKyAyLCBmeSwgZngpXFxuICAgICAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICAgICAgdmVjMyBvVmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGIsIG9UZW5zb3JDaGFubmVsICsgXCIrZytcIiwgb3ksIG94KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGIsIG9UZW5zb3JDaGFubmVsICsgXCIrZytcIiArIDEsIG95LCBveCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihiLCBvVGVuc29yQ2hhbm5lbCArIFwiK2crXCIgKyAyLCBveSwgb3gpXFxuICAgICAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGRvdChmVmFsdWVzLCBvVmFsdWVzKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBveCArPSBcIitWK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBveSArPSBcIitBK1wiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrKGk/XCJyZXMgKz0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2JpYXMoMCwgMCwgMCwgYyk7XCI6XCJcIikrXCJcXG5cXG4gICAgICAgIGlmIChcIitkK1wiKSB7XFxuICAgICAgICAgICAgcmVzID0gbWF4KDAuMCwgcmVzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKFwiKyhcInJlbHU2XCI9PT1tKStcIikge1xcbiAgICAgICAgICAgIHJlcyA9IG1pbihtYXgoMC4wLCByZXMpLCA2LjApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlcyk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7ZmlsdGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLGJpYXM6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxiZWhhdmlvcnM6W1wiYWRhcHRQYWRkaW5nc1wiLFwiaXNBcHBseVNlcGFyYWJsZUNvbnZcIixcImJhdGNoQ29tcHV0ZUNvbnYyZFwiLFwicHJvY2Vzc0JpYXNcIl19O2Z1bmN0aW9uICQobixlKXt2YXIgdD1uWzBdLG89blsxXSxyPW5bMl0saT1uWzNdO2lmKDE9PT10JiYxPT09bylyZXR1cm5bWzEsMSxyXSwzLFtpXSwxLFtyLGldXTt2YXIgcz1uLnNsaWNlKDAsZSksYT1uLnNsaWNlKGUpO3JldHVybltzLHMubGVuZ3RoLGEsYS5sZW5ndGgsW3MucmVkdWNlKChmdW5jdGlvbihuLGUpe3JldHVybiBuKmV9KSksYS5yZWR1Y2UoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4qZX0pKV1dfWZ1bmN0aW9uIG5uKG4sZSx0KXtpZigxPT09dClyZXR1cm5cIlxcbiAgICAgICAgICAgIGludCBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9cIituK1wiKGludCBuKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxNb2QobiwgXCIrZVswXStcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCI7dmFyIG89ZChlKTtyZXR1cm4gby5wdXNoKDEpLFwiXFxuICAgIGl2ZWNcIit0K1wiIHNoYXBlVmVjX1wiK24rXCIgPSBpdmVjXCIrdCtcIihcIitvLmpvaW4oXCIsIFwiKStcIik7XFxuICAgIGl2ZWNcIit0K1wiIGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X1wiK24rXCIoaW50IG4pIHtcXG4gICAgICAgIGl2ZWNcIit0K1wiIHBvcztcXG4gICAgICAgIHBvc1swXSA9IG4gLyBzaGFwZVZlY19cIituK1wiWzBdO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBcIit0K1wiOyBpKyspIHtcXG4gICAgICAgICAgICBuID0gY2FsTW9kKG4sIHNoYXBlVmVjX1wiK24rXCJbaSAtIDFdKTtcXG4gICAgICAgICAgICBwb3NbaV0gPSBuIC8gc2hhcGVWZWNfXCIrbitcIltpXTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBwb3M7XFxuICAgIH1cXG4gICAgXCJ9ZnVuY3Rpb24gZW4obil7cmV0dXJuIDE9PT1uP1wiaW50XCI6XCJpdmVjXCIrbn1mdW5jdGlvbiB0bihuKXt2YXIgZT1uLnRvdGFsX3NoYXBlLHQ9bi5jaGFubmVsLG89bi5oZWlnaHRfc2hhcGUscj1uLndpZHRoX3NoYXBlO3JldHVybltlL3Qvby9yLHQsbyxyXX1jb25zdCBvbj17bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm9yaWdpbixvPWUudHJhbnNwb3NlX1gscj12b2lkIDAhPT1vJiZvLGk9ZS50cmFuc3Bvc2VfWSxzPXZvaWQgMCE9PWkmJmksYT1lLnRyYW5zX3gsdT12b2lkIDAhPT1hJiZhLGw9ZS50cmFuc195LGM9cnx8dSxmPXN8fHZvaWQgMCE9PWwmJmw7cmV0dXJuXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpdmVjNCBvdXRfcG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBpdmVjNCBvcmlnaW5fcG9zID0gb3V0X3BvcztcXG4gICAgICAgIGlmIChcIitjK1wiKSB7XFxuICAgICAgICAgICAgb3JpZ2luX3Bvc1szXSA9IG9yaWdpbl9wb3NbMl07XFxuICAgICAgICB9XFxuICAgICAgICBpdmVjNCBjb3VudGVyX3BvcyA9IG91dF9wb3M7XFxuICAgICAgICBpZiAoXCIrZitcIikge1xcbiAgICAgICAgICAgIGNvdW50ZXJfcG9zWzJdID0gY291bnRlcl9wb3NbM107XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiKyhjP3QuaGVpZ2h0X3NoYXBlOnQud2lkdGhfc2hhcGUpK1wiOyBqKyspIHtcXG4gICAgICAgICAgICBpZiAoXCIrYytcIikge1xcbiAgICAgICAgICAgICAgICBvcmlnaW5fcG9zWzJdID0gajtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIG9yaWdpbl9wb3NbM10gPSBqO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoXCIrZitcIikge1xcbiAgICAgICAgICAgICAgICBjb3VudGVyX3Bvc1szXSA9IGo7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBjb3VudGVyX3Bvc1syXSA9IGo7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZsb2F0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9yaWdpbl9wb3NbMF0sIG9yaWdpbl9wb3NbMV0sIG9yaWdpbl9wb3NbMl0sIG9yaWdpbl9wb3NbM10pO1xcbiAgICAgICAgICAgIGZsb2F0IGMgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfY291bnRlcihjb3VudGVyX3Bvc1swXSwgY291bnRlcl9wb3NbMV0sIGNvdW50ZXJfcG9zWzJdLCBjb3VudGVyX3Bvc1szXSk7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgcmVzICs9IGMgKiBvO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KHJlcyk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7Y291bnRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sb3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX19O2Z1bmN0aW9uIHJuKG4sZSl7dmFyIHQ9blswXSxvPW5bMV0scj1uWzJdLGk9blszXTtpZigxPT09dCYmMT09PW8pcmV0dXJuW1sxLDEscl0sMyxbaV0sMSxbcixpXV07dmFyIHM9bi5zbGljZSgwLGUpLGE9bi5zbGljZShlKTtyZXR1cm5bcyxzLmxlbmd0aCxhLGEubGVuZ3RoLFtzLnJlZHVjZSgoZnVuY3Rpb24obixlKXtyZXR1cm4gbiplfSkpLGEucmVkdWNlKChmdW5jdGlvbihuLGUpe3JldHVybiBuKmV9KSldXX1mdW5jdGlvbiBzbihuLGUsdCl7aWYoMT09PXQpcmV0dXJuXCJcXG4gICAgICAgICAgICBpbnQgZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfXCIrbitcIihpbnQgbikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsTW9kKG4sIFwiK2VbMF0rXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIFwiO3ZhciBvPWQoZSk7cmV0dXJuIG8ucHVzaCgxKSxcIlxcbiAgICBpdmVjXCIrdCtcIiBzaGFwZVZlY19cIituK1wiID0gaXZlY1wiK3QrXCIoXCIrby5qb2luKFwiLCBcIikrXCIpO1xcbiAgICBpdmVjXCIrdCtcIiBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9cIituK1wiKGludCBuKSB7XFxuICAgICAgICBpdmVjXCIrdCtcIiBwb3M7XFxuICAgICAgICBwb3NbMF0gPSBuIC8gc2hhcGVWZWNfXCIrbitcIlswXTtcXG4gICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgXCIrdCtcIjsgaSsrKSB7XFxuICAgICAgICAgICAgbiA9IGNhbE1vZChuLCBzaGFwZVZlY19cIituK1wiW2kgLSAxXSk7XFxuICAgICAgICAgICAgcG9zW2ldID0gbiAvIHNoYXBlVmVjX1wiK24rXCJbaV07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcG9zO1xcbiAgICB9XFxuICAgIFwifWZ1bmN0aW9uIGFuKG4pe3JldHVybiAxPT09bj9cImludFwiOlwiaXZlY1wiK259ZnVuY3Rpb24gdW4obil7dmFyIGU9bi50b3RhbF9zaGFwZSx0PW4uY2hhbm5lbCxvPW4uaGVpZ2h0X3NoYXBlLHI9bi53aWR0aF9zaGFwZTtyZXR1cm5bZS90L28vcix0LG8scl19Y29uc3QgbG49e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIHZlYzIgb3V0Q29vcmQgPSB2Q29vcmQueHkgKiAoXzJkX3NoYXBlX3RleHR1cmVfb3V0KTtcXG4gICAgICAgIGludCBpbmRleCA9IGludChvdXRDb29yZC54KSArIGludChvdXRDb29yZC55KSAqIGludChcIituLm91dC53aWR0aF90ZXh0dXJlK1wiKTtcXG4gICAgICAgIGl2ZWM0IG9yaWdpblBvcyA9IGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X29yaWdpbihpbmRleCk7XFxuICAgICAgICBmbG9hdCByZXMgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9yaWdpblBvc1swXSwgb3JpZ2luUG9zWzFdLCBvcmlnaW5Qb3NbMl0sIG9yaWdpblBvc1szXSk7XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhcIixcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX19LGNuPXttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PW4ub3V0LG89bi5vcmlnaW4scj1lLmFsaWduX21vZGUsaT12b2lkIDA9PT1yPzE6cixzPWUuYWxpZ25fY29ybmVycyxhPXZvaWQgMD09PXN8fHM7cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG5cXG4gICAgdmVjNCBnZXREYXRhKGZsb2F0IG4sIGZsb2F0IHNjYWxlLCBib29sIGFsaWduX2ZsYWcsIGludCBpbl9sZW4pIHtcXG4gICAgICAgIGZsb2F0IG0gPSBhbGlnbl9mbGFnID8gKChuICsgMC41KSAvIHNjYWxlIC0gMC41KSA6IChuIC8gc2NhbGUpO1xcbiAgICAgICAgaW50IGExID0gaW50KGZsb29yKG0pKTtcXG4gICAgICAgIGExID0gYTEgPiAwID8gYTEgOiAwO1xcbiAgICAgICAgaW50IGEyID0gKGExICsgMSkgPCAoaW5fbGVuIC0gMSkgPyAoYTEgKyAxKSA6IChpbl9sZW4gLSAxKTtcXG5cXG4gICAgICAgIGZsb2F0IGlkeF9zcmMgPSAobiArIDAuNSkgLyBzY2FsZSAtIDAuNTtcXG4gICAgICAgIGlkeF9zcmMgPSBpZHhfc3JjID4gMC4wID8gaWR4X3NyYyA6IDAuMDtcXG4gICAgICAgIGZsb2F0IGIxID0gYWxpZ25fZmxhZyA/IChpZHhfc3JjIC0gZmxvYXQoYTEpKSA6IChuIC8gc2NhbGUgLSBmbG9hdChhMSkpO1xcbiAgICAgICAgZmxvYXQgYjIgPSAxLjAgLSBiMTtcXG4gICAgICAgIHJldHVybiB2ZWM0KGZsb2F0KGExKSwgZmxvYXQoYTIpLCBiMSwgYjIpO1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG5cXG4gICAgICAgIGJvb2wgYWxpZ25fZmxhZyA9IFwiK2krXCIgPT0gMCAmJiAhXCIrYStcIjtcXG5cXG4gICAgICAgIGZsb2F0IHNjYWxlX3ggPSAwLjA7XFxuICAgICAgICBmbG9hdCBzY2FsZV95ID0gMC4wO1xcbiAgICAgICAgaWYgKFwiK2ErXCIpIHtcXG4gICAgICAgICAgICBzY2FsZV94ID0gZmxvYXQoXCIrdC53aWR0aF9zaGFwZStcIiAtIDEpIC8gZmxvYXQoXCIrby53aWR0aF9zaGFwZStcIiAtIDEpO1xcbiAgICAgICAgICAgIHNjYWxlX3kgPSBmbG9hdChcIit0LmhlaWdodF9zaGFwZStcIiAtIDEpIC8gZmxvYXQoXCIrby5oZWlnaHRfc2hhcGUrXCIgLSAxKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHNjYWxlX3ggPSBmbG9hdChcIit0LndpZHRoX3NoYXBlK1wiKSAvIGZsb2F0KFwiK28ud2lkdGhfc2hhcGUrXCIpO1xcbiAgICAgICAgICAgIHNjYWxlX3kgPSBmbG9hdChcIit0LmhlaWdodF9zaGFwZStcIikgLyBmbG9hdChcIitvLmhlaWdodF9zaGFwZStcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2ZWM0IHZ4ID0gZ2V0RGF0YShmbG9hdChvUG9zLmEpLCBzY2FsZV94LCBhbGlnbl9mbGFnLCBcIitvLndpZHRoX3NoYXBlK1wiKTtcXG4gICAgICAgIHZlYzQgdnkgPSBnZXREYXRhKGZsb2F0KG9Qb3MuYiksIHNjYWxlX3ksIGFsaWduX2ZsYWcsIFwiK28uaGVpZ2h0X3NoYXBlK1wiKTtcXG5cXG4gICAgICAgIGludCB4MSA9IGludCh2eC5yKTtcXG4gICAgICAgIGludCB4MiA9IGludCh2eC5nKTtcXG4gICAgICAgIGZsb2F0IHgzID0gdnguYjtcXG4gICAgICAgIGZsb2F0IHg0ID0gdnguYTtcXG4gICAgICAgIGludCB5MSA9IGludCh2eS5yKTtcXG4gICAgICAgIGludCB5MiA9IGludCh2eS5nKTtcXG4gICAgICAgIGZsb2F0IHkzID0gdnkuYjtcXG4gICAgICAgIGZsb2F0IHk0ID0gdnkuYTtcXG5cXG4gICAgICAgIGZsb2F0IHZhbHVlMTEgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCB5MSwgeDEpO1xcbiAgICAgICAgZmxvYXQgdmFsdWUxMiA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIHkyLCB4MSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZTIxID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgeTEsIHgyKTtcXG4gICAgICAgIGZsb2F0IHZhbHVlMjIgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCB5MiwgeDIpO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSB4NCAqIHk0ICogdmFsdWUxMSArIHg0ICogeTMgKiB2YWx1ZTEyICsgeDMgKiB5NCAqIHZhbHVlMjEgKyB4MyAqIHkzICogdmFsdWUyMjtcXG4gICAgICAgIHNldE91dHB1dChmbG9hdCh2YWx1ZSkpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxmbj1jbjt2YXIgaG49e3JlbHU6W1widHJhbnNUb1ByZWx1XCJdLHJlbHU2OltcInRyYW5zVG9SZWx1NlwiXSxsZWFreV9yZWx1OltcInRyYW5zVG9MZWFreXJlbHVcIl0sdHJhbnNUb0xlYWt5cmVsdTpbXCJ0cmFuc1RvTGVha3lyZWx1XCJdLHNjYWxlOltcInRyYW5zVG9TY2FsZVwiXSxzaWdtb2lkOltcInRyYW5zVG9TaWdtb2lkXCJdLGhhcmRfc2lnbW9pZDpbXCJ0cmFuc1RvSGFyZFNpZ21vaWRcIl0scG93OltcInRyYW5zVG9Qb3dcIl0sc3FydDpbXCJ0cmFuc1RvU3FydFwiXSx0YW5oOltcInRyYW5zVG9UYW5oXCJdfTtmdW5jdGlvbiBwbihuLGUpe3ZhciB0PWUubXVsdGlfdmFsdWUsbz12b2lkIDA9PT10PzE6dCxyPWUuYmlhc192YWx1ZSxpPXZvaWQgMD09PXI/MDpyO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGZsb2F0IG8gPSBnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc19vcmlnaW4odkNvb3JkKS5yO1xcbiAgICAgICAgZmxvYXQgcmVzID0gXCIrZS5hY3RpdmVfZnVuY3Rpb24rXCIobywgZmxvYXQoXCIrbytcIiksIGZsb2F0KFwiK2krXCIpKTtcXG4gICAgICAgIHNldE91dHB1dChyZXMpO1xcbiAgICB9XFxuICAgIFwifWZ1bmN0aW9uIGRuKG4pe3JldHVybnttYWluRnVuYzpwbix0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc1wiXX0sYmVoYXZpb3JzOmhuW25dfX1jb25zdCBnbj17bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1lLmF4ZXMsbz1BcnJheS5pc0FycmF5KHQpP3Q6W3RdLHI9WzAsMSwyLDNdLmZpbHRlcigoZnVuY3Rpb24obil7cmV0dXJuIG4+PW8ubGVuZ3RofSkpO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihcIitbMCwxLDIsM10ubWFwKChmdW5jdGlvbihuKXtyZXR1cm4gby5pbmRleE9mKG4pPi0xPzA6XCJvUG9zW1wiK3Iuc3BsaWNlKDAsMSkrXCJdXCJ9KSkuam9pbihcIixcIikrXCIpO1xcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG8pKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0sX249e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5vcmlnaW4sbz1uLm91dCxyPWUuYWxpZ25fY29ybmVycztyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICBpbnQgZ2V0RGF0YShmbG9hdCBuLCBmbG9hdCBzY2FsZSwgYm9vbCBhbGlnbl9jb3JuZXJzKSB7XFxuICAgICAgICBmbG9hdCBtID0gYWxpZ25fY29ybmVycyA/IChuIC8gc2NhbGUgKyAwLjUpIDogKG4gLyBzY2FsZSk7XFxuICAgICAgICByZXR1cm4gaW50KGZsb29yKG0pKTtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgLy8g6L6T5Ye65pWw5o2uXFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBcXG4gICAgICAgIGZsb2F0IHNjYWxlX3ggPSAwLjA7XFxuICAgICAgICBmbG9hdCBzY2FsZV95ID0gMC4wO1xcbiAgICAgICAgaWYgKFwiK3IrXCIpIHtcXG4gICAgICAgICAgICBzY2FsZV94ID0gZmxvYXQoXCIrby53aWR0aF9zaGFwZStcIiAtMSkgLyBmbG9hdChcIit0LndpZHRoX3NoYXBlK1wiIC0gMSk7XFxuICAgICAgICAgICAgc2NhbGVfeSA9IGZsb2F0KFwiK28uaGVpZ2h0X3NoYXBlK1wiIC0gMSkgLyBmbG9hdChcIit0LmhlaWdodF9zaGFwZStcIiAtIDEpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgc2NhbGVfeCA9IGZsb2F0KFwiK28ud2lkdGhfc2hhcGUrXCIpIC8gZmxvYXQoXCIrdC53aWR0aF9zaGFwZStcIik7XFxuICAgICAgICAgICAgc2NhbGVfeSA9IGZsb2F0KFwiK28uaGVpZ2h0X3NoYXBlK1wiKSAvIGZsb2F0KFwiK3QuaGVpZ2h0X3NoYXBlK1wiKTtcXG4gICAgICAgIH1cXG4gICAgXFxuICAgICAgICBpbnQgdnggPSBnZXREYXRhKGZsb2F0KG9Qb3MuYSksIHNjYWxlX3gsIFwiK3IrXCIpO1xcbiAgICAgICAgaW50IHZ5ID0gZ2V0RGF0YShmbG9hdChvUG9zLmIpLCBzY2FsZV95LCBcIityK1wiKTtcXG4gICAgICAgIFxcbiAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIHZ5LCB2eCk7XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbn1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sY29tbW9uRnVuY0NvbmY6W1widHJhbnNmZXJGcm9tTkhXQ3RvTkNIV1wiXX07dmFyIG1uPWZ1bmN0aW9uKCl7Zm9yKHZhciBuPTAsZT0wLHQ9YXJndW1lbnRzLmxlbmd0aDtlPHQ7ZSsrKW4rPWFyZ3VtZW50c1tlXS5sZW5ndGg7dmFyIG89QXJyYXkobikscj0wO2ZvcihlPTA7ZTx0O2UrKylmb3IodmFyIGk9YXJndW1lbnRzW2VdLHM9MCxhPWkubGVuZ3RoO3M8YTtzKysscisrKW9bcl09aVtzXTtyZXR1cm4gb307Y29uc3Qgdm49e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5vcmlnaW4sbz1uLmltYWdlLHI9bi5vdXQsaT1lLnZhcmlhbmNlcyxzPXZvaWQgMD09PWk/Wy4xLC4xLC4yLC4yXTppLGE9ZS5maXhlZF9zaXplcyx1PWUuZml4ZWRfcmF0aW9zLGw9ZS5kZW5zaXRpZXMsYz1lLmZsYXR0ZW5fdG9fMmQsZj1lLmNsaXAsaD1lLnN0ZXBfdyxwPXZvaWQgMD09PWg/MDpoLGc9ZS5zdGVwX2gsXz12b2lkIDA9PT1nPzA6Zyx2PWUub2Zmc2V0LFA9dm9pZCAwPT09dj8uNTp2LHg9ZS5ydW50aW1lLGI9dm9pZCAwPT09eD8wOngsVD1vLmhlaWdodF9zaGFwZSx5PW8ud2lkdGhfc2hhcGUsRj10LmhlaWdodF9zaGFwZSx3PXQud2lkdGhfc2hhcGUsRT1yLnRvdGFsX3NoYXBlLEE9ci5jaGFubmVsLE89ci5oZWlnaHRfc2hhcGUsVj1yLndpZHRoX3NoYXBlLEM9RS9BL08vVixTPWQoW0MsQSxPLFZdKSxrPXAsUj1fOzAhPT1wJiYwIT09X3x8KGs9eS93LFI9VC9GKTt2YXIgST1NYXRoLnJvdW5kKC41KihrK1IpKSxNPXUubWFwKChmdW5jdGlvbihuKXtyZXR1cm4gTWF0aC5zcXJ0KG4pfSkpLEw9MT09PU0ubGVuZ3RoP1wic3FydF9maXhlZF9yYXRpb3NcIjpcInNxcnRfZml4ZWRfcmF0aW9zW3JdXCIsaj11Lmxlbmd0aCxEPU8sTj1DLEI9QTtjJiYoTj1GLEI9dyxEPU8vRi93KTt2YXIgRz1kKFtOLEIsRCxWXSksVz1VKFwib3V0MVwiLHtudW1iZXJzX3NoYXBlOm1uKEcsWzFdKSxsZW5ndGhfc2hhcGU6NH0pLEg9bC5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybiBuKm4qan0pKSxYPUgubGVuZ3RoLHo9ZnVuY3Rpb24obil7dmFyIGU9XCJpdmVjMiBjYWxSZW1haW4oaW50IHJlbWFpbiwgaW50IGN1ckFjY0luZGV4LCBpbnQgcykge1wiLHQ9bi5sZW5ndGg7aWYoMT09PXQpZSs9XCJcXG4gICAgICAgICAgICBpbnQgYWNjSW5kZXgwID0gZGVuc2l0eV9hY2Nfc2hhcGU7XFxuXFxuICAgICAgICAgICAgaWYgKHJlbWFpbiA+PSBhY2NJbmRleDApIHtcXG4gICAgICAgICAgICAgICAgcysrO1xcbiAgICAgICAgICAgICAgICByZW1haW4gLT0gYWNjSW5kZXgwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl2ZWMyKHJlbWFpbiwgcyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFwiO2Vsc2UgZm9yKHZhciBvPTA7bzx0O28rKyllKz1cIlxcbiAgICAgICAgICAgIGludCBhY2NJbmRleFwiK28rXCIgPSBkZW5zaXR5X2FjY19zaGFwZVtcIitvK1wiXTtcXG5cXG4gICAgICAgICAgICBpZiAocmVtYWluID49IGFjY0luZGV4XCIrbytcIikge1xcbiAgICAgICAgICAgICAgICBzKys7XFxuICAgICAgICAgICAgICAgIHJlbWFpbiAtPSBhY2NJbmRleFwiK28rXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gaXZlYzIocmVtYWluLCBzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXCI7cmV0dXJuIGUrXCJcXG4gICAgfVxcbiAgICBcIn0oSCkscT1mP1widiA9IG1pbihtYXgodiwgMC4pLCAxLik7XCI6XCJcIixZPTE9PT1YP1wiZGVuc2l0eV9hY2Nfc2hhcGVcIjpcImRlbnNpdHlfYWNjX3NoYXBlWzBdXCIsSz1cIlxcbiAgICBmbG9hdCBnZXRGbG9hdDRUZW5zb3JWYWwodmVjNCB0ZW5zb3IsIGludCBpbmRleCkge1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzBdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMSkge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMV07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAyKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclsyXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDMpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzNdO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGZsb2F0IGdldEZsb2F0M1RlbnNvclZhbCh2ZWMzIHRlbnNvciwgaW50IGluZGV4KSB7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMF07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAxKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclsxXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDIpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzJdO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGZsb2F0IGdldEZsb2F0MlRlbnNvclZhbCh2ZWMyIHRlbnNvciwgaW50IGluZGV4KSB7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMF07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAxKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclsxXTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBmbG9hdCBnZXRGbG9hdDFUZW5zb3JWYWwoZmxvYXQgdGVuc29yLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiB0ZW5zb3I7XFxuICAgIH1cXG4gICAgaW50IGdldEludDRUZW5zb3JWYWwoaXZlYzQgdGVuc29yLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGlmIChpbmRleCA9PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclswXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzFdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMikge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMl07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAzKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclszXTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpbnQgZ2V0SW50M1RlbnNvclZhbChpdmVjMyB0ZW5zb3IsIGludCBpbmRleCkge1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzBdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMSkge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMV07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAyKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclsyXTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpbnQgZ2V0SW50MlRlbnNvclZhbChpdmVjMiB0ZW5zb3IsIGludCBpbmRleCkge1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzBdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMSkge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMV07XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgaW50IGdldEludDFUZW5zb3JWYWwoaW50IHRlbnNvciwgaW50IGluZGV4KSB7XFxuICAgICAgIHJldHVybiB0ZW5zb3I7XFxuICAgIH1cXG5cXG4gICAgXCIrVytcIlxcbiAgICBcXG4gICAgICAgIFwiK20obCxcImRlbnNpdGllc1wiKStcIlxcbiAgICAgICAgXCIrbShhLFwiZml4ZWRfc2l6ZXNcIikrXCJcXG4gICAgICAgIFwiK20oTSxcInNxcnRfZml4ZWRfcmF0aW9zXCIpK1wiXFxuICAgICAgICBcIitmdW5jdGlvbihuLGUpe2lmKDE9PT1uLmxlbmd0aClyZXR1cm5cImludCBcIitlK1wiID0gaW50KFwiK25bMF0rXCIpO1wiO2Zvcih2YXIgdD1uLmxlbmd0aCxvPVwiXFxuICAgICAgICBpdmVjXCIrdCtcIiBcIitlK1wiID0gaXZlY1wiK3QrXCIoXFxuICAgIFwiLHI9MDtyPHQ7cisrKW8rPW5bcl0rXCIsXCI7cmV0dXJuIG8uc2xpY2UoMCwtMSkrXCIpO1wifShILFwiZGVuc2l0eV9hY2Nfc2hhcGVcIikrXCJcXG4gICAgXFxuICAgIFwiK3orXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGludCByciA9IGludChvUG9zLnIpO1xcbiAgICAgICAgaW50IGdnID0gaW50KG9Qb3MuZyk7XFxuICAgICAgICBpbnQgYmIgPSBpbnQob1Bvcy5iKTtcXG4gICAgICAgIGludCBhYSA9IGludChvUG9zLmEpO1xcblxcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBpbnQgaW5kZXggPSByciAqIFwiK1NbMF0rXCIgKyBnZyAqIFwiK1NbMV0rXCIgKyBiYiAqIFwiK1NbMl0rXCIgKyBhYTtcXG4gICAgICAgIGl2ZWM0IHJlYWxPdXRQb3MgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9vdXQxKGluZGV4KTtcXG4gICAgICAgIGludCBoID0gcmVhbE91dFBvcy5yO1xcbiAgICAgICAgaW50IHcgPSByZWFsT3V0UG9zLmc7XFxuICAgICAgICBpbnQgYiA9IHJlYWxPdXRQb3MuYjtcXG4gICAgICAgIGludCBhID0gcmVhbE91dFBvcy5hO1xcbiAgICBcIjtyZXR1cm4gMT09PWI/XCJcXG4gICAgICAgIFwiK20ocyxcInZhcmlhbmNlc1wiKStcIlxcbiAgICAgICAgXCIrSytcIlxcbiAgICAgICAgc2V0T3V0cHV0KGdldEZsb2F0NFRlbnNvclZhbCh2YXJpYW5jZXMsIGFhKSk7XFxuICAgICAgICB9XCI6XCJcXG4gICAgICAgICAgICBcIitLK1wiXFxuICAgICAgICAgICAgLy8g5rGCaWR4IOWvueW6lOeahCBzLCByLCBkaSwgZGpcXG4gICAgICAgICAgICBpbnQgcyA9IDA7XFxuICAgICAgICAgICAgaW50IHJlbWFpbiA9IGI7XFxuICAgICAgICAgICAgaW50IGN1ckFjY0luZGV4ID0gXCIrWStcIjtcXG5cXG4gICAgICAgICAgICBpdmVjMiByZW1haW5JbmZvID0gY2FsUmVtYWluKHJlbWFpbiwgY3VyQWNjSW5kZXgsIHMpO1xcbiAgICAgICAgICAgIHJlbWFpbiA9IHJlbWFpbkluZm9bMF07XFxuICAgICAgICAgICAgcyA9IHJlbWFpbkluZm9bMV07XFxuICAgICAgICAgICAgaW50IGRlbnNpdHkgPSBpbnQoZ2V0RmxvYXRcIitsLmxlbmd0aCtcIlRlbnNvclZhbChkZW5zaXRpZXMsIHMpKTtcXG4gICAgICAgICAgICBpbnQgciA9IGludChmbG9vcihmbG9hdChyZW1haW4gLyBkZW5zaXR5IC8gZGVuc2l0eSkpKTtcXG4gICAgICAgICAgICByZW1haW4gLT0gciAqIGRlbnNpdHkgKiBkZW5zaXR5O1xcblxcbiAgICAgICAgICAgIGZsb2F0IGRpID0gZmxvb3IoZmxvYXQocmVtYWluIC8gZGVuc2l0eSkpO1xcbiAgICAgICAgICAgIGZsb2F0IGRqID0gZmxvYXQocmVtYWluIC0gaW50KGRpKSAqIGRlbnNpdHkpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGNlbnRlcl94ID0gKGZsb2F0KHcpICsgZmxvYXQoXCIrUCtcIikpICogZmxvYXQoXCIraytcIik7XFxuICAgICAgICAgICAgZmxvYXQgY2VudGVyX3kgPSAoZmxvYXQoaCkgKyBmbG9hdChcIitQK1wiKSkgKiBmbG9hdChcIitSK1wiKTtcXG4gICAgICAgICAgICBmbG9hdCBmaXhlZF9zaXplID0gZ2V0RmxvYXRcIithLmxlbmd0aCtcIlRlbnNvclZhbChmaXhlZF9zaXplcywgcyk7XFxuICAgICAgICAgICAgZmxvYXQgc2hpZnQgPSBmbG9hdChcIitJK1wiKSAvIGZsb2F0KGRlbnNpdHkpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IHYgPSAwLjA7XFxuICAgICAgICAgICAgaWYgKGEgPT0gMCB8fCBhID09IDIpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgYm94X3dpZHRoX3JhdGlvID0gZml4ZWRfc2l6ZSAqIFwiK0wrXCI7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGRlbnNpdHlfY2VudGVyX3ggPSBjZW50ZXJfeCAtIGZsb2F0KFwiK0krXCIpIC8gMi4gKyBzaGlmdCAvIDIuO1xcbiAgICAgICAgICAgICAgICBmbG9hdCBjZW50ZXJfeF90ZW1wID0gZGVuc2l0eV9jZW50ZXJfeCArIGRqICogc2hpZnQ7XFxuICAgICAgICAgICAgICAgIGlmIChhID09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHYgPSBtYXgoKGNlbnRlcl94X3RlbXAgLSBib3hfd2lkdGhfcmF0aW8gLyAyLikgLyBmbG9hdChcIit5K1wiKSwgMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdiA9IG1pbigoY2VudGVyX3hfdGVtcCArIGJveF93aWR0aF9yYXRpbyAvIDIuKSAvIGZsb2F0KFwiK3krXCIpLCAxLik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGJveF9oZWlnaHRfcmF0aW8gPSBmaXhlZF9zaXplIC8gXCIrTCtcIjtcXG4gICAgICAgICAgICAgICAgZmxvYXQgZGVuc2l0eV9jZW50ZXJfeSA9IGNlbnRlcl95IC0gZmxvYXQoXCIrSStcIikgLyAyLiArIHNoaWZ0IC8gMi47XFxuICAgICAgICAgICAgICAgIGZsb2F0IGNlbnRlcl95X3RlbXAgPSBkZW5zaXR5X2NlbnRlcl95ICsgZGkgKiBzaGlmdDtcXG4gICAgICAgICAgICAgICAgaWYgKGEgPT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgdiA9IG1heCgoY2VudGVyX3lfdGVtcCAtIGJveF9oZWlnaHRfcmF0aW8gLyAyLikgLyBmbG9hdChcIitUK1wiKSwgMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdiA9IG1pbigoY2VudGVyX3lfdGVtcCArIGJveF9oZWlnaHRfcmF0aW8gLyAyLikgLyBmbG9hdChcIitUK1wiKSwgMS4pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIFwiK3ErXCJcXG5cXG4gICAgICAgICAgICBzZXRPdXRwdXQodik7XFxuICAgICAgICB9XFxuICAgICAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntpbWFnZTpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sb3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX19LFBuPXttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PW4ub3JpZ2luLG89bi5pbWFnZSxyPW4ub3V0LGk9ZS52YXJpYW5jZXMscz12b2lkIDA9PT1pP1suMSwuMSwuMiwuMl06aSxhPWUuZmxpcCx1PWUuY2xpcCxsPWUuc3RlcF93LGM9dm9pZCAwPT09bD8wOmwsZj1lLnN0ZXBfaCxoPXZvaWQgMD09PWY/MDpmLHA9ZS5vZmZzZXQsZD12b2lkIDA9PT1wPy41OnAsZz1lLnJ1bnRpbWUsdj12b2lkIDA9PT1nPzA6ZyxQPWUubWluX3NpemVzLHg9dm9pZCAwPT09UD9bXTpQLGI9ZS5tYXhfc2l6ZXMsVD12b2lkIDA9PT1iP1tdOmIseT1lLmFzcGVjdF9yYXRpb3MsRj12b2lkIDA9PT15P1tdOnksdz1lLm1pbl9tYXhfYXNwZWN0X3JhdGlvc19vcmRlcixFPXZvaWQgMCE9PXcmJncsQT1vLmhlaWdodF9zaGFwZSxPPW8ud2lkdGhfc2hhcGUsVj10LmhlaWdodF9zaGFwZSxDPXQud2lkdGhfc2hhcGUsUz1yLmNoYW5uZWwsaz1yLmhlaWdodF9zaGFwZSxSPWMsST1oOzAhPT1jJiYwIT09aHx8KFI9Ty9DLEk9QS9WKTt2YXIgTT1bMV07Ri5mb3JFYWNoKChmdW5jdGlvbihuKXsxIT09biYmKE0ucHVzaChNYXRoLnNxcnQobikpLGEmJk0ucHVzaChNYXRoLnNxcnQoMS9uKSkpfSkpO3ZhciBMPU0ubGVuZ3RoLGo9dT9cInJlcyA9IG1pbihtYXgocmVzLCAwLiksIDEuKTtcIjpcIlwiLEQ9XCJcXG4gICAgZmxvYXQgZ2V0RmxvYXQ0VGVuc29yVmFsKHZlYzQgdGVuc29yLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGlmIChpbmRleCA9PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclswXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGVuc29yWzFdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gMikge1xcbiAgICAgICAgICAgIHJldHVybiB0ZW5zb3JbMl07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAzKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvclszXTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgaW50IG5uID0gaW50KG9Qb3Mucik7XFxuICAgICAgICBpbnQgY2MgPSBpbnQob1Bvcy5nKTtcXG4gICAgICAgIGludCBoaCA9IGludChvUG9zLmIpO1xcbiAgICAgICAgaW50IHd3ID0gaW50KG9Qb3MuYSk7XFxuXFxuXFxuICAgICAgICBcXG4gICAgICAgIFwiK18oeCxcIm1pbl9zaXplc1wiKStcIlxcbiAgICAgICAgXCIrXyhULFwibWF4X3NpemVzXCIpK1wiXFxuICAgICAgICBcIitfKE0sXCJhc3BlY3RfcmF0aW9zXCIpK1wiXFxuICAgIFxcblxcbiAgICBcIjtyZXR1cm4gMT09PXY/XCJcXG4gICAgICAgICAgICBcIittKHMsXCJ2YXJpYW5jZXNcIikrXCJcXG4gICAgICAgICAgICBcIitEK1wiXFxuICAgICAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgICAgIHJlcyA9IGdldEZsb2F0NFRlbnNvclZhbCh2YXJpYW5jZXMsIHd3KTtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQocmVzKSk7XFxuICAgICAgICB9XCI6XCJcXG4gICAgICAgICAgICBcIitEK1wiXFxuICAgICAgICAgICAgaW50IGlkeCA9IG5uICogXCIrUyprK1wiICsgY2MgKiBcIitrK1wiICsgaGg7XFxuICAgICAgICAgICAgaW50IGFzX251bSA9IFwiK0wrXCI7XFxuICAgICAgICAgICAgZmxvYXQgb2Zmc2V0ID0gXCIrZCtcIjtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBpbnQgZmVhdHVyZV93aWR0aCA9IFwiK0MrXCI7XFxuICAgICAgICAgICAgaW50IG51bV9wcmlvcnMgPSBcIitrK1wiO1xcbiAgICAgICAgICAgIGZsb2F0IHN0ZXBfd2lkdGggPSBmbG9hdChcIitSK1wiKTtcXG4gICAgICAgICAgICBmbG9hdCBzdGVwX2hlaWdodCA9IGZsb2F0KFwiK0krXCIpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGltX3dpZHRoID0gZmxvYXQoXCIrTytcIik7XFxuICAgICAgICAgICAgZmxvYXQgaW1faGVpZ2h0ID0gZmxvYXQoXCIrQStcIik7XFxuXFxuICAgICAgICAgICAgYm9vbCBtaW5fbWF4X2FzcGVjdF9yYXRpb3Nfb3JkZXIgPSBcIitFK1wiO1xcblxcbiAgICAgICAgICAgIC8vIOaxgmlkeCDlr7nlupTnmoQgaCB3IHAgbVxcbiAgICAgICAgICAgIGludCBoID0gaW50KGlkeCAvIChudW1fcHJpb3JzICogZmVhdHVyZV93aWR0aCkpO1xcbiAgICAgICAgICAgIGludCB3ID0gKGlkeCAvIG51bV9wcmlvcnMpICUgZmVhdHVyZV93aWR0aDtcXG4gICAgICAgICAgICBpbnQgcCA9IGlkeCAlIG51bV9wcmlvcnM7XFxuICAgICAgICAgICAgaW50IG0gPSBcIisoVC5sZW5ndGg+MCkrXCIgPyBpbnQocCAvIChhc19udW0gKyAxKSkgOiBpbnQocCAvIGFzX251bSk7XFxuICAgICAgICAgICAgZmxvYXQgY3ggPSAoZmxvYXQodykgKyBvZmZzZXQpICogc3RlcF93aWR0aDtcXG4gICAgICAgICAgICBmbG9hdCBjeSA9IChmbG9hdChoKSArIG9mZnNldCkgKiBzdGVwX2hlaWdodDtcXG4gICAgICAgICAgICBmbG9hdCBtaW5fc2l6ZSA9IGZsb2F0KG1pbl9zaXplc1ttXSk7XFxuICAgICAgICAgICAgZmxvYXQgYncgPSAwLjA7XFxuICAgICAgICAgICAgZmxvYXQgYmggPSAwLjA7XFxuXFxuICAgICAgICAgICAgXCIrKFQubGVuZ3RoPjA/XCJcXG4gICAgICAgICAgICBpbnQgcyA9IHAgJSAoYXNfbnVtICsgMSk7XFxuICAgICAgICAgICAgaWYgKFwiKyFFK1wiKSB7XFxuICAgICAgICAgICAgICAgIGlmIChzIDwgYXNfbnVtKSB7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBhciA9IGFzcGVjdF9yYXRpb3Nbc107XFxuICAgICAgICAgICAgICAgICAgICBidyA9IG1pbl9zaXplICogYXIgLyAyLjA7XFxuICAgICAgICAgICAgICAgICAgICBiaCA9IG1pbl9zaXplIC8gYXIgLyAyLjA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBtYXhfc2l6ZSA9IGZsb2F0KG1heF9zaXplc1ttXSk7XFxuICAgICAgICAgICAgICAgICAgICBidyA9IHNxcnQobWluX3NpemUgKiBtYXhfc2l6ZSkgLyAyLjA7XFxuICAgICAgICAgICAgICAgICAgICBiaCA9IGJ3O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBpZiAocyA9PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBiaCA9IG1pbl9zaXplIC8gMi4wO1xcbiAgICAgICAgICAgICAgICAgICAgYncgPSBiaDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG1heF9zaXplID0gZmxvYXQobWF4X3NpemVzW21dKTtcXG4gICAgICAgICAgICAgICAgICAgIGJ3ID0gc3FydChtaW5fc2l6ZSAqIG1heF9zaXplKSAvIDIuMDtcXG4gICAgICAgICAgICAgICAgICAgIGJoID0gYnc7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBhciA9IGFzcGVjdF9yYXRpb3NbcyAtIDFdO1xcbiAgICAgICAgICAgICAgICAgICAgYncgPSBtaW5fc2l6ZSAqIHNxcnQoYXIpIC8gMi4wO1xcbiAgICAgICAgICAgICAgICAgICAgYmggPSBtaW5fc2l6ZSAvIHNxcnQoYXIpIC8gMi4wO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVwiOlwiXFxuICAgICAgICAgICAgaW50IHMgPSBwICUgYXNfbnVtO1xcbiAgICAgICAgICAgIGZsb2F0IGFyID0gYXNwZWN0X3JhdGlvc1tzXTtcXG4gICAgICAgICAgICBidyA9IG1pbl9zaXplICogYXIgLyAyLjA7XFxuICAgICAgICAgICAgYmggPSBtaW5fc2l6ZSAvIGFyIC8gMi4wO1xcbiAgICAgICAgXCIpK1wiXFxuICAgICAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgICAgIGlmICh3dyA9PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJlcyA9IChjeCAtIGJ3KSAvIGltX3dpZHRoO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmICh3dyA9PSAxKSB7XFxuICAgICAgICAgICAgICAgIHJlcyA9IChjeSAtIGJoKSAvIGltX2hlaWdodDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAod3cgPT0gMikge1xcbiAgICAgICAgICAgICAgICByZXMgPSAoY3ggKyBidykgLyBpbV93aWR0aDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJlcyA9IChjeSArIGJoKSAvIGltX2hlaWdodDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgXCIraitcIlxcblxcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChyZXMpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e2ltYWdlOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxiZWhhdmlvcnM6W119O3ZhciB4bj17YXJnX21heDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm9yaWdpbixvPWUuYXhpcyxyPXZvaWQgMD09PW8/LTE6byxpPWUuZmxhdHRlbixzPXQudG90YWxfc2hhcGUsYT10LmhlaWdodF9zaGFwZSx1PXQud2lkdGhfc2hhcGUsbD10LmNoYW5uZWwsYz10Lmxlbmd0aF91bmZvcm1hdHRlZF9zaGFwZSxmPXMvKHUqYSpsKSxoPXI8MD8zOjQtYytyLHA9W2YsbCxhLHVdW2hdO3JldHVyblwiXFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBpbnQgcG9zID0gMDtcXG4gICAgICAgIGlmIChcIishaStcIikge1xcbiAgICAgICAgICAgIGlmIChcIitoK1wiID09IDEpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgdG1wID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLmcsIDAsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IFwiK3ArXCI7IGluZGV4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgaW5kZXgsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvID4gdG1wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbztcXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmRleDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChcIitoK1wiID09IDIpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgdG1wID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLmcsIG9Qb3MuYiwgMCwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IFwiK3ArXCI7IGluZGV4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgb1Bvcy5iLCBpbmRleCwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvID4gdG1wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbztcXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmRleDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChcIitoK1wiID09IDMpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgdG1wID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hLCAwKTtcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IFwiK3ArXCI7IGluZGV4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEsIGluZGV4KTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvID4gdG1wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbztcXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmRleDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgdG1wID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbigwLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IFwiK3ArXCI7IGluZGV4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGluZGV4LCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvID4gdG1wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbztcXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmRleDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGludCBpbmRleCA9IDA7XFxuICAgICAgICAgICAgZmxvYXQgdG1wID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbigwLCAwLCAwLCAwKTtcXG4gICAgICAgICAgICBmb3IgKGludCBuID0gMDsgbiA8IFwiK2YrXCI7IG4rKykge1xcbiAgICAgICAgICAgICAgICBmb3IgKGludCBjID0gMDsgYyA8IFwiK2wrXCI7IGMrKykge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaCA9IDA7IGggPCBcIithK1wiOyBoKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCB3ID0gMDsgdyA8IFwiK3UrXCI7IHcrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihuLCBjLCBoLCB3KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8gPiB0bXApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG87XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmRleDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChwb3MpKTtcXG4gICAgfVwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxhcmdfbWluOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe2Zvcih2YXIgdD1uLm9yaWdpbixvPWUuYXhpcyxyPXZvaWQgMD09PW8/LTE6byxpPWUuZmxhdHRlbixzPXQudG90YWxfc2hhcGUsYT10LmhlaWdodF9zaGFwZSx1PXQud2lkdGhfc2hhcGUsbD10LmNoYW5uZWwsYz1zLyh1KmEqbCksZj1bYyxsLGEsdV0saD0wLHA9MDtwPDQmJiEoZltwXT4xKTtwKyspaCsrO3ZhciBkPXI8MD80LWgrcjpyLGc9ZltkPWgrZF07cmV0dXJuXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgZmxvYXQgbyA9IDAuMDtcXG4gICAgICAgIGludCBwb3MgPSAwO1xcbiAgICAgICAgaWYgKFwiKyFpK1wiKSB7XFxuICAgICAgICAgICAgaWYgKFwiK2QrXCIgPT0gMSkge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB0bXAgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgMCwgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpbmRleCA9IDA7IGluZGV4IDwgXCIrZytcIjsgaW5kZXgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5nLCBpbmRleCwgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPCB0bXApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBvO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGluZGV4O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKFwiK2QrXCIgPT0gMikge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB0bXAgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgb1Bvcy5iLCAwLCBvUG9zLmEpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpbmRleCA9IDA7IGluZGV4IDwgXCIrZytcIjsgaW5kZXgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5nLCBvUG9zLmIsIGluZGV4LCBvUG9zLmEpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPCB0bXApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBvO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGluZGV4O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKFwiK2QrXCIgPT0gMykge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB0bXAgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEsIDApO1xcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpbmRleCA9IDA7IGluZGV4IDwgXCIrZytcIjsgaW5kZXgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSwgaW5kZXgpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPCB0bXApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBvO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGluZGV4O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9ICAgICBcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHRtcCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oMCwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICAgICAgICAgIGZvciAoaW50IGluZGV4ID0gMDsgaW5kZXggPCBcIitnK1wiOyBpbmRleCsrKSB7XFxuICAgICAgICAgICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihpbmRleCwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAobyA8IHRtcCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG87XFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gaW5kZXg7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xcbiAgICAgICAgICAgIGZsb2F0IHRtcCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oMCwgMCwgMCwgMCk7XFxuICAgICAgICAgICAgZm9yIChpbnQgbiA9IDA7IG4gPCBcIitjK1wiOyBuKyspIHtcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgYyA9IDA7IGMgPCBcIitsK1wiOyBjKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGggPSAwOyBoIDwgXCIrYStcIjsgaCsrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgdyA9IDA7IHcgPCBcIit1K1wiOyB3KyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4obiwgYywgaCwgdyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvIDwgdG1wKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBvO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gaW5kZXg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQocG9zKSk7XFxuICAgIH1cIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0sY29udjJkOlEsY29udjJkX3BhY2tpbmc6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5vcmlnaW4sbz1uLmZpbHRlcixyPW4ub3V0LGk9bi5iaWFzLHM9ZS5ncm91cHMsYT12b2lkIDA9PT1zPzE6cyx1PWUuc3RyaWRlcyxsPXZvaWQgMD09PXU/W106dSxjPWUucGFkZGluZ3MsZj12b2lkIDA9PT1jP1tdOmMsaD1lLmRpbGF0aW9ucyxwPXZvaWQgMD09PWg/W106aCxkPWUuZnVzZV9yZWx1LGc9ZS5hY3RfdHlwZSxfPWxbMF0sbT12b2lkIDA9PT1fPzE6Xyx2PWxbMV0sUD12b2lkIDA9PT12PzE6dix4PWZbMF0sYj12b2lkIDA9PT14PzA6eCxUPWZbMV0seT12b2lkIDA9PT1UPzA6VCxGPXBbMF0sdz12b2lkIDA9PT1GPzE6RixFPXBbMV0sQT12b2lkIDA9PT1FPzE6RTtyZXR1cm5cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBpbnQgeCA9IG9Qb3MuYTtcXG4gICAgICAgIGludCBjID0gb1Bvcy5nO1xcbiAgICAgICAgaW50IHkgPSBvUG9zLmI7XFxuICAgICAgICBpbnQgYiA9IG9Qb3MucjtcXG4gICAgICAgIHZlYzQgcmVzID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcblxcbiAgICAgICAgaW50IG95ID0geSAqIFwiK20rXCIgLSBcIitiK1wiO1xcbiAgICAgICAgZm9yIChpbnQgZnkgPSAwOyBmeSA8IFwiK28uaGVpZ2h0X3NoYXBlK1wiOyBmeSsrKSB7XFxuICAgICAgICAgICAgaWYgKG95ID49IFwiK3QuaGVpZ2h0X3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAob3kgPCAwKSB7XFxuICAgICAgICAgICAgICAgIG95ICs9IFwiK3crXCI7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgb3ggPSB4ICogXCIrUCtcIiAtIFwiK3krXCI7XFxuICAgICAgICAgICAgZm9yIChpbnQgZnggPSAwOyBmeCA8IFwiK28ud2lkdGhfc2hhcGUrXCI7IGZ4KyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKG94ID49IFwiK3Qud2lkdGhfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChveCA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIG94ICs9IFwiK0ErXCI7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBjaGFubmVs6K6h566XXFxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrby5jaGFubmVsK1wiOyBqICs9IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIGludCBjMCA9IChjIC8gKFwiK3IuY2hhbm5lbCtcIiAqIDQgLyBcIithK1wiKSkgKiBcIitvLmNoYW5uZWwrXCIgKyBqO1xcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBmVmFsdWUgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nX2ZpbHRlcihjICogNCwgaiwgZnksIGZ4KTtcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgb1ZhbHVlID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2luZ19vcmlnaW4oYiwgYzAsIG95LCBveCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBwYWNrZWRfaW5kZXggPSAwOyBwYWNrZWRfaW5kZXggPCA0OyBwYWNrZWRfaW5kZXgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWNrZWRfaW5kZXggPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuciArPSBkb3QoZlZhbHVlLCBvVmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFja2VkX2luZGV4ID09IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IGMxID0gKChjICsgMSkgLyAoXCIrci5jaGFubmVsK1wiICogNCAvIFwiK2ErXCIpKSAqIFwiK28uY2hhbm5lbCtcIiArIGo7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9WYWx1ZSA9IGdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdfb3JpZ2luKGIsIGMxLCBveSwgb3gpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmVmFsdWUgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nX2ZpbHRlcihjICogNCArIDEsIGosIGZ5LCBmeCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5nICs9IGRvdChmVmFsdWUsIG9WYWx1ZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYWNrZWRfaW5kZXggPT0gMikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgYzIgPSAoKGMgKyAyKSAvIChcIityLmNoYW5uZWwrXCIgKiA0IC8gXCIrYStcIikpICogXCIrby5jaGFubmVsK1wiICsgajtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb1ZhbHVlID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2luZ19vcmlnaW4oYiwgYzIsIG95LCBveCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZWYWx1ZSA9IGdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdfZmlsdGVyKGMgKiA0ICsgMiwgaiwgZnksIGZ4KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmIgKz0gZG90KGZWYWx1ZSwgb1ZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhY2tlZF9pbmRleCA9PSAzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBjMyA9ICgoYyArIDMpIC8gKFwiK3IuY2hhbm5lbCtcIiAqIDQgLyBcIithK1wiKSkgKiBcIitvLmNoYW5uZWwrXCIgKyBqO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvVmFsdWUgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nX29yaWdpbihiLCBjMywgb3ksIG94KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZlZhbHVlID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2luZ19maWx0ZXIoYyAqIDQgKyAzLCBqLCBmeSwgZngpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuYSArPSBkb3QoZlZhbHVlLCBvVmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBveCArPSBcIitBK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBveSArPSBcIit3K1wiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrKGk/XCJyZXMgKz0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2luZ19iaWFzKDAsIGMsIDAsIDApO1wiOlwiXCIpK1wiXFxuXFxuICAgICAgICBpZiAoXCIrZCtcIikge1xcbiAgICAgICAgICAgIHJlcyA9IG1heCh2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCksIHJlcyk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChcIisoXCJyZWx1NlwiPT09ZykrXCIpIHtcXG4gICAgICAgICAgICByZXMgPSBtaW4obWF4KHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKSwgcmVzKSwgdmVjNCg2LjAsIDYuMCwgNi4wLCA2LjApKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldFBhY2tlZE91dHB1dChyZXMpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e2ZpbHRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nXCJdLG9yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nXCJdLGJpYXM6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zUGFja2luZ1wiXX0sYmVoYXZpb3JzOltcImFkYXB0UGFkZGluZ3NcIixcImlzQXBwbHlTZXBhcmFibGVDb252XCIsXCJiYXRjaENvbXB1dGVDb252MmRcIixcInByb2Nlc3NCaWFzXCJdfSxjb252MmRfdHJhbnNwb3NlOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PW4ub3JpZ2luLG89bi5maWx0ZXIscj1uLm91dCxpPWUuZ3JvdXBzLHM9dm9pZCAwPT09aT8xOmksYT1lLnN0cmlkZXMsdT12b2lkIDA9PT1hP1tdOmEsbD1lLnBhZGRpbmdzLGM9dm9pZCAwPT09bD9bXTpsLGY9ZS5kaWxhdGlvbnMsaD12b2lkIDA9PT1mP1tdOmYscD11WzBdLGQ9dm9pZCAwPT09cD8xOnAsZz11WzFdLF89dm9pZCAwPT09Zz8xOmcsbT1jWzBdLHY9dm9pZCAwPT09bT8wOm0sUD1jWzFdLHg9dm9pZCAwPT09UD8wOlA7eD1vLmhlaWdodF9zaGFwZS14LTEsdj1vLndpZHRoX3NoYXBlLXYtMTt2YXIgYj1oWzBdLFQ9dm9pZCAwPT09Yj8xOmIseT1oWzFdLEY9dm9pZCAwPT09eT8xOnk7cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGludCB4ID0gb1Bvcy5hO1xcbiAgICAgICAgaW50IGMgPSBvUG9zLmc7XFxuICAgICAgICBpbnQgeSA9IG9Qb3MuYjtcXG4gICAgICAgIGludCBiID0gb1Bvcy5yO1xcbiAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgaW50IHRlbXBfeCA9IDA7XFxuICAgICAgICBpbnQgdGVtcF95ID0gMDtcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBmbG9hdCBmID0gMC4wO1xcblxcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpbnQgb1RlbnNvckNoYW5uZWwgPSBpbnQoYyAqIFwiK3MrXCIgLyBcIityLmNoYW5uZWwrXCIpICogXCIrdC5jaGFubmVsK1wiO1xcbiAgICAgICAgaW50IG95ID0geSAtIFwiK3grXCI7XFxuICAgICAgICBjb25zdCBpbnQgZ3JvdXBMZW4gPSBpbnQoXCIrdC5jaGFubmVsK1wiIC8gXCIrcytcIik7XFxuICAgICAgICBpbnQgZ3JvdXBJbmRleCA9IGludChjIC8gZ3JvdXBMZW4pO1xcblxcbiAgICAgICAgZm9yIChpbnQgZnkgPSAwOyBmeSA8IFwiK28uaGVpZ2h0X3NoYXBlK1wiOyBmeSsrKSB7XFxuICAgICAgICAgICAgaWYgKG95IDwgMCkge1xcbiAgICAgICAgICAgICAgICBveSArPSBcIitUK1wiO1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IG94ID0geCAtIFwiK3YrXCI7XFxuICAgICAgICAgICAgZm9yIChpbnQgZnggPSAwOyBmeCA8IFwiK28ud2lkdGhfc2hhcGUrXCI7IGZ4KyspIHtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKG94IDwgMCkge1xcbiAgICAgICAgICAgICAgICAgICAgb3ggKz0gXCIrRitcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIGNoYW5uZWzorqHnrpdcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBncm91cExlbjsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgICBpbnQgY3VySW5kZXggPSBqICsgYiAqIGdyb3VwTGVuO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbE1vZChveCwgaW50KFwiK18rXCIpKSA9PSAwICYmIGNhbE1vZChveSwgaW50KFwiK2QrXCIpKSA9PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcF94ID0gaW50KGZsb29yKGZsb2F0KG94KSAvIGZsb2F0KFwiK18rXCIpKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcF95ID0gaW50KGZsb29yKGZsb2F0KG95KSAvIGZsb2F0KFwiK2QrXCIpKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBfeCA8IFwiK3Qud2lkdGhfc2hhcGUrXCIgJiYgdGVtcF95IDwgXCIrdC5oZWlnaHRfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oYiwgY3VySW5kZXggLCB0ZW1wX3ksIHRlbXBfeCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfZmlsdGVyKFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VySW5kZXgsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQoYyAvIFwiK3MrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIrby5oZWlnaHRfc2hhcGUrXCItMS1meSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiK28ud2lkdGhfc2hhcGUrXCItMS1meFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gZiAqIG87XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG94ICs9IFwiK0YrXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG95ICs9IFwiK1QrXCI7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQocmVzKSk7XFxuICAgIH1cXG5cIn0sdGV4dHVyZUZ1bmNDb25mOntmaWx0ZXI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLG9yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJhZGFwdFBhZGRpbmdzXCIsXCJpc0FwcGx5U2VwYXJhYmxlQ29udlwiLFwiYmF0Y2hDb21wdXRlQ29udjJkXCIsXCJwcm9jZXNzQmlhc1wiXX0sZGVwdGh3aXNlX2NvbnYyZDpRLGNvbnYyZF9kZXB0aHdpc2U6USxjb252MmRfZWxlbWVudHdpc2VfYWRkOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PW4ub3JpZ2luLG89bi5maWx0ZXIscj1uLm91dCxpPW4uY291bnRlcixzPWUuYWN0aXZlX2Z1bmN0aW9uLGE9ZS5ncm91cHMsdT12b2lkIDA9PT1hPzE6YSxsPWUuYXhpcyxjPWUuc3RyaWRlcyxmPXZvaWQgMD09PWM/W106YyxoPWUucGFkZGluZ3MscD12b2lkIDA9PT1oP1tdOmgsZD1lLmRpbGF0aW9ucyxnPXZvaWQgMD09PWQ/W106ZCxfPWUubXVsdGlfdmFsdWUsbT1lLmJpYXNfdmFsdWUsdj1mWzBdLFA9dm9pZCAwPT09dj8xOnYseD1mWzFdLGI9dm9pZCAwPT09eD8xOngsVD1wWzBdLHk9dm9pZCAwPT09VD8wOlQsRj1wWzFdLHc9dm9pZCAwPT09Rj8wOkYsRT1nWzBdLEE9dm9pZCAwPT09RT8xOkUsTz1nWzFdLFY9dm9pZCAwPT09Tz8xOk87cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG5cXG4gICAgZmxvYXQgZ2V0VmFsdWVGcm9tQ291bnRlcihpbnQgaW5kZXgpIHtcXG4gICAgICAgIGZsb2F0IHhQb3MgPSBmbG9hdChpbmRleCkgLyBmbG9hdChcIitpLndpZHRoX3NoYXBlK1wiKTtcXG4gICAgICAgIHZlYzQgcGl4ZWxzID0gVEVYVFVSRTJEKHRleHR1cmVfY291bnRlciwgdmVjMih4UG9zLCAwLjUpKTtcXG4gICAgICAgIHJldHVybiBwaXhlbHMucjtcXG4gICAgfVxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcblxcbiAgICAgICAgaW50IHggPSBvUG9zLmE7XFxuICAgICAgICBpbnQgYyA9IG9Qb3MuZztcXG4gICAgICAgIGludCB5ID0gb1Bvcy5iO1xcbiAgICAgICAgaW50IGIgPSBvUG9zLnI7XFxuICAgICAgICBpbnQgYWRkQXhpcyA9IG9Qb3NbXCIrbCtcIl07XFxuICAgICAgICBmbG9hdCByZXMgPSBnZXRWYWx1ZUZyb21Db3VudGVyKGFkZEF4aXMpO1xcblxcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpbnQgb1RlbnNvckNoYW5uZWwgPSAoYyAvIChcIityLmNoYW5uZWwrXCIgLyBcIit1K1wiKSkgKiBcIitvLmNoYW5uZWwrXCI7XFxuICAgICAgICBpbnQgb3kgPSB5ICogXCIrUCtcIiAtIFwiK3krXCI7XFxuICAgICAgICBmb3IgKGludCBmeSA9IDA7IGZ5IDwgXCIrby5oZWlnaHRfc2hhcGUrXCI7IGZ5KyspIHtcXG4gICAgICAgICAgICBpZiAob3kgPj0gXCIrdC5oZWlnaHRfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChveSA8IDApIHtcXG4gICAgICAgICAgICAgICAgb3kgKz0gXCIrQStcIjtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBveCA9IHggKiBcIitiK1wiIC0gXCIrdytcIjtcXG4gICAgICAgICAgICBmb3IgKGludCBmeCA9IDA7IGZ4IDwgXCIrby53aWR0aF9zaGFwZStcIjsgZngrKykge1xcbiAgICAgICAgICAgICAgICBpZiAob3ggPj0gXCIrdC53aWR0aF9zaGFwZStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKG94IDwgMCkge1xcbiAgICAgICAgICAgICAgICAgICAgb3ggKz0gXCIrVitcIjtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIGNoYW5uZWzorqHnrpdcXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBcIitvLmNoYW5uZWwrXCI7IGorKykge1xcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgZiA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19maWx0ZXIoYywgaiwgZnksIGZ4KTtcXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGIsIG9UZW5zb3JDaGFubmVsICsgaiwgb3ksIG94KTtcXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBmICogbztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBveCArPSBcIitWK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBveSArPSBcIitBK1wiO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiK3MrXCIocmVzLCAgXCIrXytcIiwgIFwiK20rXCIpKTtcXG4gICAgfVxcblwifSx0ZXh0dXJlRnVuY0NvbmY6e2ZpbHRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sb3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxjb3VudGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcIm1lcmdlQXR0cnNcIixcImNoZWNrSXNNZXJnZVwiLFwic2V0QWN0aXZlRnVuY1wiXX0scG9vbDJkOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PW4ub3JpZ2luLG89ZS5zdHJpZGVzLHI9dm9pZCAwPT09bz9bXTpvLGk9ZS5wYWRkaW5ncyxzPXZvaWQgMD09PWk/W106aSxhPWUucG9vbGluZ190eXBlLHU9ZS5rc2l6ZSxsPXJbMF0sYz12b2lkIDA9PT1sPzE6bCxmPXJbMV0saD12b2lkIDA9PT1mPzE6ZixwPXNbMF0sZD12b2lkIDA9PT1wPzA6cCxnPXNbMV0sXz12b2lkIDA9PT1nPzA6ZyxtPXVbMF0sdj11WzFdO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBmbG9hdCByZXMgPSAwLjA7XFxuICAgICAgICBpZiAoXCIrYStcIiA9PSAxKSB7XFxuICAgICAgICAgICAgcmVzID0gLTEuNzAxNDExODRlMzg7XFxuICAgICAgICB9XFxuICAgICAgICAvLyDojrflj5ZvdXRwdXTnmoTlnZDmoIdcXG4gICAgICAgIGl2ZWM0IG91dF9wb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIC8vIFjjgIFZ5pa55ZCR55qE56e75Yqo5q2l6ZW/XFxuICAgICAgICBpbnQgY291bnRfcG9vbCA9IDA7XFxuICAgICAgICBpbnQgb3lfYmFzZSA9IG91dF9wb3NbMl0gKiBcIitjK1wiIC0gXCIrZCtcIjtcXG4gICAgICAgIGludCBveF9iYXNlID0gb3V0X3Bvc1szXSAqIFwiK2grXCIgLSBcIitfK1wiO1xcbiAgICAgICAgZm9yIChpbnQgZnkgPSAwOyBmeSA8IFwiK20rXCI7IGZ5KyspIHtcXG4gICAgICAgICAgICBpbnQgb3kgPSBveV9iYXNlICsgZnk7XFxuICAgICAgICAgICAgaWYgKG95ID49IFwiK3QuaGVpZ2h0X3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAob3kgPCAwKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBmb3IgKGludCBmeCA9IDA7IGZ4IDwgXCIrditcIjsgZngrKykge1xcbiAgICAgICAgICAgICAgICBpbnQgb3ggPSBveF9iYXNlICsgZng7XFxuICAgICAgICAgICAgICAgIGlmIChveCA+PSBcIit0LndpZHRoX3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAob3ggPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBvcmlnaW7mlbDmja5cXG4gICAgICAgICAgICAgICAgZmxvYXQgY3VyciA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob3V0X3Bvc1swXSwgb3V0X3Bvc1sxXSwgb3ksIG94KTtcXG4gICAgICAgICAgICAgICAgaWYgKFwiK2ErXCIgPT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnIgPiByZXMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBjdXJyO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGN1cnI7XFxuICAgICAgICAgICAgICAgICAgICAvLyDlnKjlubPlnYfmsaDljJbmqKHlvI/lv73nlaXloavlhYXlgLwoZXhjbHVzaXZl6buY6K6k5Li6dHJ1Ze+8iVxcbiAgICAgICAgICAgICAgICAgICAgY291bnRfcG9vbCsrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKFwiK2ErXCIgIT0gMSkge1xcbiAgICAgICAgICAgIHJlcyA9IHJlcyAvIGZsb2F0KGNvdW50X3Bvb2wpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KHJlcyk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcImlzTWF4XCIsXCJzZXRQYWNrZWRcIixcInNldEFkYXB0aXZlXCIsXCJpc0dsb2JhbFBvb2xpbmdcIl19LHBvb2wyZF9tYXg6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5vcmlnaW4sbz1lLnN0cmlkZXMscj12b2lkIDA9PT1vP1tdOm8saT1lLnBhZGRpbmdzLHM9dm9pZCAwPT09aT9bXTppLGE9ZS5rc2l6ZSx1PWUuZ2xvYmFsX3Bvb2xpbmcsbD1lLnJ1bnRpbWUsYz1yWzBdLGY9dm9pZCAwPT09Yz8xOmMsaD1yWzFdLHA9dm9pZCAwPT09aD8xOmgsZD1zWzBdLGc9dm9pZCAwPT09ZD8wOmQsXz1zWzFdLG09dm9pZCAwPT09Xz8wOl8sdj1hWzBdLFA9YVsxXSx4PWZ1bmN0aW9uKG4pe3ZhciBlPW4udG90YWxfc2hhcGUsdD1uLmNoYW5uZWwsbz1uLmhlaWdodF9zaGFwZSxyPW4ud2lkdGhfc2hhcGU7cmV0dXJuW2UvdC9vL3IsdCxvLHJdfSh0KSxiPVwiXCIsVD1cInNldE91dHB1dChmbG9hdChyZXMpKTtcIjtyZXR1cm4gMD09PWwmJiEwPT09dSYmKGI9XCJcXG4gICAgICAgICAgICBpZiAoY3VyciA+IHJlcykge1xcbiAgICAgICAgICAgICAgICBpbmRleCA9IFwiK3hbMl0qeFszXStcIiAqIG91dF9wb3NbMV0gKyBcIit4WzNdK1wiICogb3kgKyBveDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICBcIixUPVwic2V0T3V0cHV0KGZsb2F0KGluZGV4KSk7XCIpLFwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBmbG9hdCByZXMgPSAtMS43MDE0MTE4NGUzODtcXG4gICAgICAgIGludCBpbmRleCA9IDA7XFxuICAgICAgICAvLyDojrflj5ZvdXRwdXTnmoTlnZDmoIdcXG4gICAgICAgIGl2ZWM0IG91dF9wb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGludCBiID0gb3V0X3Bvc1swXTtcXG4gICAgICAgIGludCBjID0gb3V0X3Bvc1sxXTtcXG4gICAgICAgIGludCB5ID0gb3V0X3Bvc1syXTtcXG4gICAgICAgIGludCB4ID0gb3V0X3Bvc1szXTtcXG4gICAgICAgIC8vIFjjgIFZ5pa55ZCR55qE56e75Yqo5q2l6ZW/XFxuICAgICAgICBpbnQgb3lfYmFzZSA9IG91dF9wb3NbMl0gKiBcIitmK1wiIC0gXCIrZytcIjtcXG4gICAgICAgIGludCBveF9iYXNlID0gb3V0X3Bvc1szXSAqIFwiK3ArXCIgLSBcIittK1wiO1xcbiAgICAgICAgZm9yIChpbnQgZnkgPSAwOyBmeSA8IFwiK3YrXCI7IGZ5KyspIHtcXG4gICAgICAgICAgICBpbnQgb3kgPSBveV9iYXNlICsgZnk7XFxuICAgICAgICAgICAgaWYgKG95ID49IFwiK3QuaGVpZ2h0X3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAob3kgPCAwKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBmb3IgKGludCBmeCA9IDA7IGZ4IDwgXCIrUCtcIjsgZngrKykge1xcbiAgICAgICAgICAgICAgICBpbnQgb3ggPSBveF9iYXNlICsgZng7XFxuICAgICAgICAgICAgICAgIGlmIChveCA+PSBcIit0LndpZHRoX3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAob3ggPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBvcmlnaW7mlbDmja5cXG4gICAgICAgICAgICAgICAgZmxvYXQgY3VyciA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob3V0X3Bvc1swXSwgb3V0X3Bvc1sxXSwgb3ksIG94KTtcXG4gICAgICAgICAgICAgICAgXCIrYitcIlxcbiAgICAgICAgICAgICAgICByZXMgPSBtYXgocmVzLCBjdXJyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBcIitUK1wiXFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcImlzTWF4XCIsXCJzZXRQYWNrZWRcIixcInNldEFkYXB0aXZlXCIsXCJpc0dsb2JhbFBvb2xpbmdcIl19LHBvb2wyZF93aW5vZ3JhZDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm9yaWdpbixvPW4ucG9vbCxyPWUuc3RyaWRlcyxpPXZvaWQgMD09PXI/W106cixzPWUucGFkZGluZ3MsYT12b2lkIDA9PT1zP1tdOnMsdT1lLnR5cGVfcG9vbCxsPWlbMF0sYz12b2lkIDA9PT1sPzE6bCxmPWlbMV0saD12b2lkIDA9PT1mPzE6ZixwPWFbMF0sZD12b2lkIDA9PT1wPzA6cCxnPWFbMV0sXz12b2lkIDA9PT1nPzA6ZyxtPXQuaGVpZ2h0X3NoYXBlLHY9dC53aWR0aF90ZXh0dXJlLFA9dC5oZWlnaHRfdGV4dHVyZTtyZXR1cm5cIlxcblxcbiAgICBmbG9hdCBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNrZWRfb3JpZ2luKGludCByLCBpbnQgZywgaW50IGIsIGludCBhKSB7XFxuICAgICAgICBpbnQgeSA9IGIgLyAyO1xcbiAgICAgICAgaW50IHlPZmZzZXQgPSBjYWxNb2QoYiwgMik7XFxuICAgICAgICBpbnQgeCA9IGEgLyAyO1xcbiAgICAgICAgaW50IHhPZmZzZXQgPSBjYWxNb2QoYSwgMik7XFxuICAgICAgICBpbnQgaGVpZ2h0ID0gXCIrbStcIiArIFwiK3Qub2Zmc2V0X3krXCI7XFxuICAgICAgICB2ZWM0IHBpeGVscyA9IFRFWFRVUkUyRChcXG4gICAgICAgICAgICB0ZXh0dXJlX29yaWdpbixcXG4gICAgICAgICAgICB2ZWMyKChmbG9hdCh4KSArIDAuNSkgLyBmbG9hdChcIit2K1wiKSxcXG4gICAgICAgICAgICAoZmxvYXQoZyAqIGhlaWdodCAvIDIgKyB5KSArIDAuNSkgLyBmbG9hdChcIitQK1wiKSlcXG4gICAgICAgICk7XFxuICAgICAgICBpbnQgaW5kZXggPSAwO1xcbiAgICAgICAgaWYgKHhPZmZzZXQgPT0gMCAmJiB5T2Zmc2V0ID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxzWzBdO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZiAoeE9mZnNldCA9PSAxICYmIHlPZmZzZXQgPT0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBwaXhlbHNbMV07XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmICh4T2Zmc2V0ID09IDAgJiYgeU9mZnNldCA9PSAxKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHBpeGVsc1syXTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBwaXhlbHNbM107XFxuICAgIH1cXG5cXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGZsb2F0IHJlcyA9ICgtMS4wIC8gZXhwKC0yMC4wKSk7XFxuICAgICAgICAvLyDojrflj5ZvdXRwdXTnmoTlnZDmoIdcXG4gICAgICAgIGl2ZWM0IG91dF9wb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIC8vIGludCBiID0gb3V0X3Bvc1swXTtcXG4gICAgICAgIC8vIGludCBjID0gb3V0X3Bvc1sxXTtcXG4gICAgICAgIC8vIGludCB5ID0gb3V0X3Bvc1syXTtcXG4gICAgICAgIC8vIGludCB4ID0gb3V0X3Bvc1szXTtcXG4gICAgICAgIC8vIFjjgIFZ5pa55ZCR55qE56e75Yqo5q2l6ZW/XFxuICAgICAgICBpbnQgY291bnRfcG9vbCA9IDA7XFxuICAgICAgICBpbnQgb3lfYmFzZSA9IG91dF9wb3NbMl0gKiBcIitjK1wiIC0gXCIrZCtcIjtcXG4gICAgICAgIGludCBveF9iYXNlID0gb3V0X3Bvc1szXSAqIFwiK2grXCIgLSBcIitfK1wiO1xcblxcbiAgICAgICAgZm9yIChpbnQgZnkgPSAwOyBmeSA8IFwiK28uaGVpZ2h0X3NoYXBlK1wiOyBmeSsrKSB7XFxuICAgICAgICAgICAgaW50IG95ID0gb3lfYmFzZSArIGZ5O1xcbiAgICAgICAgICAgIGlmIChveSA+PSBcIit0LmhlaWdodF9zaGFwZStcIikge1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG95IDwgMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZm9yIChpbnQgZnggPSAwOyBmeCA8IFwiK28ud2lkdGhfc2hhcGUrXCI7IGZ4KyspIHtcXG4gICAgICAgICAgICAgICAgaW50IG94ID0gb3hfYmFzZSArIGZ4O1xcbiAgICAgICAgICAgICAgICBpZiAob3ggPj0gXCIrdC53aWR0aF9zaGFwZStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKG94IDwgMCkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2lu5pWw5o2uXFxuICAgICAgICAgICAgICAgIGZsb2F0IGN1cnIgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNrZWRfb3JpZ2luKG91dF9wb3NbMF0sIG91dF9wb3NbMV0sIG95LCBveCk7XFxuICAgICAgICAgICAgICAgIGlmIChcIit1K1wiID09IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyID4gcmVzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gY3VycjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBjdXJyO1xcbiAgICAgICAgICAgICAgICAgICAgLy8g5Zyo5bmz5Z2H5rGg5YyW5qih5byP5b+955Wl5aGr5YWF5YC8KGV4Y2x1c2l2Zem7mOiupOS4unRydWXvvIlcXG4gICAgICAgICAgICAgICAgICAgIGNvdW50X3Bvb2wrKztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChcIit1K1wiICE9IDEpIHtcXG4gICAgICAgICAgICByZXMgPSByZXMgLyBmbG9hdChjb3VudF9wb29sKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChyZXMpO1xcbiAgICB9XFxuICAgIFwifSxiZWhhdmlvcnM6W1wiaXNNYXhcIixcInNldFBhY2tlZFwiLFwic2V0QWRhcHRpdmVcIixcImlzR2xvYmFsUG9vbGluZ1wiXX0sZWxlbWVudHdpc2VfYWRkOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PWUuY291bnRlclBvcyxvPWUuU2NhbGVfeSxyPXZvaWQgMD09PW8/MTpvLGk9ZS5TY2FsZV94LHM9dm9pZCAwPT09aT8xOmksYT1lLlNjYWxlX291dCx1PXZvaWQgMD09PWE/MTphO3JldHVyblwiXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGZsb2F0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuXFxuICAgICAgICBmbG9hdCBjID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2NvdW50ZXIoXCIrdCtcIik7XFxuICAgICAgICBmbG9hdCByZXMgPSBmbG9hdChcIit1L3IrXCIpICogYyArIGZsb2F0KFwiK3UvcytcIikgKiBvO1xcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KHJlcykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e2NvdW50ZXI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLG9yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJwcm9jZXNzRWxlbWVudHdpc2VBeGlzXCIsXCJnZW5FbGVtZW50d2lzZUNvdW50ZXJQb3NcIl19LGVsZW1lbnR3aXNlX211bDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLmNvdW50ZXIsbz1lLmNvdW50ZXJQb3Mscj1lLlNjYWxlX3ksaT12b2lkIDA9PT1yPzE6cixzPWUuU2NhbGVfeCxhPXZvaWQgMD09PXM/MTpzLHU9ZS5TY2FsZV9vdXQsbD12b2lkIDA9PT11PzE6dTtyZXR1cm5cIlxcbiAgICBpdmVjNCBmb3JtYXROQ0hXKGludCBuLCBpbnQgYywgaW50IGgsIGludCB3KSB7XFxuICAgICAgICBpbnQgbmV3TiA9IG47XFxuICAgICAgICBpbnQgbmV3QyA9IGM7XFxuICAgICAgICBpbnQgbmV3SCA9IGg7XFxuICAgICAgICBpbnQgbmV3VyA9IHc7XFxuXFxuICAgICAgICBpZiAobiA+PSBcIit0LmhlaWdodF90ZXh0dXJlL3QuaGVpZ2h0X3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgbmV3TiA9IGludChcIit0LmhlaWdodF90ZXh0dXJlL3QuaGVpZ2h0X3NoYXBlK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjID49IFwiK3QuY2hhbm5lbCtcIikge1xcbiAgICAgICAgICAgIG5ld0MgPSBpbnQoXCIrKHQuY2hhbm5lbC0xKStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaCA+PSBcIit0LmhlaWdodF9zaGFwZStcIikge1xcbiAgICAgICAgICAgIG5ld0ggPSBcIisodC5oZWlnaHRfc2hhcGUtMSkrXCI7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodyA+PSBcIit0LndpZHRoX3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgbmV3VyA9IFwiKyh0LndpZHRoX3NoYXBlLTEpK1wiO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGl2ZWM0KG5ld04sIG5ld0MsIG5ld0gsIG5ld1cpO1xcbiAgICB9XFxuXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIC8vIOi+k+WHuuaVsOaNrlxcbiAgICAgICAgaXZlYzQgb1BvczEgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGZsb2F0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MxLnIsIG9Qb3MxLmcsIG9Qb3MxLmIsIG9Qb3MxLmEpO1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGZvcm1hdE5DSFcob1BvczEuciwgb1BvczEuZywgb1BvczEuYiwgb1BvczEuYSk7XFxuXFxuICAgICAgICBmbG9hdCBjID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2NvdW50ZXIoXCIrbytcIik7XFxuICAgICAgICBmbG9hdCByZXMgPSBmbG9hdChcIitsL2ErXCIpICogbyAqIGZsb2F0KFwiKzEvaStcIikgKiBjO1xcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KHJlcykpO1xcbiAgICB9XFxuXFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e2NvdW50ZXI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLG9yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJwcm9jZXNzRWxlbWVudHdpc2VBeGlzXCIsXCJnZW5FbGVtZW50d2lzZUNvdW50ZXJQb3NcIl19LGVsZW1lbnR3aXNlX2Rpdjp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLmNvdW50ZXIsbz1lLmNvdW50ZXJQb3Mscj1lLlNjYWxlX3ksaT12b2lkIDA9PT1yPzE6cixzPWUuU2NhbGVfeCxhPXZvaWQgMD09PXM/MTpzLHU9ZS5TY2FsZV9vdXQsbD12b2lkIDA9PT11PzE6dTtyZXR1cm5cIlxcbiAgICBpdmVjNCBmb3JtYXROQ0hXKGludCBuLCBpbnQgYywgaW50IGgsIGludCB3KSB7XFxuICAgICAgICBpbnQgbmV3TiA9IG47XFxuICAgICAgICBpbnQgbmV3QyA9IGM7XFxuICAgICAgICBpbnQgbmV3SCA9IGg7XFxuICAgICAgICBpbnQgbmV3VyA9IHc7XFxuXFxuICAgICAgICBpZiAobiA+PSBcIit0LmhlaWdodF90ZXh0dXJlL3QuaGVpZ2h0X3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgbmV3TiA9IGludChcIit0LmhlaWdodF90ZXh0dXJlL3QuaGVpZ2h0X3NoYXBlK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjID49IFwiK3QuY2hhbm5lbCtcIikge1xcbiAgICAgICAgICAgIG5ld0MgPSBpbnQoXCIrKHQuY2hhbm5lbC0xKStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaCA+PSBcIit0LmhlaWdodF9zaGFwZStcIikge1xcbiAgICAgICAgICAgIG5ld0ggPSBcIisodC5oZWlnaHRfc2hhcGUtMSkrXCI7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodyA+PSBcIit0LndpZHRoX3NoYXBlK1wiKSB7XFxuICAgICAgICAgICAgbmV3VyA9IFwiKyh0LndpZHRoX3NoYXBlLTEpK1wiO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGl2ZWM0KG5ld04sIG5ld0MsIG5ld0gsIG5ld1cpO1xcbiAgICB9XFxuXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIC8vIOi+k+WHuuaVsOaNrlxcbiAgICAgICAgaXZlYzQgb1BvczEgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGZsb2F0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3MxLnIsIG9Qb3MxLmcsIG9Qb3MxLmIsIG9Qb3MxLmEpO1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGZvcm1hdE5DSFcob1BvczEuciwgb1BvczEuZywgb1BvczEuYiwgb1BvczEuYSk7XFxuXFxuICAgICAgICBmbG9hdCBjID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2NvdW50ZXIoXCIrbytcIik7XFxuICAgICAgICBmbG9hdCByZXMgPSBmbG9hdChcIitsK1wiKSAqIChmbG9hdChcIisxL2ErXCIpICogbyAvIChmbG9hdChcIisxL2krXCIpICogYykpO1xcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KHJlcykpO1xcbiAgICB9XFxuXFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e2NvdW50ZXI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLG9yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJwcm9jZXNzRWxlbWVudHdpc2VBeGlzXCIsXCJnZW5FbGVtZW50d2lzZUNvdW50ZXJQb3NcIl19LGVsZW1lbnR3aXNlX3Bvdzp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1lLmNvdW50ZXJQb3Msbz1lLlNjYWxlX3kscj12b2lkIDA9PT1vPzE6byxpPWUuU2NhbGVfeCxzPXZvaWQgMD09PWk/MTppLGE9ZS5TY2FsZV9vdXQsdT12b2lkIDA9PT1hPzE6YTtyZXR1cm5cIlxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgLy8g6L6T5Ye65pWw5o2uXFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcblxcbiAgICAgICAgZmxvYXQgYyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19jb3VudGVyKFwiK3QrXCIpO1xcbiAgICAgICAgZmxvYXQgcmVzID0gcG93KGZsb2F0KFwiK3UvcytcIikgKiBvLCBmbG9hdChcIit1L3IrXCIpICogYyk7XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQocmVzKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7Y291bnRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sb3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcInByb2Nlc3NFbGVtZW50d2lzZUF4aXNcIixcImdlbkVsZW1lbnR3aXNlQ291bnRlclBvc1wiXX0sZWxlbWVudHdpc2Vfc3ViOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PWUuY291bnRlclBvcyxvPWUuU2NhbGVfeSxyPXZvaWQgMD09PW8/MTpvLGk9ZS5TY2FsZV94LHM9dm9pZCAwPT09aT8xOmksYT1lLlNjYWxlX291dCx1PXZvaWQgMD09PWE/MTphO3JldHVyblwiXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGZsb2F0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuXFxuICAgICAgICBmbG9hdCBjID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2NvdW50ZXIoXCIrdCtcIik7XFxuICAgICAgICBmbG9hdCByZXMgPSBmbG9hdChcIit1L3MrXCIpICogbyAtIGZsb2F0KFwiK3UvcitcIikgKiBjO1xcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KHJlcykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e2NvdW50ZXI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLG9yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJwcm9jZXNzRWxlbWVudHdpc2VBeGlzXCIsXCJnZW5FbGVtZW50d2lzZUNvdW50ZXJQb3NcIl19LG11bDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm9yaWdpbixvPW4uY291bnRlcixyPWUueF9udW1fY29sX2RpbXMsaT1lLnlfbnVtX2NvbF9kaW1zLHM9dG4odCksYT10bihvKSx1PSQocyxyKSxsPXVbMF0sYz11WzFdLGY9dVsyXSxoPXVbM10scD11WzRdLGQ9JChhLGkpLGc9ZFswXSxfPWRbMV0sbT1kWzJdLHY9ZFszXTtyZXR1cm5cIlxcbiAgICBcIitubihcIngxXCIsbCxjKStcIlxcbiAgICBcIitubihcIngyXCIsZixoKStcIlxcbiAgICBcIitubihcInkxXCIsZyxfKStcIlxcbiAgICBcIitubihcInkyXCIsbSx2KStcIlxcblxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpdmVjNCBvcG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCB0ZW1wID0gMC4wO1xcblxcbiAgICAgICAgLy8gb3V0cHV0IGlzIDJEXFxuICAgICAgICBpbnQgYiA9IG9wb3MuYjtcXG4gICAgICAgIGludCBhID0gb3Bvcy5hO1xcblxcbiAgICAgICAgXCIrZW4oYykrXCIgeDEgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF94MShiKTtcXG4gICAgICAgIFwiK2VuKHYpK1wiIHkyID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfeTIoYSk7XFxuXFxuICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK3BbMV0rXCI7IGorKykge1xcbiAgICAgICAgICAgIFwiK2VuKGgpK1wiIHgyID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfeDIoaik7XFxuICAgICAgICAgICAgXCIrZW4oXykrXCIgeTEgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF95MShqKTtcXG5cXG4gICAgICAgICAgICBpdmVjNCB4UG9zID0gaXZlYzQoXCIrZW4oYykrXCIoeDEpLCBcIitlbihoKStcIih4MikpO1xcbiAgICAgICAgICAgIGl2ZWM0IHlQb3MgPSBpdmVjNChcIitlbihfKStcIih5MSksIFwiK2VuKHYpK1wiKHkyKSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oeFBvcy5yLCB4UG9zLmcsIHhQb3MuYiwgeFBvcy5hKTtcXG4gICAgICAgICAgICBmbG9hdCBjID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2NvdW50ZXIoeVBvcy5yLCB5UG9zLmcsIHlQb3MuYiwgeVBvcy5hKTtcXG4gICAgICAgICAgICByZXMgKz0gYyAqIG87XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntjb3VudGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0sbWF0bXVsOm9uLG1hdG11bF92MjpvbixmYzp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm9yaWdpbixvPW4ud2VpZ2h0LHI9ZS54X251bV9jb2xfZGltcyxpPWUueV9udW1fY29sX2RpbXMscz11bih0KSxhPXVuKG8pLHU9cm4ocyxyKSxsPXVbMF0sYz11WzFdLGY9dVsyXSxoPXVbM10scD11WzRdLGQ9cm4oYSxpKSxnPWRbMF0sXz1kWzFdLG09ZFsyXSx2PWRbM107cmV0dXJuXCJcXG4gICAgXCIrc24oXCJ4MVwiLGwsYykrXCJcXG4gICAgXCIrc24oXCJ4MlwiLGYsaCkrXCJcXG4gICAgXCIrc24oXCJ5MVwiLGcsXykrXCJcXG4gICAgXCIrc24oXCJ5MlwiLG0sdikrXCJcXG5cXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG4gICAgICAgIC8vIOiOt+WPlm91dHB1dOeahOWdkOagh1xcbiAgICAgICAgaXZlYzQgb3BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgZmxvYXQgYmlhcyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19iaWFzKG9wb3Muciwgb3Bvcy5nLCBvcG9zLmIsIG9wb3MuYSk7XFxuICAgICAgICBmbG9hdCB0ZW1wID0gMC4wO1xcblxcbiAgICAgICAgLy8gb3V0cHV0IGlzIDJEXFxuICAgICAgICBpbnQgYiA9IG9wb3MuYjtcXG4gICAgICAgIGludCBhID0gb3Bvcy5hO1xcblxcbiAgICAgICAgXCIrYW4oYykrXCIgeDEgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF94MShiKTtcXG4gICAgICAgIFwiK2FuKHYpK1wiIHkyID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfeTIoYSk7XFxuXFxuICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK3BbMV0rXCI7IGorKykge1xcbiAgICAgICAgICAgIFwiK2FuKGgpK1wiIHgyID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfeDIoaik7XFxuICAgICAgICAgICAgXCIrYW4oXykrXCIgeTEgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF95MShqKTtcXG5cXG4gICAgICAgICAgICBpdmVjNCB4UG9zID0gaXZlYzQoXCIrYW4oYykrXCIoeDEpLCBcIithbihoKStcIih4MikpO1xcbiAgICAgICAgICAgIGl2ZWM0IHlQb3MgPSBpdmVjNChcIithbihfKStcIih5MSksIFwiK2FuKHYpK1wiKHkyKSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oeFBvcy5yLCB4UG9zLmcsIHhQb3MuYiwgeFBvcy5hKTtcXG4gICAgICAgICAgICBmbG9hdCBjID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX3dlaWdodCh5UG9zLnIsIHlQb3MuZywgeVBvcy5iLCB5UG9zLmEpO1xcbiAgICAgICAgICAgIHJlcyArPSBjICogbztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJlcyA9IHJlcyArIGJpYXM7XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOnt3ZWlnaHQ6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLG9yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sYmlhczpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxkcm9wb3V0OnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgaWYgKFwiKyhcImRvd25ncmFkZV9pbl9pbmZlclwiPT09ZS5kcm9wb3V0X2ltcGxlbWVudGF0aW9uKStcIikge1xcbiAgICAgICAgICAgIG8gPSBvICogKDEuMCAtIFwiK2UuZHJvcG91dF9wcm9iK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX19LGNvbmNhdDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1lLmRpbSxvPU9iamVjdC5rZXlzKG4pLmZpbHRlcigoZnVuY3Rpb24obil7cmV0dXJuXCJvdXRcIiE9PW59KSkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gbltlXX0pKS5tYXAoKGZ1bmN0aW9uKG4pe3ZhciBlPW4ud2lkdGhfc2hhcGUsbz1uLmhlaWdodF9zaGFwZSxyPW4uY2hhbm5lbDtyZXR1cm5bbi50b3RhbF9zaGFwZS8oZSpvKnIpLHIsbyxlXVt0XX0pKSxyPW8ubWFwKChmdW5jdGlvbihuLGUpe3JldHVybiBvLnNsaWNlKDAsZSsxKS5yZWR1Y2UoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4rZX0pLDApfSkpLGk9XCJcIjtyZXR1cm4gci5mb3JFYWNoKChmdW5jdGlvbihuLGUpe2krPTA9PT1lP1wiXFxuICAgICAgICAgICAgaWYgKG9Qb3NbXCIrdCtcIl0gPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFwiOlwiXFxuICAgICAgICAgICAgZWxzZSBpZiAob1Bvc1tcIit0K1wiXSA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgb1Bvc1tcIit0K1wiXSA9IG9Qb3NbXCIrdCtcIl0gLSBcIityW2UtMV0rXCI7XFxuICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luX1wiK2UrXCIob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXCJ9KSksXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIC8vIOi+k+WHuuWdkOagh+i9rOaNouS4uui+k+WFpeWdkOagh1xcbiAgICAgICAgZmxvYXQgbyA9IDAuMDtcXG4gICAgICAgIFwiK2krXCJcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7XCJAYWxsXCI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxiZWhhdmlvcnM6W1wibm9ybWFsaXplRGltXCJdfSxjb25jYXRfbXVsOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PWUuZGltLG89T2JqZWN0LmtleXMobikuZmlsdGVyKChmdW5jdGlvbihuKXtyZXR1cm5cIm91dFwiIT09bn0pKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBuW2VdfSkpLm1hcCgoZnVuY3Rpb24obil7dmFyIGU9bi53aWR0aF9zaGFwZSxvPW4uaGVpZ2h0X3NoYXBlLHI9bi5jaGFubmVsO3JldHVybltuLnRvdGFsX3NoYXBlLyhlKm8qcikscixvLGVdW3RdfSkpLHI9by5tYXAoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG8uc2xpY2UoMCxlKzEpLnJlZHVjZSgoZnVuY3Rpb24obixlKXtyZXR1cm4gbitlfSksMCl9KSksaT1cIlwiO3JldHVybiByLmZvckVhY2goKGZ1bmN0aW9uKG4sZSl7aSs9MD09PWU/XCJcXG4gICAgICAgICAgICBpZiAob1Bvc1tcIit0K1wiXSA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgICAgICB9XCI6XCJcXG4gICAgICAgICAgICBlbHNlIGlmIChvUG9zW1wiK3QrXCJdIDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICBvUG9zW1wiK3QrXCJdID0gb1Bvc1tcIit0K1wiXSAtIFwiK3JbZS0xXStcIjtcXG4gICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW5fXCIrZStcIihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcIn0pKSxcIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcbiAgICAgICAgXCIraStcIlxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG8pKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntcIkBhbGxcIjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJub3JtYWxpemVEaW1cIl19LHNwbGl0OnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PWUudGFyZ2V0X2xlbmd0aCxvPWUubnVtLHI9ZS5kaW07cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGludCBsZW5ndGggPSBpbnQoXCIrdCtcIiAvIFwiK28rXCIpO1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBvUG9zW1wiK3IrXCJdID0gb1Bvc1tcIityK1wiXSArIGxheWVyX3J1bl90aW1lICogbGVuZ3RoO1xcbiAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcIm5vcm1hbGl6ZURpbVwiXX0sc29mdG1heDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm9yaWdpbixvPWUuYXhpcyxyPW87cmV0dXJuKCFvfHxvPDApJiYocj0ob3x8LTEpKzQpLFwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBjb25zdCBpbnQgbiA9IGludChcIit0LnRvdGFsX3NoYXBlK1wiL1wiK3QuY2hhbm5lbCtcIi9cIit0LmhlaWdodF9zaGFwZStcIi9cIit0LndpZHRoX3NoYXBlK1wiKTtcXG4gICAgICAgIGZsb2F0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3NbMF0sIG9Qb3NbMV0sIG9Qb3NbMl0sIG9Qb3NbM10pO1xcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBmbG9hdCB0b3RhbCA9IDAuMDtcXG4gICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG4gICAgICAgIGlmIChcIityK1wiID09IDApIHtcXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG47IGkrKyl7XFxuICAgICAgICAgICAgZmxvYXQgdGVtcCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oaSwgb1Bvc1sxXSwgb1Bvc1syXSwgb1Bvc1szXSk7XFxuICAgICAgICAgICAgdG90YWwgKz0gZXhwKHRlbXApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXMgPSBleHAobykgLyB0b3RhbDtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYgKFwiK3IrXCIgPT0gMSkge1xcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrdC5jaGFubmVsK1wiOyBpKyspe1xcbiAgICAgICAgICAgIGZsb2F0IHRlbXAgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3NbMF0sIGksIG9Qb3NbMl0sIG9Qb3NbM10pO1xcbiAgICAgICAgICAgIHRvdGFsICs9IGV4cCh0ZW1wKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmVzID0gZXhwKG8pIC8gdG90YWw7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3Qud2lkdGhfc2hhcGUrXCI7IGkrKyl7XFxuICAgICAgICAgICAgZmxvYXQgdGVtcCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvc1swXSwgb1Bvc1sxXSwgb1Bvc1syXSwgaSk7XFxuICAgICAgICAgICAgdG90YWwgKz0gZXhwKHRlbXApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXMgPSBleHAobykgLyB0b3RhbDtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChyZXMpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxiYXRjaG5vcm06e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5iaWFzLG89bi5zY2FsZSxyPW4ubWVhbixpPW4udmFyaWFuY2Uscz1lLmVwc2lsb247cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIC8vIOi+k+WHuuaVsOaNrlxcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG5cXG4gICAgICAgIC8vIOW9kuS4gOWMluaVsOaNrlxcbiAgICAgICAgdmVjNCBzY2FsZSA9IGdldFBpeGVsc0Zyb21UZXh0dXJlUG9zX3NjYWxlKHZlYzIoIGZsb2F0KG9Qb3MuZykgLyBmbG9hdChcIitvLndpZHRoX3RleHR1cmUrXCIpICsgMC4wMDAwMSwgMC4wKSk7XFxuICAgICAgICB2ZWM0IGJpYXMgPSBnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc19iaWFzKHZlYzIoIGZsb2F0KG9Qb3MuZykgLyBmbG9hdChcIit0LndpZHRoX3RleHR1cmUrXCIpICsgMC4wMDAwMSwgMC4wKSk7XFxuICAgICAgICB2ZWM0IG1lYW4gPSBnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc19tZWFuKHZlYzIoKGZsb2F0KG9Qb3MuZykpIC8gZmxvYXQoXCIrci53aWR0aF90ZXh0dXJlK1wiKSAgKyAwLjAwMDAxLCAwLjApKTtcXG4gICAgICAgIHZlYzQgdmFyaWFuY2UgPSBnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc192YXJpYW5jZShcXG4gICAgICAgICAgICB2ZWMyKChmbG9hdChvUG9zLmcpKSAvIGZsb2F0KFwiK2kud2lkdGhfdGV4dHVyZStcIikgKyAwLjAwMDAxLFxcbiAgICAgICAgICAgIDAuMClcXG4gICAgICAgICk7XFxuXFxuICAgICAgICBmbG9hdCB4ID0gKG8gLSBtZWFuWzBdKSAvIHNxcnQodmFyaWFuY2VbMF0gKyBcIitzK1wiKTtcXG4gICAgICAgIGZsb2F0IHJlcyA9IHNjYWxlWzBdICogeCArIGJpYXNbMF07XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLHNjYWxlOltcImdldFBpeGVsc0Zyb21UZXh0dXJlUG9zXCJdLGJpYXM6W1wiZ2V0UGl4ZWxzRnJvbVRleHR1cmVQb3NcIl0sbWVhbjpbXCJnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc1wiXSx2YXJpYW5jZTpbXCJnZXRQaXhlbHNGcm9tVGV4dHVyZVBvc1wiXX19LHJlc2hhcGU6bG4scmVzaGFwZTI6bG4sYmlsaW5lYXJfaW50ZXJwOmNuLHRyYW5zcG9zZTI6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9ZS5wZXJtX2FycixvPWUucGVybV9zaXplLHI9dFswXSxpPXRbMV0scz10WzJdO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG5cXG4gICAgICAgIC8vIOi9rOe9riDlnZDmoIflj5jmjaJcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBpZiAoXCIrbytcIiA9PSAxKSB7XFxuICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvc1swXSwgb1Bvc1sxXSwgb1Bvc1syXSwgb1Bvc1szXSk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChcIitvK1wiID09IDIpIHtcXG4gICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihcXG4gICAgICAgICAgICAgICAgb1Bvc1swXSwgb1Bvc1sxXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1soMiArIFwiK3IrXCIpID4gMyA/IDMgOiAoMiArIFwiK3IrXCIpXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1soMiArIFwiK2krXCIpID4gMyA/IDMgOiAoMiArIFwiK2krXCIpXVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChcIitvK1wiID09IDMpIHtcXG4gICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihcXG4gICAgICAgICAgICAgICAgb1Bvc1swXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1soMSArIFwiK3IrXCIpID4gMyA/IDMgOiAoMSArIFwiK3IrXCIpXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1soMSArIFwiK2krXCIpID4gMyA/IDMgOiAoMSArIFwiK2krXCIpXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1soMSArIFwiK3MrXCIpID4gMyA/IDMgOiAoMSArIFwiK3MrXCIpXVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmIChcIitvK1wiID09IDQpIHtcXG4gICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihcXG4gICAgICAgICAgICAgICAgb1Bvc1tcIityK1wiXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1tcIitpK1wiXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1tcIitzK1wiXSxcXG4gICAgICAgICAgICAgICAgb1Bvc1tcIit0WzNdK1wiXVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJub3JtYWxpemVQZXJtXCJdfSx1bnBhY2tlZF8yX3BhY2tlZDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICB2ZWM0IG91dDQ7XFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKykge1xcbiAgICAgICAgICAgIHZlYzQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdfb3JpZ2luKG9Qb3NbMF0sIG9Qb3NbMV0gKiA0ICsgaSwgb1Bvc1syXSwgb1Bvc1szXSk7XFxuICAgICAgICAgICAgb3V0NFtpXSA9IG9bMF07XFxuICAgICAgICB9XFxuICAgICAgICBzZXRQYWNrZWRPdXRwdXQob3V0NCk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdcIl19fSxwYWNrZWRfMl91bnBhY2tlZDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCByZXMgPSAwLjA7XFxuICAgICAgICBpbnQgYzEgPSBjYWxNb2Qob1Bvc1sxXSwgNCk7XFxuICAgICAgICB2ZWM0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nX29yaWdpbihvUG9zWzBdLCBvUG9zWzFdIC8gNCwgb1Bvc1syXSwgb1Bvc1szXSk7XFxuXFxuICAgICAgICBpZiAoYzEgPT0gMCkge1xcbiAgICAgICAgICAgIHJlcyA9IG8ucjtcXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPT0gMSkge1xcbiAgICAgICAgICAgIHJlcyA9IG8uZztcXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPT0gMikge1xcbiAgICAgICAgICAgIHJlcyA9IG8uYjtcXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPT0gMykge1xcbiAgICAgICAgICAgIHJlcyA9IG8uYTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChyZXMpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NQYWNraW5nXCJdfX0sdW5zcXVlZXplMjp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm9yaWdpbixvPWUuYXhlcyxyPXQubGVuZ3RoX3VuZm9ybWF0dGVkX3NoYXBlLGk9QXJyYXkuaXNBcnJheShvKT9vOltvXSxzPTQtci1pLmxlbmd0aCxhPWkubWFwKChmdW5jdGlvbihuKXtyZXR1cm4gbitzfSkpLHU9WzAsMSwyLDNdLmZpbHRlcigoZnVuY3Rpb24obil7cmV0dXJuLTE9PT1hLmluZGV4T2Yobil9KSkubWFwKChmdW5jdGlvbihuKXtyZXR1cm5cIm9Qb3NbXCIrbitcIl1cIn0pKSxsPUFycmF5LmZyb20obmV3IEFycmF5KGEubGVuZ3RoKSwoZnVuY3Rpb24oKXtyZXR1cm5cIjBcIn0pKTtyZXR1cm4gdS5zcGxpY2UuYXBwbHkodSxmdW5jdGlvbigpe2Zvcih2YXIgbj0wLGU9MCx0PWFyZ3VtZW50cy5sZW5ndGg7ZTx0O2UrKyluKz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciBvPUFycmF5KG4pLHI9MDtmb3IoZT0wO2U8dDtlKyspZm9yKHZhciBpPWFyZ3VtZW50c1tlXSxzPTAsYT1pLmxlbmd0aDtzPGE7cysrLHIrKylvW3JdPWlbc107cmV0dXJuIG99KFswLDBdLGwpKSxcIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcbiAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oXCIrdS5qb2luKFwiLFwiKStcIik7XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxmbGF0dGVuX2NvbnRpZ3VvdXNfcmFuZ2U6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5vcmlnaW4sbz1uLm91dDtyZXR1cm5cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGludCBzdW1WYWwgPSBvUG9zLmFcXG4gICAgICAgICAgICArIG9Qb3MuYiAqIFwiK28ud2lkdGhfc2hhcGUrXCJcXG4gICAgICAgICAgICArIG9Qb3MuZyAqIFwiK28uaGVpZ2h0X3NoYXBlK1wiICogXCIrby53aWR0aF9zaGFwZStcIlxcbiAgICAgICAgICAgICsgb1Bvcy5yICogXCIrby5jaGFubmVsK1wiICogXCIrby53aWR0aF9zaGFwZStcIiAqIFwiK28uaGVpZ2h0X3NoYXBlK1wiO1xcbiAgICAgICAgaXZlYzQgbmV3X29Qb3MgPSB0cmFuc2ZlckZyb21OSFdDdG9OQ0hXKFxcbiAgICAgICAgICAgIHN1bVZhbCxcXG4gICAgICAgICAgICBcIit0LmNoYW5uZWwrXCIsXFxuICAgICAgICAgICAgXCIrdC53aWR0aF9zaGFwZStcIixcXG4gICAgICAgICAgICBcIit0LmhlaWdodF9zaGFwZStcIixcXG4gICAgICAgICAgICBcIit0LnRvdGFsX3NoYXBlK1wiXFxuICAgICAgICApO1xcbiAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4obmV3X29Qb3MuciwgbmV3X29Qb3MuZywgbmV3X29Qb3MuYiwgbmV3X29Qb3MuYSk7XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQobykpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGNvbW1vbkZ1bmNDb25mOltcInRyYW5zZmVyRnJvbU5IV0N0b05DSFdcIl19LGZsYXR0ZW4yOmxuLGdyZWF0ZXJfdGhhbjp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBmbG9hdCB4ID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2lucHV0KG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCB5ID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2NvdW50ZXIob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChib29sKHggPj0geSkpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sY291bnRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxyZWR1Y2Vfc3VtOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICAvLyDovpPlh7rlnZDmoIfovazmjaLkuLrovpPlhaXlnZDmoIdcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2UuaW5wdXRzX2RpbStcIjsgaSsrKSB7XFxuICAgICAgICAgICAgb1Bvc1tcIitlLmRpbStcIl0gPSBpO1xcbiAgICAgICAgICAgIG8gKz0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpOztcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sYmVoYXZpb3JzOltcIm5vcm1hbGl6ZURpbVwiXX0sd2hlcmU6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIC8vIOi+k+WHuuWdkOagh+i9rOaNouS4uui+k+WFpeWdkOagh1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19pbnB1dChvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgZmxvYXQgeSA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19jb3VudGVyKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCBjb25kaXRpb24gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfY29uZGl0aW9uKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcblxcbiAgICAgICAgaWYgKGJvb2woY29uZGl0aW9uKSkge1xcbiAgICAgICAgICAgIG8gPSB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgbyA9IHk7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQobyk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxjb3VudGVyOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxjb25kaXRpb246W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0sY29ubmVjdDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm91dCxvPXQudG90YWxfc2hhcGUscj10LndpZHRoX3NoYXBlLGk9dC5oZWlnaHRfc2hhcGUscz10LmNoYW5uZWwsYT1kKFtvLyhyKmkqcykscyxpLHJdKSx1PU9iamVjdC5rZXlzKG4pLmZpbHRlcigoZnVuY3Rpb24obil7cmV0dXJuXCJvdXRcIiE9PW59KSkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gbltlXS50b3RhbF9zaGFwZX0pKSxsPXUubWFwKChmdW5jdGlvbihuLGUpe3JldHVybiB1LnNsaWNlKDAsZSsxKS5yZWR1Y2UoKGZ1bmN0aW9uKG4sZSl7cmV0dXJuIG4rZX0pLDApfSkpLGM9XCJcIjtyZXR1cm4gbC5mb3JFYWNoKChmdW5jdGlvbihuLGUpe2MrPTA9PT1lP1wiXFxuICAgICAgICAgICAgaWYgKHN1bVZhbCA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgY28gPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9vcmlnaW4oc3VtVmFsKTtcXG4gICAgICAgICAgICAgICAgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oY28uciwgY28uZywgY28uYiwgY28uYSk7XFxuICAgICAgICAgICAgfVwiOlwiXFxuICAgICAgICAgICAgZWxzZSBpZiAoc3VtVmFsIDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICBjbyA9IGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X29yaWdpbl9cIitlK1wiKHN1bVZhbCAtIFwiK2xbZS0xXStcIik7XFxuICAgICAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luX1wiK2UrXCIoY28uciwgY28uZywgY28uYiwgY28uYSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIFwifSkpLFwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcbiAgICAgICAgaXZlYzQgY287XFxuICAgICAgICBpbnQgc3VtVmFsID0gb1Bvcy5iICogXCIrYVsyXStcIiArIG9Qb3MuYTtcXG4gICAgICAgIFwiK2MrXCJcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7XCJAYWxsXCI6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCIsXCJnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleFwiXX19LHJlZHVjZV9tZWFuOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PWUuaW5wdXRzX2RpbTtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgLy8g6L6T5Ye65Z2Q5qCH6L2s5o2i5Li66L6T5YWl5Z2Q5qCHXFxuICAgICAgICBmbG9hdCBvID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIit0K1wiOyBpKyspIHtcXG4gICAgICAgICAgICBvUG9zW1wiK2UuZGltK1wiXSA9IGk7XFxuICAgICAgICAgICAgbyArPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICB9XFxuICAgICAgICBvID0gbyAvIGZsb2F0KFwiK3QrXCIpO1xcbiAgICAgICAgc2V0T3V0cHV0KG8pO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXCJub3JtYWxpemVEaW1cIl19LGhhcmRfc3dpc2g6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9ZS5vZmZzZXQsbz12b2lkIDA9PT10PzM6dCxyPWUuc2NhbGUsaT12b2lkIDA9PT1yPzY6cixzPWUudGhyZXNob2xkO3JldHVyblwiXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGZsb2F0IG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCByZXMgPSBvICogbWluKG1heCgwLjAsIG8gKyBmbG9hdChcIitvK1wiKSksIGZsb2F0KFwiKyh2b2lkIDA9PT1zPzY6cykrXCIpKSAvIGZsb2F0KFwiK2krXCIpO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlcyk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX19LG5lYXJlc3RfaW50ZXJwOl9uLG5lYXJlc3RfaW50ZXJwX3YyOl9uLGNhc3Q6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9XCJcIjtzd2l0Y2goZS5vdXRfZHR5cGUpe2Nhc2UgMDp0PVwiXFxuICAgICAgICAgICAgZmxvYXQgcmVzX2Jvb2wgPSAwLjA7XFxuICAgICAgICAgICAgaWYgKG8gIT0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIHJlc19ib29sID0gMS4wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzZXRPdXRwdXQocmVzX2Jvb2wpO1wiO2JyZWFrO2Nhc2UgMTpjYXNlIDI6Y2FzZSAzOnQ9XCJcXG4gICAgICAgICAgICBpbnQgcmVzX2ludCA9IGludChvKTtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQocmVzX2ludCkpO1wiO2JyZWFrO2RlZmF1bHQ6dD1cIiAgICAgICBcXG4gICAgICAgICAgICBmbG9hdCByZXNfZmxvYXQgPSBvO1xcbiAgICAgICAgICAgIHNldE91dHB1dChyZXNfZmxvYXQpO1wifXJldHVyblwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgLy8g6L6T5Ye65pWw5o2uXFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxmaWxsX2NvbnN0YW50X2JhdGNoX3NpemVfbGlrZTp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgZmxvYXQgcmVzID0gZmxvYXQoXCIrZS52YWx1ZStcIik7XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcblwifX0scm5uX21hdG11bDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLndlaWdodGxpc3RfMCxvPWUuaW5wdXRfYXhpcyxyPWUuc3RhdGVfYXhpcyxpPWUuYmF0Y2gscz1lLnJldmVyc2UsYT12b2lkIDAhPT1zJiZzP2ktby0xOm87cmV0dXJuXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG4gICAgICAgIC8vIOiOt+WPlm91dHB1dOeahOWdkOagh1xcbiAgICAgICAgaXZlYzQgb3V0X3BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgXFxuICAgICAgICBpZiAoXCIrKDA9PT1vKStcIikge1xcbiAgICAgICAgICAgIHJlcyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob3V0X3Bvc1swXSwgXCIrYStcIiwgb3V0X3Bvc1syXSwgb3V0X3Bvc1szXSk7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KHJlcyk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICBpdmVjNCBvcmlnaW5fcG9zID0gb3V0X3BvcztcXG4gICAgICAgIGl2ZWM0IHdlaWdodF9wb3MgPSBvdXRfcG9zO1xcblxcbiAgICAgICAgd2VpZ2h0X3Bvc1sxXSA9IDA7XFxuICAgICAgICB3ZWlnaHRfcG9zWzJdID0gd2VpZ2h0X3Bvc1szXTtcXG5cXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuICAgICAgICBmbG9hdCB3X2hoID0gMC4wO1xcbiAgICAgICAgZmxvYXQgcHJlc3RhdGVfaCA9IDAuMDtcXG4gICAgICAgIHJlcyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob3V0X3Bvc1swXSwgXCIrYStcIiwgb3V0X3Bvc1syXSwgb3V0X3Bvc1szXSk7XFxuICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK3Qud2lkdGhfc2hhcGUrXCI7IGorKykge1xcbiAgICAgICAgICAgIHByZXN0YXRlX2ggPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfcHJlc3RhdGUob3JpZ2luX3Bvc1swXSwgb3JpZ2luX3Bvc1sxXSwgb3JpZ2luX3Bvc1syXSwgaik7XFxuICAgICAgICAgICAgd19oaCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc193ZWlnaHRsaXN0XzAob3V0X3Bvc1swXSwgXCIrcitcIiwgb3V0X3Bvc1szXSwgaik7XFxuICAgICAgICAgICAgbyArPSB3X2hoICogcHJlc3RhdGVfaDtcXG4gICAgICAgIH1cXG4gICAgICAgIHJlcyArPSBvO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlcyk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxwcmVzdGF0ZTpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sd2VpZ2h0bGlzdF8wOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX19LHJubl9oaWRkZW46e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9ZS5zdGF0ZV9heGlzLG89ZS5oaWRkZW5fc2l6ZTtyZXR1cm5cIlxcbiAgICAvLyBzdGFydOWHveaVsFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgZmxvYXQgb3JpZ2luID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEpO1xcbiAgICAgICAgZmxvYXQgY2VsbCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hICsgXCIrbytcIik7XFxuICAgICAgICBmbG9hdCBhcHBlbmRlciA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hICsgXCIrMipvK1wiKTtcXG4gICAgICAgIGZsb2F0IGZvdXJ0aCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob1Bvcy5yLCBvUG9zLmcsIG9Qb3MuYiwgb1Bvcy5hICsgXCIrMypvK1wiKTtcXG4gICAgICAgIGZsb2F0IGNvdW50ZXIgID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX2NvdW50ZXIob1Bvcy5yLCBcIit0K1wiLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCBpID0gMS4wIC8gKDEuMCArIGV4cCgtb3JpZ2luKSk7XFxuICAgICAgICBmbG9hdCBmID0gMS4wIC8gKDEuMCArIGV4cCgtY2VsbCkpO1xcbiAgICAgICAgZmxvYXQgbyA9IDEuMCAvICgxLjAgKyBleHAoLWZvdXJ0aCkpO1xcbiAgICAgICAgZmxvYXQgYyA9IGYgKiBjb3VudGVyICsgaSAqIHRhbmhfY2FsYyhhcHBlbmRlcik7XFxuICAgICAgICBmbG9hdCBoID0gbyAqIHRhbmhfY2FsYyhjKTtcXG4gICAgICAgIFxcbiAgICAgICAgc2V0T3V0cHV0KGgpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sY291bnRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxybm5fY2VsbDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1lLnN0YXRlX2F4aXMsbz1lLmhpZGRlbl9zaXplO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvcmlnaW4gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIsIG9Qb3MuYSk7XFxuICAgICAgICBmbG9hdCBjZWxsID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEgKyBcIitvK1wiKTtcXG4gICAgICAgIGZsb2F0IGFwcGVuZGVyID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEgKyBcIisyKm8rXCIpO1xcbiAgICAgICAgZmxvYXQgZm91cnRoID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgb1Bvcy5iLCBvUG9zLmEgKyBcIiszKm8rXCIpO1xcbiAgICAgICAgZmxvYXQgY291bnRlciAgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfY291bnRlcihvUG9zLnIsIFwiK3QrXCIsIG9Qb3MuYiwgb1Bvcy5hKTtcXG4gICAgICAgIGZsb2F0IGkgPSAxLjAgLyAoMS4wICsgZXhwKC1vcmlnaW4pKTtcXG4gICAgICAgIGZsb2F0IGYgPSAxLjAgLyAoMS4wICsgZXhwKC1jZWxsKSk7XFxuICAgICAgICBmbG9hdCBjID0gZiAqIGNvdW50ZXIgKyBpICogdGFuaF9jYWxjKGFwcGVuZGVyKTtcXG4gICAgICAgIFxcbiAgICAgICAgc2V0T3V0cHV0KGMpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sY291bnRlcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19fSxybm5fb3JpZ2luOnttYWluRnVuYzpmdW5jdGlvbihuLGUpe3ZhciB0PW4ud2VpZ2h0bGlzdF8wLG89bi53ZWlnaHRsaXN0XzEscj1lLnN0YXRlX2F4aXM7cmV0dXJuXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgcmVzID0gMC4wO1xcbiAgICAgICAgLy8g6I635Y+Wb3V0cHV055qE5Z2Q5qCHXFxuICAgICAgICBpdmVjNCBvdXRfcG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBpdmVjNCBvcmlnaW5fcG9zID0gb3V0X3BvcztcXG4gICAgICAgIGl2ZWM0IHdlaWdodF9wb3MgPSBvdXRfcG9zO1xcbiAgICAgIFxcbiAgICAgICAgd2VpZ2h0X3Bvc1sxXSA9IDA7XFxuICAgICAgICB3ZWlnaHRfcG9zWzJdID0gd2VpZ2h0X3Bvc1szXTtcXG5cXG4gICAgICAgIGZsb2F0IGJfaWggPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfd2VpZ2h0bGlzdF8yKDAsIDAsIDAsIG91dF9wb3NbM10pO1xcbiAgICAgICAgZmxvYXQgYl9oaCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc193ZWlnaHRsaXN0XzMoMCwgMCwgMCwgb3V0X3Bvc1szXSk7XFxuICAgICAgICBcXG4gICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrdC53aWR0aF9zaGFwZStcIjsgaisrKSB7XFxuICAgICAgICAgICAgZmxvYXQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4ob3JpZ2luX3Bvc1swXSwgb3JpZ2luX3Bvc1sxXSwgMCwgaik7XFxuICAgICAgICAgICAgZmxvYXQgd19paCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc193ZWlnaHRsaXN0XzAoMCwgMCwgb3V0X3Bvc1szXSwgaik7XFxuICAgICAgICAgICAgcmVzICs9IHdfaWggKiBvO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmVzICs9IGJfaWg7XFxuXFxuICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK28ud2lkdGhfc2hhcGUrXCI7IGorKykge1xcbiAgICAgICAgICAgICAgICBmbG9hdCBwcmVzdGF0ZSA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19wcmVzdGF0ZSgwLCAwLCAwLCBqKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgd19oaCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc193ZWlnaHRsaXN0XzEoMCwgXCIrcitcIiwgb3V0X3Bvc1szXSwgaik7XFxuICAgICAgICAgICAgICAgIHJlcyArPSB3X2hoICogcHJlc3RhdGU7XFxuICAgICAgICB9XFxuICAgICAgICByZXMgKz0gYl9oaDtcXG4gXFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLHByZXN0YXRlOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSx3ZWlnaHRsaXN0XzA6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLHdlaWdodGxpc3RfMTpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl0sd2VpZ2h0bGlzdF8yOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSx3ZWlnaHRsaXN0XzM6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfX0scG9vbDJkX2F2Zzp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm9yaWdpbixvPWUuc3RyaWRlcyxyPXZvaWQgMD09PW8/W106byxpPWUucGFkZGluZ3Mscz12b2lkIDA9PT1pP1tdOmksYT1lLmtzaXplLHU9clswXSxsPXZvaWQgMD09PXU/MTp1LGM9clsxXSxmPXZvaWQgMD09PWM/MTpjLGg9c1swXSxwPXZvaWQgMD09PWg/MDpoLGQ9c1sxXSxnPXZvaWQgMD09PWQ/MDpkLF89YVswXSxtPWFbMV07cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGZsb2F0IHJlcyA9IDAuMDtcXG4gICAgICAgIC8vIOiOt+WPlm91dHB1dOeahOWdkOagh1xcbiAgICAgICAgaXZlYzQgb3V0X3BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgLy8gWOOAgVnmlrnlkJHnmoTnp7vliqjmraXplb9cXG4gICAgICAgIGludCBveV9iYXNlID0gb3V0X3Bvc1syXSAqIFwiK2wrXCIgLSBcIitwK1wiO1xcbiAgICAgICAgaW50IG94X2Jhc2UgPSBvdXRfcG9zWzNdICogXCIrZitcIiAtIFwiK2crXCI7XFxuICAgICAgICBmb3IgKGludCBmeSA9IDA7IGZ5IDwgXCIrXytcIjsgZnkrKykge1xcbiAgICAgICAgICAgIGludCBveSA9IG95X2Jhc2UgKyBmeTtcXG4gICAgICAgICAgICBpZiAob3kgPj0gXCIrdC5oZWlnaHRfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChveSA8IDApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZvciAoaW50IGZ4ID0gMDsgZnggPCBcIittK1wiOyBmeCsrKSB7XFxuICAgICAgICAgICAgICAgIGludCBveCA9IG94X2Jhc2UgKyBmeDtcXG4gICAgICAgICAgICAgICAgaWYgKG94ID49IFwiK3Qud2lkdGhfc2hhcGUrXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChveCA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbuaVsOaNrlxcbiAgICAgICAgICAgICAgICBmbG9hdCBjdXJyID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvdXRfcG9zWzBdLCBvdXRfcG9zWzFdLCBveSwgb3gpO1xcbiAgICAgICAgICAgICAgICByZXMgKz0gY3VycjtcXG4gICAgICAgICAgICAgICAgLy8g5Zyo5bmz5Z2H5rGg5YyW5qih5byP5b+955Wl5aGr5YWF5YC8KGV4Y2x1c2l2Zem7mOiupOS4unRydWXvvIlcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXMgPSByZXMgLyBmbG9hdChcIitfK1wiICogXCIrbStcIik7XFxuICAgICAgICBzZXRPdXRwdXQocmVzKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOntvcmlnaW46W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdfSxiZWhhdmlvcnM6W1wic2V0UGFja2VkXCIsXCJzZXRBZGFwdGl2ZVwiLFwiaXNHbG9iYWxQb29saW5nXCJdfSxwcmVsdTpkbihcInByZWx1XCIpLHJlbHU2OmRuKFwicmVsdTZcIiksbGVha3lSZWx1OmRuKFwibGVha3lSZWx1XCIpLHNjYWxlOmRuKFwic2NhbGVcIiksc2lnbW9pZDpkbihcInNpZ21vaWRcIikscmVsdTpkbihcInJlbHVcIiksaGFyZF9zaWdtb2lkOmRuKFwiaGFyZF9zaWdtb2lkXCIpLHBvdzpkbihcInBvd1wiKSxzcXJ0OmRuKFwic3FydFwiKSx0YW5oOmRuKFwidGFuaFwiKSxzcXVlZXplMjpnbixwYWQzZDp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm9yaWdpbixvPWUucGFkZGluZ3Mscj1lLm1vZGUsaT1lLnZhbHVlLHM9ZnVuY3Rpb24obil7dmFyIGU9bi50b3RhbF9zaGFwZSx0PW4uY2hhbm5lbCxvPW4uaGVpZ2h0X3NoYXBlLHI9bi53aWR0aF9zaGFwZTtyZXR1cm5bZS90L28vcix0LG8scl19KHQpLGE9e3JlZmxlY3Q6XCJcXG4gICAgICAgICAgICBpbnQgYTtcXG4gICAgICAgICAgICBpbnQgYjtcXG4gICAgICAgICAgICBpZiAob1Bvcy5hIC0gXCIrb1swXStcIiA8IDApIHtcXG4gICAgICAgICAgICAgICAgYSA9IFwiK29bMF0rXCIgLSBvUG9zLmE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKG9Qb3MuYSAtIFwiK29bMF0rXCIgPj0gXCIrc1szXStcIikge1xcbiAgICAgICAgICAgICAgICBhID0gXCIrc1szXStcIiAtIChvUG9zLmEgLSBcIitvWzBdK1wiIC0gXCIrc1szXStcIiArIDEpIC0gMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGEgPSBvUG9zLmEgLSBcIitvWzBdK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAob1Bvcy5iIC0gXCIrb1syXStcIiA8IDApIHtcXG4gICAgICAgICAgICAgICAgYiA9IFwiK29bMl0rXCIgLSBvUG9zLmI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKG9Qb3MuYiAtIFwiK29bMl0rXCIgPj0gXCIrc1syXStcIikge1xcbiAgICAgICAgICAgICAgICBiID0gXCIrc1syXStcIiAtIChvUG9zLmIgLSBcIitvWzJdK1wiIC0gXCIrc1syXStcIiArIDEpIC0gMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGIgPSBvUG9zLmIgLSBcIitvWzJdK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihvUG9zLnIsIG9Qb3MuZywgYiwgYSk7XFxuICAgICAgICBcIixyZXBsaWNhdGU6XCJcXG4gICAgICAgICAgICBpbnQgYTtcXG4gICAgICAgICAgICBpbnQgYjtcXG4gICAgICAgICAgICBpZiAob1Bvcy5hIC0gXCIrb1swXStcIiA8IDApIHtcXG4gICAgICAgICAgICAgICAgYSA9IDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKG9Qb3MuYSAtIFwiK29bMF0rXCIgPj0gXCIrc1szXStcIikge1xcbiAgICAgICAgICAgICAgICBhID0gXCIrc1szXStcIiAtIDE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgICBhID0gb1Bvcy5hIC0gXCIrb1swXStcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKG9Qb3MuYiAtIFwiK29bMl0rXCIgPCAwKSB7XFxuICAgICAgICAgICAgICAgIGIgPSAwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChvUG9zLmIgLSBcIitvWzJdK1wiID49IFwiK3NbMl0rXCIpIHtcXG4gICAgICAgICAgICAgICAgYiA9IFwiK3NbMl0rXCIgLSAxO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgYiA9IG9Qb3MuYiAtIFwiK29bMl0rXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBiLCBhKTtcXG4gICAgICAgIFwiLGNpcmN1bGFyOlwiXFxuICAgICAgICAgICAgaW50IGE7XFxuICAgICAgICAgICAgaW50IGI7XFxuICAgICAgICAgICAgaWYgKG9Qb3MuYSAtIFwiK29bMF0rXCIgPCAwKSB7XFxuICAgICAgICAgICAgICAgIGEgPSBpbnQobW9kKGZsb2F0KFwiK29bMF0rXCIgKyBvUG9zLmEgLSAxKSwgZmxvYXQoXCIrc1szXStcIikpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAob1Bvcy5hIC0gXCIrb1swXStcIiA+PSBcIitzWzNdK1wiKSB7XFxuICAgICAgICAgICAgICAgIGEgPSBpbnQobW9kKGZsb2F0KG9Qb3MuYSAtIFwiK29bMF0rXCIgLSBcIitzWzNdK1wiKSwgZmxvYXQoXCIrc1szXStcIikpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIGEgPSBvUG9zLmEgLSBcIitvWzBdK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAob1Bvcy5iIC0gXCIrb1syXStcIiA8IDApIHtcXG4gICAgICAgICAgICAgICAgYiA9IGludChtb2QoZmxvYXQoXCIrb1syXStcIiArIG9Qb3MuYiAtIDEpLCBmbG9hdChcIitzWzJdK1wiKSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIGlmIChvUG9zLmIgLSBcIitvWzJdK1wiID49IFwiK3NbMl0rXCIpIHtcXG4gICAgICAgICAgICAgICAgYiA9IGludChtb2QoZmxvYXQob1Bvcy5iIC0gXCIrb1syXStcIiAtIFwiK3NbMl0rXCIpLCBmbG9hdChcIitzWzJdK1wiKSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgYiA9IG9Qb3MuYiAtIFwiK29bMl0rXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBiLCBhKTtcXG4gICAgICAgIFwiLGNvbnN0YW50OlwiXCIsdW5kZWZpbmVkOlwiXCJ9O3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBvUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBmbG9hdCBvID0gXCIrKGl8fFwiMC4wXCIpK1wiO1xcbiAgICAgICAgaWYgKG9Qb3MuYSAtIFwiK29bMF0rXCIgPj0gMFxcbiAgICAgICAgICAgICYmIG9Qb3MuYiAtIFwiK29bMl0rXCIgPj0gMFxcbiAgICAgICAgICAgICYmIG9Qb3MuYSAtIFwiK29bMF0rXCIgPCBcIitzWzNdK1wiXFxuICAgICAgICAgICAgJiYgb1Bvcy5iIC0gXCIrb1syXStcIiA8IFwiK3NbMl0rXCJcXG4gICAgICAgICkge1xcbiAgICAgICAgICAgIG8gPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKG9Qb3Muciwgb1Bvcy5nLCBvUG9zLmIgLSBcIitvWzJdK1wiLCBvUG9zLmEgLSBcIitvWzBdK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIFwiK2Fbcl0rXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX19LGJpbGluZWFyX2ludGVycF92MjpmbixzaHVmZmxlX2NoYW5uZWw6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5vdXQsbz1lLmdyb3VwLHI9dm9pZCAwPT09bz8yOm8saT10LnRvdGFsX3NoYXBlLHM9dC5oZWlnaHRfc2hhcGUsYT10LndpZHRoX3NoYXBlLHU9dC5jaGFubmVsLGw9WzEsMCwyLDNdO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICAvLyDovpPlh7rmlbDmja5cXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIGZsb2F0IG8gPSAwLjA7XFxuXFxuICAgICAgICBpbnQgc3VtVmFsID0gb1Bvcy5hXFxuICAgICAgICAgICAgKyBvUG9zLmIgKiBcIithK1wiXFxuICAgICAgICAgICAgKyBvUG9zLmcgKiBcIitzK1wiICogXCIrYStcIlxcbiAgICAgICAgICAgICsgb1Bvcy5yICogXCIrdStcIiAqIFwiK2ErXCIgKiBcIitzK1wiO1xcblxcbiAgICAgICAgaXZlYzQgdHJhbnNwb3NlX291dF9wb3MgPSB0cmFuc2ZlckZyb21OSFdDdG9OQ0hXKFxcbiAgICAgICAgICAgIHN1bVZhbCxcXG4gICAgICAgICAgICBcIityK1wiLFxcbiAgICAgICAgICAgIFwiK2ErXCIsXFxuICAgICAgICAgICAgXCIrcytcIixcXG4gICAgICAgICAgICBcIitpK1wiXFxuICAgICAgICApO1xcblxcbiAgICAgICAgaXZlYzQgdHJhbnNwb3NlX2luX3BvcyA9IGl2ZWM0KHRyYW5zcG9zZV9vdXRfcG9zW1wiK2xbMF0rXCJdLFxcbiAgICAgICAgICAgIHRyYW5zcG9zZV9vdXRfcG9zW1wiK2xbMV0rXCJdLCB0cmFuc3Bvc2Vfb3V0X3Bvc1tcIitsWzJdK1wiXSwgdHJhbnNwb3NlX291dF9wb3NbXCIrbFszXStcIl0pO1xcbiAgICAgICAgaW50IHN1bVZhbDIgPSB0cmFuc3Bvc2VfaW5fcG9zLmFcXG4gICAgICAgICAgICArIHRyYW5zcG9zZV9pbl9wb3MuYiAqIFwiK2ErXCJcXG4gICAgICAgICAgICArIHRyYW5zcG9zZV9pbl9wb3MuZyAqIFwiK3MrXCIgKiBcIithK1wiXFxuICAgICAgICAgICAgKyB0cmFuc3Bvc2VfaW5fcG9zLnIgKiBcIit1L3IrXCIgKiBcIithK1wiICogXCIrcytcIjtcXG4gICAgICAgIGl2ZWM0IG9yaWdpbl9vUG9zID0gdHJhbnNmZXJGcm9tTkhXQ3RvTkNIVyhcXG4gICAgICAgICAgICBzdW1WYWwyLFxcbiAgICAgICAgICAgIFwiK3UrXCIsXFxuICAgICAgICAgICAgXCIrYStcIixcXG4gICAgICAgICAgICBcIitzK1wiLFxcbiAgICAgICAgICAgIFwiK2krXCJcXG4gICAgICAgICk7XFxuXFxuXFxuICAgICAgICBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihcXG4gICAgICAgICAgICBvcmlnaW5fb1Bvc1swXSxcXG4gICAgICAgICAgICBvcmlnaW5fb1Bvc1sxXSxcXG4gICAgICAgICAgICBvcmlnaW5fb1Bvc1syXSxcXG4gICAgICAgICAgICBvcmlnaW5fb1Bvc1szXVxcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sY29tbW9uRnVuY0NvbmY6W1widHJhbnNmZXJGcm9tTkhXQ3RvTkNIV1wiXX0scGFja19vdXQ6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7cmV0dXJuXCJcXG5cXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgdmVjMiBvdXRDb29yZCA9IHZDb29yZC54eSAqIF8yZF9zaGFwZV90ZXh0dXJlX291dDtcXG4gICAgICAgIGludCBpbmRleCA9IGludChvdXRDb29yZC54KSArIGludChvdXRDb29yZC55KSAqIGludChcIituLm91dC53aWR0aF90ZXh0dXJlK1wiKTtcXG5cXG4gICAgICAgIGludCBmaXJzdCA9IGluZGV4ICogNDtcXG4gICAgICAgIGludCBzZWMgPSBpbmRleCAqIDQgKyAxO1xcbiAgICAgICAgaW50IHRoaXJkID0gaW5kZXggKiA0ICsgMjtcXG4gICAgICAgIGludCBmb3VydGggPSBpbmRleCAqIDQgKyAzO1xcblxcbiAgICAgICAgaXZlYzQgclBvcyA9IGdldFRlbnNvclBvc0Zyb21BcnJheUluZGV4X29yaWdpbihmaXJzdCk7XFxuICAgICAgICBpdmVjNCBnUG9zID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfb3JpZ2luKHNlYyk7XFxuICAgICAgICBpdmVjNCBiUG9zID0gZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhfb3JpZ2luKHRoaXJkKTtcXG4gICAgICAgIGl2ZWM0IGFQb3MgPSBnZXRUZW5zb3JQb3NGcm9tQXJyYXlJbmRleF9vcmlnaW4oZm91cnRoKTtcXG5cXG4gICAgICAgIGZsb2F0IHIgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKHJQb3MuciwgclBvcy5nLCByUG9zLmIsIHJQb3MuYSk7XFxuICAgICAgICBmbG9hdCBnID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihnUG9zLnIsIGdQb3MuZywgZ1Bvcy5iLCBnUG9zLmEpO1xcbiAgICAgICAgZmxvYXQgYiA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19vcmlnaW4oYlBvcy5yLCBiUG9zLmcsIGJQb3MuYiwgYlBvcy5hKTtcXG4gICAgICAgIGZsb2F0IGEgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3Nfb3JpZ2luKGFQb3MuciwgYVBvcy5nLCBhUG9zLmIsIGFQb3MuYSk7XFxuXFxuICAgICAgICBzZXRQYWNrZWRPdXRwdXQodmVjNChyLCBnLCBiLCBhKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiLFwiZ2V0VGVuc29yUG9zRnJvbUFycmF5SW5kZXhcIl19fSxuaHdjXzJfbmNodzp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1uLm9yaWdpbixvPW4ub3V0O3JldHVyblwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IG9Qb3MgPSBnZXRPdXRwdXRUZW5zb3JQb3MoKTtcXG4gICAgICAgIC8vIOi+k+WHuuWdkOagh+i9rOaNouS4uui+k+WFpeWdkOagh1xcbiAgICAgICAgaW50IHN1bVZhbCA9IG9Qb3MuYSAqIFwiK28uY2hhbm5lbCtcIlxcbiAgICAgICAgICAgICsgb1Bvcy5iICogXCIrby53aWR0aF9zaGFwZStcIiAqIFwiK28uY2hhbm5lbCtcIlxcbiAgICAgICAgICAgICsgb1Bvcy5nXFxuICAgICAgICAgICAgKyBvUG9zLnIgKiBcIitvLmNoYW5uZWwrXCIgKiBcIitvLndpZHRoX3NoYXBlK1wiICogXCIrby5oZWlnaHRfc2hhcGUrXCI7XFxuICAgICAgICBpdmVjNCBuZXdfb1BvcyA9IHRyYW5zZmVyRnJvbU5IV0N0b05DSFcoXFxuICAgICAgICAgICAgc3VtVmFsLFxcbiAgICAgICAgICAgIFwiK3QuY2hhbm5lbCtcIixcXG4gICAgICAgICAgICBcIit0LndpZHRoX3NoYXBlK1wiLFxcbiAgICAgICAgICAgIFwiK3QuaGVpZ2h0X3NoYXBlK1wiLFxcbiAgICAgICAgICAgIFwiK3QudG90YWxfc2hhcGUrXCJcXG4gICAgICAgICk7XFxuICAgICAgICBmbG9hdCBvID0gZ2V0VmFsdWVGcm9tVGVuc29yUG9zX29yaWdpbihuZXdfb1Bvcy5yLCBuZXdfb1Bvcy5nLCBuZXdfb1Bvcy5iLCBuZXdfb1Bvcy5hKTtcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChvKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXX0sY29tbW9uRnVuY0NvbmY6W1widHJhbnNmZXJGcm9tTkhXQ3RvTkNIV1wiXX0sZmVlZFBvc3Q6e21haW5GdW5jOmZ1bmN0aW9uKG4sZSl7dmFyIHQ9bi5vdXQsbz1lLm1lYW4scj12b2lkIDA9PT1vP1swLDAsMF06byxpPWUuc3RkLHM9dm9pZCAwPT09aT9bMSwxLDFdOmksYT10LnRvdGFsX3NoYXBlLHU9dC5oZWlnaHRfc2hhcGUsbD10LndpZHRoX3NoYXBlLGM9dC5jaGFubmVsO3JldHVyblwiXFxuICAgIC8vIHN0YXJ05Ye95pWwXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpdmVjNCBuaHdjUG9zID0gZ2V0T3V0cHV0VGVuc29yUG9zKCk7XFxuICAgICAgICBpbnQgc3VtVmFsID0gbmh3Y1Bvcy5hXFxuICAgICAgICAgICAgKyBuaHdjUG9zLmIgKiBcIitsK1wiXFxuICAgICAgICAgICAgKyBuaHdjUG9zLmcgKiBcIit1K1wiICogXCIrbCtcIlxcbiAgICAgICAgICAgICsgbmh3Y1Bvcy5yICogXCIrYytcIiAqIFwiK2wrXCIgKiBcIit1K1wiO1xcblxcbiAgICAgICAgaXZlYzQgb1BvcyA9IHRyYW5zZmVyRnJvbU5IV0N0b05DSFcoXFxuICAgICAgICAgICAgc3VtVmFsLFxcbiAgICAgICAgICAgIFwiK2MrXCIsXFxuICAgICAgICAgICAgXCIrbCtcIixcXG4gICAgICAgICAgICBcIit1K1wiLFxcbiAgICAgICAgICAgIFwiK2ErXCJcXG4gICAgICAgICk7XFxuICAgICAgICBmbG9hdCByZXMgPSAwLjA7XFxuICAgICAgICBpbnQgYzEgPSBpbnQobW9kKGZsb2F0KG9Qb3NbMV0pLCA0LjApKTtcXG4gICAgICAgIGludCBjID0gb1Bvc1sxXTtcXG4gICAgICAgIHZlYzQgbyA9IGdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdfb3JpZ2luKG9Qb3NbMF0sIGMgLyA0LCBvUG9zWzJdLCBvUG9zWzNdKTtcXG5cXG4gICAgICAgIGlmIChjMSA9PSAwKSB7XFxuICAgICAgICAgICAgcmVzID0gby5yO1xcbiAgICAgICAgfSBlbHNlIGlmIChjMSA9PSAxKSB7XFxuICAgICAgICAgICAgcmVzID0gby5nO1xcbiAgICAgICAgfSBlbHNlIGlmIChjMSA9PSAyKSB7XFxuICAgICAgICAgICAgcmVzID0gby5iO1xcbiAgICAgICAgfSBlbHNlIGlmIChjMSA9PSAzKSB7XFxuICAgICAgICAgICAgcmVzID0gby5hO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGMgPT0gMCkge1xcbiAgICAgICAgICAgIHJlcyA9IChyZXMgLSBmbG9hdChcIityWzBdK1wiKSkgLyBmbG9hdChcIitzWzBdK1wiKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PSAxKSB7XFxuICAgICAgICAgICAgcmVzID0gKHJlcyAtIGZsb2F0KFwiK3JbMV0rXCIpKSAvIGZsb2F0KFwiK3NbMV0rXCIpO1xcbiAgICAgICAgfSBlbHNlIGlmIChjID09IDIpIHtcXG4gICAgICAgICAgICByZXMgPSAocmVzIC0gZmxvYXQoXCIrclsyXStcIikpIC8gZmxvYXQoXCIrc1syXStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQocmVzKSk7XFxuICAgIH1cXG4gICAgXCJ9LHRleHR1cmVGdW5jQ29uZjp7b3JpZ2luOltcImdldFZhbHVlRnJvbVRlbnNvclBvc1BhY2tpbmdcIl19LGNvbW1vbkZ1bmNDb25mOltcInRyYW5zZmVyRnJvbU5IV0N0b05DSFdcIl19LGltZ0ZlZWQ6e21haW5GdW5jOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXG4gICAgdW5pZm9ybSB2ZWMyIHVfc2NhbGU7XFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICB2ZWMyIG91dENvb3JkID0gdkNvb3JkLnh5O1xcbiAgICAgICAgdmVjMiBuZXdQb3MgPSB2Q29vcmQgLyB1X3NjYWxlO1xcbiAgICAgICAgdmVjMiBzdGFydFBvcyA9ICgxLjAgLyB1X3NjYWxlIC0gMS4wKSAvIDIuMDtcXG4gICAgICAgIGJvb2wgZXhjZWVkWCA9IHVfc2NhbGUueSA9PSAxLjAgJiYgKG5ld1Bvcy54IDwgc3RhcnRQb3MueCB8fCBuZXdQb3MueCA+ICgxLjAgKyBzdGFydFBvcy54KSk7XFxuICAgICAgICBib29sIGV4Y2VlZFkgPSB1X3NjYWxlLnggPT0gMS4wICYmIChuZXdQb3MueSA8IHN0YXJ0UG9zLnkgfHwgbmV3UG9zLnkgPiAoMS4wICsgc3RhcnRQb3MueSkpO1xcbiAgICAgICAgaWYgKGV4Y2VlZFggfHwgZXhjZWVkWSkge1xcbiAgICAgICAgICAgIHNldFBhY2tlZE91dHB1dCh2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCkpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIG5ld1BvcyA9IG5ld1BvcyAtIHN0YXJ0UG9zO1xcbiAgICAgICAgdmVjNCBjb3VudGVyID0gVEVYVFVSRTJEKHRleHR1cmVfb3JpZ2luLCBuZXdQb3MpO1xcbiAgICAgICAgc2V0UGFja2VkT3V0cHV0KGNvdW50ZXIpO1xcbiAgICB9XFxuICAgIFwifSx0ZXh0dXJlRnVuY0NvbmY6e29yaWdpbjpbXX19LGJveF9jb2Rlcjp7bWFpbkZ1bmM6ZnVuY3Rpb24obixlKXt2YXIgdD1cImRlY29kZV9jZW50ZXJfc2l6ZVwiPT09ZS5jb2RlX3R5cGU7cmV0dXJuXCJcXG4gICAgLy8gc3RhcnTlh73mlbBcXG4gICAgdmVjMiBnZXRQcmlvckJveERhdGEoaW50IHIsIGludCBnLCBpbnQgYiwgaW50IG0sIGludCBuKSB7XFxuICAgICAgICBmbG9hdCBzdGFydCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19wcmlvcmJveChyLCBnLCBiLCBtKTtcXG4gICAgICAgIGZsb2F0IGVuZCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc19wcmlvcmJveChyLCBnLCBiLCBuKTtcXG4gICAgICAgIGZsb2F0IGxlbiA9IGVuZCAtIHN0YXJ0O1xcbiAgICAgICAgcmV0dXJuIHZlYzIoc3RhcnQgKyBsZW4gLyAyLjAsIGxlbik7XFxuICAgIH1cXG4gICAgdmVjMiBnZXRCb3hWYXJEYXRhKGludCByLCBpbnQgZywgaW50IGIsIGludCBtLCBpbnQgbikge1xcbiAgICAgICAgcmV0dXJuIHZlYzIoXFxuICAgICAgICAgICAgZ2V0VmFsdWVGcm9tVGVuc29yUG9zX3ByaW9yYm94dmFyKHIsIGcsIGIsIG0pLFxcbiAgICAgICAgICAgIGdldFZhbHVlRnJvbVRlbnNvclBvc19wcmlvcmJveHZhcihyLCBnLCBiLCBuKVxcbiAgICAgICAgKTtcXG4gICAgfVxcbiAgICB2ZWMyIGdldFRhcmdldEJveERhdGEoaW50IHIsIGludCBnLCBpbnQgYiwgaW50IG0sIGludCBuKSB7XFxuICAgICAgICBcIisodD9cIlxcbiAgICAgICAgICAgIHJldHVybiB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfdGFyZ2V0Ym94KHIsIGcsIGIsIG0pLFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfdGFyZ2V0Ym94KHIsIGcsIGIsIG4pXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgICAgZmxvYXQgc3RhcnQgPSBnZXRWYWx1ZUZyb21UZW5zb3JQb3NfdGFyZ2V0Ym94KHIsIGcsIGIsIG0pO1xcbiAgICAgICAgICAgIGZsb2F0IGVuZCA9IGdldFZhbHVlRnJvbVRlbnNvclBvc190YXJnZXRib3gociwgZywgYiwgbik7XFxuICAgICAgICAgICAgZmxvYXQgbGVuID0gZW5kIC0gc3RhcnQ7XFxuICAgICAgICAgICAgcmV0dXJuIHZlYzIoc3RhcnQgKyBsZW4gLyAyLjAsIGxlbik7XFxuICAgICAgICBcIikrXCJcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgaXZlYzQgb1BvcyA9IGdldE91dHB1dFRlbnNvclBvcygpO1xcbiAgICAgICAgaW50IHIgPSBpbnQob1Bvcy5yKTtcXG4gICAgICAgIGludCBnID0gaW50KG9Qb3MuZyk7XFxuICAgICAgICBpbnQgYiA9IGludChvUG9zLmIpO1xcbiAgICAgICAgaW50IGEgPSBpbnQob1Bvcy5hKTtcXG4gICAgICAgIC8vIOi+k+WHuuWdkOagh+i9rOaNouS4uui+k+WFpeWdkOagh1xcbiAgICAgICAgZmxvYXQgbyA9IDAuMDtcXG5cXG4gICAgICAgIGludCBtID0gMDtcXG4gICAgICAgIGludCBuID0gMDtcXG4gICAgICAgIGlmIChhID09IDAgfHwgYSA9PSBcIisodD8yOjEpK1wiKSB7XFxuICAgICAgICAgICAgbSA9IDA7XFxuICAgICAgICAgICAgbiA9IDI7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBtID0gMTtcXG4gICAgICAgICAgICBuID0gMztcXG4gICAgICAgIH1cXG4gICAgICAgIHZlYzIgcHJpb3Jib3ggPSBnZXRQcmlvckJveERhdGEociwgZywgYiwgbSwgbik7XFxuICAgICAgICB2ZWMyIGJveHZhciA9IGdldEJveFZhckRhdGEociwgZywgYiwgbSwgbik7XFxuICAgICAgICB2ZWMyIHRhcmdldGJveCA9IGdldFRhcmdldEJveERhdGEociwgZywgYiwgbSwgbik7XFxuICAgICAgICBmbG9hdCBwMSA9IHByaW9yYm94LnI7XFxuICAgICAgICBmbG9hdCBwMiA9IHByaW9yYm94Lmc7XFxuICAgICAgICBmbG9hdCB0MSA9IHRhcmdldGJveC5yO1xcbiAgICAgICAgZmxvYXQgdDIgPSB0YXJnZXRib3guZztcXG4gICAgICAgIGZsb2F0IHYxID0gYm94dmFyLnI7XFxuICAgICAgICBmbG9hdCB2MiA9IGJveHZhci5nO1xcblxcbiAgICAgICAgXCIrKHQ/XCJcXG4gICAgICAgICAgICBmbG9hdCBiMSA9IHAyICogdjEgKiB0MSArIHAxO1xcbiAgICAgICAgICAgIGZsb2F0IGIyID0gZXhwKHYyICogdDIpICogcDI7XFxuICAgICAgICAgICAgaWYgKGEgPT0gMCB8fCBhID09IDEpIHtcXG4gICAgICAgICAgICAgICAgbyA9IGIxIC0gYjIgLyAyLjAgO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbyA9IGIxICsgYjIgLyAyLjA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXCI6XCJcXG4gICAgICAgICAgICBpZiAoYSA9PSAwIHx8IGEgPT0gMSkge1xcbiAgICAgICAgICAgICAgICBvID0gKHQxIC0gcDEpIC8gcDIgLyB2MTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgIG8gPSBsb2coYWJzKHQyIC8gcDIpKSAvIHYyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIFwiKStcIlxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG8pKTtcXG4gICAgfVxcbiAgICBcIn0sdGV4dHVyZUZ1bmNDb25mOnt0YXJnZXRib3g6W1wiZ2V0VmFsdWVGcm9tVGVuc29yUG9zXCJdLHByaW9yYm94OltcImdldFZhbHVlRnJvbVRlbnNvclBvc1wiXSxwcmlvcmJveHZhcjpbXCJnZXRWYWx1ZUZyb21UZW5zb3JQb3NcIl19LGJlaGF2aW9yczpbXX0sZGVuc2l0eV9wcmlvcl9ib3g6dm4scHJpb3JfYm94OlBufSxibj1uZXcgSjshZnVuY3Rpb24obixlLHQpe3UuYmFja2VuZD1uLGUmJih1LmJhY2tlbmRJbnN0YW5jZT1lKSx0JiZPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChmdW5jdGlvbihuKXshZnVuY3Rpb24obixlKXt2YXIgdD1uLmNvbmYsbz1uLnBhcmFtcyxyPW4ubWFpbixpPW4ubWFpbkZ1bmMscz1uLnRleHR1cmVGdW5jQ29uZixhPW4uY29tbW9uRnVuY0NvbmYsbD1uLmJlaGF2aW9ycyxjPXZvaWQgMD09PWw/W106bCxmPXUuYmFja2VuZCtcIl9cIitlO3Uub3BSZWdpc3RyeS5vcHNbZl18fCh1Lm9wUmVnaXN0cnkub3BzW2ZdPXtuYW1lOmUsY29uZjp0LHBhcmFtczpvLG1haW46cixtYWluRnVuYzppLHRleHR1cmVGdW5jQ29uZjpzLGNvbW1vbkZ1bmNDb25mOmEsYmVoYXZpb3JzOmN9KX0odFtuXSxuKX0pKX0oXCJ3ZWJnbFwiLGJuLHhuKX19LGU9e307ZnVuY3Rpb24gdChvKXtpZihlW29dKXJldHVybiBlW29dLmV4cG9ydHM7dmFyIHI9ZVtvXT17ZXhwb3J0czp7fX07cmV0dXJuIG5bb10ocixyLmV4cG9ydHMsdCksci5leHBvcnRzfXJldHVybiB0LmQ9KG4sZSk9Pntmb3IodmFyIG8gaW4gZSl0Lm8oZSxvKSYmIXQubyhuLG8pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkobixvLHtlbnVtZXJhYmxlOiEwLGdldDplW29dfSl9LHQuZz1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzKXJldHVybiBnbG9iYWxUaGlzO3RyeXtyZXR1cm4gdGhpc3x8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaChuKXtpZihcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93KXJldHVybiB3aW5kb3d9fSgpLHQubz0obixlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sZSksdC5yPW49PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSx0KDY0Nil9KSgpfV0pfSkpOyJdLCJzb3VyY2VSb290IjoiIn0=